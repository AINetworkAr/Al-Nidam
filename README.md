# دورة تصميم النظم

مرحبًا، أهلاً بك في الدورة. آمل أن توفر لك هذه الدورة تجربة تعلم رائعة.

_يمكنك أيضًا الحصول على هذه الدورة على موقعي الإلكتروني [هنا](https://karanpratapsingh.com/courses/system-design) وكذلك ككتاب إلكتروني على [leanpub](https://leanpub.com/systemdesign). يُرجى تقييم الدورة بنجمة واحدة كتحفيز إذا كانت مفيدة لك!_



# جدول المحتويات

- **مقدمة**

  - [ما هو تصميم النظم؟](#what-is-system-design)

- **الفصل الأول**

  - [بروتوكول الإنترنت (IP)](#ip)
  - [نموذج OSI](#osi-model)
  - [بروتوكولات TCP و UDP](#tcp-and-udp)
  - [نظام اسم المجال (DNS)](#domain-name-system-dns)
  - [توازن الحمل (Load Balancing)](#load-balancing)
  - [التجميع (Clustering)](#clustering)
  - [التخزين المؤقت (Caching)](#caching)
  - [شبكة توزيع المحتوى (CDN)](#content-delivery-network-cdn)
  - [البروكسي (Proxy)](#proxy)
  - [التوفر (Availability)](#availability)
  - [التوسعية (Scalability)](#scalability)
  - [التخزين (Storage)](#storage)

- **الفصل الثاني**

  - [قواعد البيانات ونظام إدارة قواعد البيانات (DBMS)](#databases-and-dbms)
  - [قواعد البيانات ذات اللغة الهيكلية (SQL)](#sql-databases)
  - [قواعد البيانات غير اللغة الهيكلية (NoSQL)](#nosql-databases)
  - [قواعد البيانات ذات اللغة الهيكلية مقابل قواعد البيانات غير اللغة الهيكلية](#sql-vs-nosql-databases)
  - [تكرار قاعدة البيانات (Database Replication)](#database-replication)
  - [الفهارس (Indexes)](#indexes)
  - [التطبيع والتجانس (Normalization and Denormalization)](#normalization-and-denormalization)
  - [نماذج الاتساق ACID و BASE](#acid-and-base-consistency-models)
  - [نظرية CAP](#cap-theorem)
  - [نظرية PACELC](#pacelc-theorem)
  - [المعاملات (Transactions)](#transactions)
  - [المعاملات الموزعة (Distributed Transactions)](#distributed-transactions)
  - [التجزئة (Sharding)](#sharding)
  - [التجزئة الهاشية المتسقة (Consistent Hashing)](#consistent-hashing)
  - [التوحيد القاعدي (Database Federation)](#database-federation)

- **الفصل الثالث**

  - [الهندسة المتعددة الطبقات (N-tier architecture)](#n-tier-architecture)
  - [وسطاء الرسائل (Message Brokers)](#message-brokers)
  - [قوائم الرسائل (Message Queues)](#message-queues)
  - [النشر والاشتراك (Publish-Subscribe)](#publish-subscribe)
  - [حافلة الخدمات المؤسسية (ESB)](#enterprise-service-bus-esb)
  - [الأحجام الضخمة والخدمات المصغرة (Monoliths and Microservices)](#monoliths-and-microservices)
  - [هندسة المعمارية المستندة إلى الأحداث (EDA)](#event-driven-architecture-eda)
  - [تتبع الأحداث (Event Sourcing)](#event-sourcing)
  - [فصل المسؤولية بين الأوامر والاستعلامات (CQRS)](#command-and-query-responsibility-segregation-cqrs)
  - [بوابة واجهة برمجة التطبيقات (API Gateway)](#api-gateway)
  - [REST وGraphQL وgRPC](#rest-graphql-grpc)
  - [الاستطلاع الطويل والمقابس الشبكية وأحداث الخادم المُرسَل (SSE)](#long-polling-websockets-server-sent-events-sse)

- **الفصل الرابع**

  - [التشفير الجغرافي وأشجار الرباعيات (Geohashing and Quadtrees)](#geohashing-and-quadtrees)
  - [المفتاح الكهربائي (Circuit breaker)](#circuit-breaker)
  - [تحديد المعدل (Rate Limiting)](#rate-limiting)
  - [اكتشاف الخدمات (Service Discovery)](#service-discovery)
  - [SLA و SLO و SLI](#sla-slo-sli)
  - [استعادة الكوارث (Disaster recovery)](#disaster-recovery)
  - [الآلات الافتراضية (VMs) والحاويات (Containers)](#virtual-machines-vms-and-containers)
  - [OAuth 2.0 وOpenID Connect (OIDC)](#oauth-20-and-openid-connect-oidc)
  - [تسجيل الدخول الموحد (SSO)](#single-sign-on-sso)
  - [SSL وTLS وmTLS](#ssl-tls-mtls)

- **الفصل الخامس**

  - [مقابلات تصميم النظم](#system-design-interviews)
  - [مُختصر عناوين URL](#url-shortener)
  - [تطبيق واتساب](#whatsapp)
  - [تطبيق تويتر](#twitter)
  - [خدمة نتفليكس](#netflix)
  - [خدمة أوبر](#uber)

- **الملحق**

  - [الخطوات التالية](#next-steps)
  - [المراجع](#references)


# ما هو تصميم النظم؟

قبل أن نبدأ هذه الدورة، دعنا نتحدث عن مفهوم تصميم النظم بشكل عام.

تصميم النظم هو عملية تحديد الهيكلية والواجهات والبيانات لنظام يلبي المتطلبات المحددة. يهدف تصميم النظم إلى تلبية احتياجات الأعمال أو المؤسسة من خلال نظم متماسكة وفعالة. يتطلب هذا التصميم نهجاً منهجياً لبناء وهندسة الأنظمة. يتطلب تصميم نظام جيد أن نفكر في كل شيء، بدءًا من البنية التحتية وصولاً إلى كيفية تخزين البيانات.

## لماذا يُعتبر تصميم النظم مهمًا جدًا؟

يساعد تصميم النظم في تحديد حلاً يلبي متطلبات الأعمال. إنه واحد من أولى القرارات التي يمكننا اتخاذها عند بناء نظام. في كثير من الأحيان، من الضروري التفكير على المستوى العالي نظراً لأن هذه القرارات صعبة التصحيح في وقت لاحق. كما يجعل من السهل استنتاج وإدارة التغييرات المعمارية مع تطور النظام.


# عنوان IP

عنوان IP هو عنوان فريد يحدد جهازًا على الإنترنت أو شبكة محلية. تعني الحروف IP "بروتوكول الإنترنت"، وهو مجموعة من القواعد التي تحكم تنسيق البيانات المرسلة عبر الإنترنت أو الشبكة المحلية.

بشكل أساسي، تعتبر عناوين IP المُعرف الذي يسمح بإرسال المعلومات بين الأجهزة على الشبكة. إنها تحتوي على معلومات الموقع وتجعل الأجهزة متاحة للتواصل. يحتاج الإنترنت إلى وسيلة للتمييز بين أجهزة الكمبيوتر المختلفة والموجهات والمواقع الإلكترونية. توفر عناوين IP طريقة للقيام بذلك وتشكل جزءًا أساسيًا من كيفية عمل الإنترنت.

## الإصدارات

الآن، دعنا نتعرف على الإصدارات المختلفة لعناوين IP:

### IPv4

بروتوكول الإنترنت الأصلي هو IPv4 الذي يستخدم تدوينًا رقميًا بالنقاط العشرية بطول 32 بت يسمح فقط بحوالي 4 مليار عنوان IP. في البداية، كان كافيًا تمامًا، ولكن مع نمو انتشار الإنترنت، احتجنا إلى شيء أفضل.

_مثال: `102.22.192.181`_

### IPv6

IPv6 هو بروتوكول جديد تم تقديمه في عام 1998. بدأ نشره في منتصف العقد الثاني من القرن الحادي والعشرين ونظرًا لازدياد مستخدمي الإنترنت بشكل هائل، فإنه لا يزال قائمًا حتى الآن.

يستخدم هذا البروتوكول الجديد تدوينًا بالنص الست عشري الألفا رقمي بطول 128 بت. وهذا يعني أن IPv6 يمكنه توفير حوالي ~340e+36 عنوان IP. هذا أكثر من كافٍ لتلبية الطلب المتزايد لسنوات قادمة.

_مثال: `2001:0db8:85a3:0000:0000:8a2e:0370:7334`_

## أنواع العناوين

لنتناول أنواع عناوين IP:

### عامة (Public)

عنوان IP العام هو العنوان الذي يتم ربط عنوان رئيسي واحد به لشبكتك بأكملها. في هذا النوع من عناوين IP، يكون لدى كل الأجهزة المتصلة نفس عنوان IP.

_مثال: عنوان IP الذي يتم توفيره لجهاز التوجيه الخاص بك من قِبل مزود خدمة الإنترنت._

### خاصة (Private)

عنوان IP الخاص هو رقم IP فريد يتم تعيينه لكل جهاز يتصل بشبكة الإنترنت الخاصة بك، والتي تشمل أجهزة مثل الكمبيوترات والأجهزة اللوحية والهواتف الذكية، والتي تُستخدم في منزلك.

_مثال: عناوين IP التي ينشئها جهاز التوجيه المنزلي لأجهزتك._

### ثابتة (Static)

عنوان IP الثابت لا يتغير وهو عنوان تم إنشاؤه يدويًا بدلاً من تكليفه تلقائياً. عادةً ما تكون هذه العناوين أكثر تكلفة ولكنها أكثر موثوقية.

_مثال: عادةً ما تُستخدم للأمور المهمة مثل خدمات تحديد الموقع الجغرافي الموثوقة، الوصول عن بُعد، استضافة الخادم، إلخ._

### ديناميكية (Dynamic)

يتغير عنوان IP الديناميكي من وقت لآخر وليس دائمًا نفسه. يتم تكليفه من قبل خادم بروتوكول تكوين المضيف الديناميكي (DHCP). عناوين IP

 الديناميكية هي النوع الأكثر شيوعًا لعناوين بروتوكول الإنترنت. إنها أرخص للنشر وتسمح لنا باستخدام عناوين IP مرة أخرى في الشبكة حسب الحاجة.

_مثال: عادةً ما تُستخدم بشكل أكثر شيوعًا للأجهزة الاستهلاكية والاستخدام الشخصي._

# نموذج OSI

نموذج OSI هو نموذج منطقي ومفهومي يحدد اتصالات الشبكة المستخدمة في الأنظمة المفتوحة للتواصل والتفاعل مع الأنظمة الأخرى. يحدد نموذج النظام المفتوح (نموذج OSI) أيضًا شبكة منطقية ويصف بفعالية نقل حزم الكمبيوتر باستخدام طبقات متعددة من البروتوكولات.

يمكن اعتبار نموذج OSI لغة عالمية لشبكات الكمبيوتر. يستند إلى مفهوم تقسيم نظام الاتصال إلى سبع طبقات مجردة، يتم تراكم كل طبقة منها فوق الطبقة السابقة.

## لماذا يهم نموذج OSI؟

نموذج النظام المفتوح (OSI) قد حدد المصطلحات الشائعة المستخدمة في مناقشات الشبكات والوثائق. يسمح لنا ذلك بتفكيك عملية الاتصال المعقدة وتقييم مكوناتها.

على الرغم من أن هذا النموذج لا يُطبق مباشرة في شبكات TCP/IP الأكثر شيوعًا اليوم، إلا أنه ما زال يمكننا من فعل الكثير من الأشياء، مثل:

- جعل عملية إصلاح الأخطاء أسهل والتعرف على التهديدات عبر جميع الطبقات.
- تشجيع مصنعي الأجهزة على إنشاء منتجات شبكية يمكنها التواصل مع بعضها البعض عبر الشبكة.
- ضروري لتطوير عقلية أمان متقدمة.
- تقسيم وظيفة معقدة إلى مكونات أبسط.

## الطبقات

يمكن تعريف الطبقات السبع المجردة لنموذج OSI على النحو التالي، من الأعلى إلى الأسفل:

![osi-model](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-I/osi-model/osi-model.png)

### التطبيق (Application)

هذه هي الطبقة الوحيدة التي تتفاعل مباشرة مع بيانات المستخدم. تعتمد تطبيقات البرامج مثل متصفحات الويب وعملاء البريد الإلكتروني على طبقة التطبيق لبدء الاتصال. ولكن ينبغي أن يكون من الواضح أن تطبيقات البرامج العميل ليست جزءًا من طبقة التطبيق، بل تقوم طبقة التطبيق بالمسؤولية عن البروتوكولات وتلاعب البيانات التي يعتمد عليها البرنامج لتقديم بيانات معنوية للمستخدم. تتضمن بروتوكولات طبقة التطبيق HTTP وكذلك SMTP.

### العرض (Presentation)

طبقة العرض تُسمى أيضًا طبقة الترجمة. تُستخرج البيانات من طبقة التطبيق هنا ويتم تعديلها حسب التنسيق المطلوب لنقلها عبر الشبكة. تتضمن وظائف طبقة العرض الترجمة والتشفير/فك التشفير والضغط.

### الجلسة (Session)

هذه هي الطبقة المسؤولة عن فتح وإغلاق الاتصال بين الجهازين. الوقت الذي يستغرقه الاتصال منذ فتحه حتى إغلاقه يُعرف بالجلسة. تضمن طبقة الجلسة أن تظل الجلسة مفتوحة بما فيه الكفاية لنقل جميع البيانات المتبادلة، ثم تغلق الجلسة على الفور لتجنب إهدار الموارد. تزامن طبقة الجلسة أيضًا نقل البيانات مع نقاط التحقق.

### النقل (Transport)

طبقة النقل (المعروفة أيضًا بالطبقة 4) مسؤولة عن الاتصال من نهاية إلى أخرى بين الجهازين. يشمل ذلك أخذ البيانات من طبقة الجلسة وتجزئتها إلى قطع تسمى الشرائح ق

بل إرسالها إلى طبقة الشبكة (الطبقة 3). كما أنها مسؤولة عن إعادة تجميع الشرائح على الجهاز الاستقبالي إلى بيانات يمكن لطبقة الجلسة استهلاكها.

### الشبكة (Network)

طبقة الشبكة مسؤولة عن تس faciliti faciliting نقل البيانات بين شبكتين مختلفتين. تقوم طبقة الشبكة بتجزئة الشرائح من طبقة النقل إلى وحدات أصغر، تُسمى الحزم، على الجهاز الإرسالي، وإعادة تجميع هذه الحزم على الجهاز الاستقبالي. تبحث طبقة الشبكة أيضًا عن أفضل مسار مادي للبيانات للوصول إلى وجهتها، وهذا ما يُعرف بالتوجيه. إذا كان الجهازين المتصلين على نفس الشبكة، فإن طبقة الشبكة غير ضرورية.

### الرابط البيانات (Data Link)

طبقة الرابط البيانات مشابهة جدًا لطبقة الشبكة، باستثناء أن طبقة الرابط البيانات تس faciliti faciliting نقل البيانات بين جهازين على نفس الشبكة. تأخذ طبقة الرابط البيانات الحزم من طبقة الشبكة وتقسمها إلى أجزاء أصغر تُسمى الإطارات.

### الطبقة المادية (Physical)

تشمل هذه الطبقة المعدات المادية المشاركة في نقل البيانات، مثل الكابلات والمفاتيح (السويتشات). هذه أيضًا الطبقة التي يتم فيها تحويل البيانات إلى تسلسل بتي، وهو سلسلة من الأصفار والواحدات. يجب أن تتفق طبقة المادية في كلا الجهازين على اتفاق إشارة بحيث يمكن تمييز الأصفار عن الواحدات على كلا الجهازين.
# TCP و UDP

## TCP

بروتوكول التحكم في النقل (TCP) هو بروتوكول موجه للاتصالات، مما يعني أنه بمجرد تأسيس الاتصال، يمكن نقل البيانات في كلا الاتجاهين. يحتوي TCP على أنظمة مدمجة لفحص الأخطاء وضمان توصيل البيانات في نفس الترتيب الذي تم إرسالها، مما يجعله البروتوكول المثالي لنقل المعلومات مثل الصور الثابتة، وملفات البيانات، وصفحات الويب.

![tcp](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-I/tcp-and-udp/tcp.png)

ولكن على الرغم من أن TCP موثوق تلقائيًا، فإن آليات ردود الفعل الخاصة به تؤدي أيضًا إلى زيادة العبء التشغيلي، مما يترجم إلى استخدام أكبر لعرض النطاق الترددي المتاح على الشبكة.

## UDP

بروتوكول مستخدم الحزم (UDP) هو بروتوكول بسيط أكثر وغير متصل بالشبكة حيث لا تُطلب خدمات فحص الأخطاء واستعادة البيانات. مع UDP، لا يوجد عبء لفتح اتصال، والحفاظ على اتصال، أو إنهاء اتصال. يتم إرسال البيانات باستمرار إلى المستلم، سواء كان قد استلمها أم لا.

![udp](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-I/tcp-and-udp/udp.png)

يفضل بشكل كبير في حالات الاتصالات في الوقت الحقيقي مثل البث أو النقل المتعدد الاتجاهات. ينبغي أن نستخدم UDP على TCP عندما نحتاج إلى أدنى تأخير ويكون فقدان البيانات أسوأ من فقدان البيانات.

## TCP مقابل UDP

TCP هو بروتوكول موجه للاتصال، بينما UDP هو بروتوكول غير متصل بالشبكة. الفرق الرئيسي بين TCP و UDP هو السرعة، حيث يكون TCP أبطأ نسبيًا من UDP. بشكل عام، يعتبر UDP بروتوكولًا أسرع وأبسط وأكثر كفاءة، ولكن يمكن فقط إعادة نقل الحزم المفقودة باستخدام TCP.

يوفر TCP تسليم البيانات بترتيب من المستخدم إلى الخادم (والعكس بالعكس)، بينما لا تُكرّس UDP للاتصالات من طرف إلى طرف، ولا يفحص جاهزية المستقبل.

| الميزة              | TCP                                            | UDP                              |
| -------------------- | --------------------------------------------- | -------------------------------- |
| الاتصال             | يتطلب اتصال مؤسس                             | بروتوكول بدون اتصال            |
| توصيل مضمون        | يمكن ضمان توصيل البيانات                  | لا يمكن ضمان توصيل البيان

ات   |
| إعادة النقل        | يمكن إعادة نقل الحزم المفقودة             | لا توجد إعادة نقل للحزم المفقودة |
| السرعة              | أبطأ من UDP                                  | أسرع من TCP                    |
| البث المتعدد       | لا يدعم البث المتعدد                        | يدعم البث المتعدد              |
| حالات الاستخدام    | HTTPS، HTTP، SMTP، POP، FTP، وغيرها         | بث الفيديو، DNS، VoIP، وغيرها  |

# نظام أسماء النطاقات (DNS)

في وقت سابق تعلمنا عن عناوين IP التي تمكّن كل جهاز من الاتصال بالأجهزة الأخرى. ولكن كما نعلم، يفضل البشر التعامل مع الأسماء بدلاً من الأرقام. فمن الأسهل تذكر اسم مثل `google.com` بدلاً من شيء مثل `122.250.192.232`.

وهذا يجلبنا إلى نظام أسماء النطاقات (DNS) وهو نظام تسمية هرمي ومركزي يُستخدم لتحويل أسماء النطاقات التي يمكن قراءتها بواسطة الإنسان إلى عناوين IP.

## كيفية عمل DNS

يتضمن بحث DNS الخطوات التالية الثمانية:

1. يقوم العميل بكتابة [example.com](http://example.com) في متصفح الويب، ويتم نقل الاستعلام عبر الإنترنت ويتم استقباله من قبل حل المسمى DNS.
2. يقوم حل المسمى DNS بالاستعلام بشكل متكرر إلى خادم جذر DNS.
3. يقوم خادم الجذر بالرد على حل المسمى بمعلومات حول خادم نطاق أعلى (TLD).
4. يقوم حل المسمى ثم بإجراء طلب لـ TLD `.com`.
5. يقوم خادم TLD بالرد بعنوان IP لخادم أسماء النطاق، [example.com](http://example.com).
6. في النهاية، يرسل حل المسمى DNS طلبًا إلى خادم أسماء النطاق.
7. يتم إرجاع عنوان IP لـ [example.com](http://example.com) ثم يتم إرساله إلى حل المسمى DNS من قبل خادم أسماء النطاق.
8. يقوم حل المسمى DNS ثم بالرد على متصفح الويب بعنوان IP للنطاق المطلوب أصلاً.

بمجرد تحديد عنوان IP، يجب أن يكون العميل قادرًا على طلب المحتوى من العنوان IP الذي تم تحديده. على سبيل المثال، يمكن أن يعيد العنوان IP المحدد صفحة ويب ليتم عرضها في المتصفح.

## أنواع الخوادم

الآن، دعونا نلقي نظرة على أربعة مجموعات رئيسية من الخوادم التي تشكل بنية DNS.

### حل المسمى DNS

حل المسمى DNS (المعروف أيضًا باسم حل المسمى المتكرر DNS) هو أول محطة في استعلام DNS. يعمل حل المسمى المتكرر كوسيط بين عميل وخادم أسماء DNS. بعد استقبال استعلام DNS من عميل الويب، يرد حل المسمى المتكرر بالبيانات المخبأة أو يرسل طلبًا إلى خادم جذر DNS، تليه طلب آخر إلى خادم TLD، ومن ثم طلب آخر إلى خادم أسماء مخول به. بعد استقبال استجابة من خادم الأسماء المخول به تحتوي على عنوان IP المطلوب، يرسل حل المسمى المتكرر بالاستجابة إلى العميل.

### خادم جذر DNS

يقبل خادم جذر استعلامًا من حل المسمى المتكرر يتضمن اسم نطاق، ويقوم خادم الجذر بالرد على حل المسمى المتكرر بتوجيهه إلى خادم TLD، بناءً على امتداد ذلك النطاق (`.com`، `.net`، `.org`، إلخ). يتم الإشراف على خوادم الجذر من قبل جمعية غير هادفة للربح تُسمى [Internet Corporation for Assigned Names and Numbers (ICANN)](https://www.icann.org).

هناك 13 خادم جذر لأسماء DNS يعرفها كل حل المسمى المتكرر. يُلاحظ أنه على الرغم من وجود 13 خادمًا جذريًا، فإن ذلك لا يعني أن هناك فقط 13 جهازًا في نظام خوادم الجذر. هناك 13 نوعًا من خوادم الجذر، لكن هناك عدة نسخ من كل واحد في جميع أنحاء العالم، تستخدم توجيه [An

ycast](https://en.wikipedia.org/wiki/Anycast) لتوفير استجابة سريعة.

### خادم TLD

يحتفظ خادم TLD بالمعلومات لجميع أسماء النطاق التي تشترك في امتداد نطاق مشترك، مثل `.com`، `.net`، أو أي امتداد آخر يأتي بعد النقطة الأخيرة في عنوان URL.

تتم معالجة خوادم TLD بواسطة [هيئة الأرقام المخصصة للإنترنت (IANA)](https://www.iana.org)، والتي تعد فرعًا لـ [ICANN](https://www.icann.org). تقسم IANA خوادم TLD إلى مجموعتين رئيسيتين:

- **النطاقات العامة على مستوى أعلى**: وهذه النطاقات مثل `.com`، `.org`، `.net`، `.edu`، و `.gov`.
- **نطاقات رمز البلد العلوية**: وتشمل أي نطاقات تخص دولة معينة أو ولاية. أمثلة على ذلك `.uk`، `.us`، `.ru`، و `.jp`.

### خادم أسماء DNS المخول به

يكون خادم أسماء النطاق المخول به عادة آخر خطوة لحل المسمى المتكرر في رحلة للحصول على عنوان IP. يحتوي خادم أسماء النطاق المخول به على معلومات محددة لاسم النطاق الذي يخدمه (مثل [google.com](http://google.com)) ويمكنه توفير عنوان IP لهذا الخادم الموجود في سجل DNS A، أو إذا كان للنطاق سجل CNAME (اسم مستعار)، فسيقوم بتوجيه حل المسمى المتكرر بنطاق اسم مستعار آخر، وفي هذه النقطة يتعين على حل المسمى المتكرر إجراء بحث جديد بالكامل للحصول على سجل من خادم أسماء النطاق المخول به (عادة سجل A يحتوي على عنوان IP). إذا لم يتم العثور على النطاق، يُرجع رسالة NXDOMAIN.

## أنواع الاستعلامات

هناك ثلاثة أنواع من الاستعلامات في نظام DNS:

### الاستعلام المتكرر

في الاستعلام المتكرر، يتطلب عميل DNS أن يستجيب له خادم DNS (عادةً حل المسمى المتكرر) بإما سجل الموارد المطلوب أو رسالة خطأ إذا لم يتمكن حل المسمى المتكرر من العثور على السجل.

### الاستعلام التكراري

في الاستعلام التكراري، يقدم عميل DNS اسم مضيف، ويقوم حل المسمى DNS بإرجاع أفضل إجابة يمكنها. إذا كان حل المسمى المتكرر لديه سجلات DNS ذات الصلة في ذاكرته المخبأة، فيتم إرجاعها. إذا لم يكن الأمر كذلك، فإنه يحيل عميل DNS إلى خادم جذري أو خادم أسماء مخول به آخر الذي يكون أقرب إلى المنطقة المطلوبة لـ DNS. يجب على عميل DNS إعادة الاستعلام

 مباشرةً ضد خادم DNS الذي أحيل إليه.

### الاستعلام غير المتكرر

الاستعلام غير المتكرر هو استعلام يعرف حل المسمى المتكرر بالفعل عن الإجابة. إما أنه يعود بسجل DNS على الفور لأنه يحتوي بالفعل على السجل في ذاكرته المحلية، أو يستعلم خادم أسماء DNS المخول به الذي يحمل المسؤولية عن السجل، مما يعني أنه يحمل بالتأكيد العنوان IP الصحيح لتلك الاسم.

## أنواع السجلات

سجلات DNS (أو ملفات النطاق) هي تعليمات توجد في خوادم أسماء النطاق المخول بها وتوفر معلومات حول نطاق بما في ذلك عنوان IP المرتبط بتلك النطاق وكيفية التعامل مع طلبات تلك النطاق.

تتألف هذه السجلات من سلسلة من الملفات النصية المكتوبة بما يُعرف باسم "نحو DNS". يعتبر نحو DNS مجرد سلسلة من الأحرف المستخدمة كأوامر تخبر خادم DNS بما يجب عليه القيام به. يحتوي جميع سجلات DNS أيضًا على "TTL"، والذي يعني الوقت المتبقي على صلاحية السجل. عند تخزين السجل في الذاكرة المؤقتة، يتم تخزين قيمة TTL المصاحبة له أيضًا. يستمر الخادم في تحديث قيمة TTL للسجل المخزن في الذاكرة المؤقتة، ويقوم بالعد التنازلي كل ثانية. عندما يصل إلى الصفر، يتم حذف السجل أو إزالته من الذاكرة المؤقتة. في تلك النقطة، إذا تم استلام استعلام لذلك السجل، يتعين على خادم DNS بدء عملية الحل.

## DNS المعكوس

بحث DNS المعكوس هو استعلام DNS لاسم النطاق المرتبط بعنوان IP المحدد. يعمل هذا عكس البحث عن استخدام بحث DNS المعكوس بشكل أكثر استخدامًا المعروف باسم بحث DNS المستعرض، حيث يتم استعلام النظام DNS لإرجاع عنوان IP. يستخدم عملية تحليل العنوان IP المعكوس سجلات PTR. إذا لم يكن لدى الخادم سجل PTR، فلن يتمكن من حل البحث المعكوس.

يُستخدم بحث العودة بشكل شائع بواسطة خوادم البريد الإلكتروني. تفحص خوادم البريد الإلكتروني وترى ما إذا كانت رسالة البريد الإلكتروني قد أتت من خادم صالح قبل إدخالها إلى شبكتها. قد ترفض العديد من خوادم البريد الإلكتروني رسائل من أي خادم لا يدعم بحث ال

عودة أو من خادم غير محتمل للغاية.

ملحوظة: قد لا يتم اعتماد بحث DNS المعكوس عالميًا لأنه ليس ضروريًا للوظائف الطبيعية للإنترنت.

## أمثلة

هذه بعض الحلول لإدارة DNS المُستخدمة على نطاق واسع:

- [Route53](https://aws.amazon.com/route53)
- [Cloudflare DNS](https://www.cloudflare.com/dns)
- [Google Cloud DNS](https://cloud.google.com/dns)
- [Azure DNS](https://azure.microsoft.com/en-in/services/dns)
- [NS1](https://ns1.com/products/managed-dns)

# توزيع الحمل

توزيع الحمل يسمح لنا بتوزيع حركة المرور الشبكية الواردة عبر مصادر متعددة لضمان التوافر العالي والموثوقية عن طريق إرسال الطلبات فقط إلى المصادر التي تكون متصلة بالشبكة وجاهزة للعمل. يوفر هذا المرونة في إضافة أو إزالة المصادر حسب الطلب.

![توزيع الحمل](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-I/load-balancing/load-balancer.png)

للحصول على مزيد من التوسعية والاحتياطية، يمكننا تطبيق توزيع الحمل على كل طبقة في نظامنا:

![طبقات توزيع الحمل](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-I/load-balancing/load-balancer-layers.png)

## لكن لماذا؟

يجب أن تكون المواقع الحديثة عالية الحركة قادرة على تلبية مئات الآلاف، إن لم يكن الملايين، من الطلبات المتزامنة من المستخدمين. لتحقيق التوسع الفعال لتلبية هذه الأحمال العالية، يتطلب المعتمد عليه في الحوسبة الحديثة إضافة مزيد من الخوادم.

يمكن أن يكون توزيع الحمل أمام الخوادم وتوجيه طلبات العملاء عبر جميع الخوادم القادرة على تلبية هذه الطلبات بطريقة تزيد من سرعة واستخدام القدرات. يضمن هذا ألا يتم استغلال خادم واحد بشكل مفرط، مما قد يؤدي إلى تدهور الأداء. إذا تعطل خادم واحد، يقوم توزيع الحمل بإعادة توجيه حركة المرور إلى الخوادم المتاحة. عند إضافة خادم جديد إلى مجموعة الخوادم، يقوم توزيع الحمل تلقائيًا ببدء إرسال الطلبات إليه.

## توزيع الأعباء العمل

هذه هي الوظيفة الأساسية التي يقدمها توزيع الحمل ولها العديد من التغييرات الشائعة:

- **بناءً على المضيف**: يوزع الطلبات بناءً على اسم المضيف المطلوب.
- **بناءً على المسار**: يستخدم العنوان الكامل لعنوان URL لتوزيع الطلبات بدلاً من المضيف فقط.
- **بناءً على المحتوى**: يفحص محتوى الرسالة للطلب. يتيح ذلك التوزيع بناءً على المحتوى مثل قيمة معلمة معينة.

## الطبقات

بشكل عام، يعمل توزيع الحمل على أحد المستويين التاليين:

### الطبقة الشبكية

هذا هو توزيع الحمل الذي يعمل على مستوى الشبكة ويعرف أيضًا باسم المستوى 4. يقوم بالتو

جيه بناءً على معلومات الشبكة مثل عناوين IP ولا يمكنه القيام بتوجيه بناءً على المحتوى. عادة ما تكون هذه الأجهزة مخصصة لتوزيع الحمل وتستطيع العمل بسرعة عالية.

### الطبقة التطبيقية

هذا هو توزيع الحمل الذي يعمل على مستوى التطبيق ويعرف أيضًا باسم المستوى 7. يمكن لتوزيع الحمل قراءة الطلبات بأكملها والقيام بتوزيع بناءً على المحتوى. يتيح ذلك إدارة الحمل بناءً على فهم كامل لحركة المرور.

## الأنواع

لنلقي نظرة على أنواع مختلفة من توزيع الحمل:

### البرمجيات

غالبًا ما تكون الحملات البرمجية أسهل في التنفيذ مقارنة بالإصدارات الأجهزة. كما أنها تميل إلى أن تكون أكثر كفاءة من حيث التكلفة ومرونة، وتُستخدم بالتعاون مع بيئات تطوير البرمجيات. يمنحنا النهج البرمجي مرونة تكوين موازن الحمل وفقًا لاحتياجات بيئتنا الخاصة. وقد يكون هذا التحسين في المرونة على حساب الحاجة للقيام بمزيد من العمل لإعداد توازن الحمل. بالمقارنة مع الإصدارات الأجهزة التي توفر نهجًا أكثر تقييدًا، تمنحنا الأنظمة البرمجية حرية أكبر لإجراء التغييرات والترقيات.

تُستخدم الحملات البرمجية على نطاق واسع وتتوفر إما كحلول قابلة للتثبيت تتطلب التكوين والإدارة، أو كخدمة سحابية مُدارة.

### الأجهزة

كما يوحي الاسم، يعتمد توزيع الحمل على الأجهزة الفعلية في الموقع لتوزيع حركة التطبيق والشبكة. يمكن أن تتعامل هذه الأجهزة مع حجم كبير من حركة المرور ولكنها غالبًا ما تحمل تكلفة باهظة ومحدودة إلى حد ما من حيث المرونة.

تشتمل أجهزة توزيع الحمل على برامج محددة تتطلب صيانة وتحديثات عند صدور الإصدارات الجديدة والتصحيحات الأمنية.

### DNS

توزيع الحمل في نظام أسماء النطاقات (DNS) يتضمن تكوين نطاق في نظام أسماء النطاقات بحيث تتم توزيع طلبات العملاء عبر مجموعة من خوادم الخادم.

مع الأسف، يعاني توزيع الحمل في نظام أسماء النطاقات من مشكلات تقلل من موثوقيته وكفاءته. الأمر الأكثر أهمية هو أن نظام أسماء النطاقات لا يتحقق من تعطل الخوادم أو الشبكات أو الأخطاء. دائمًا ما يعيد نفس مجموعة عناوين IP لنطاق حتى إذا كانت الخوادم غير متصلة بالشبكة أو لا يمكن الوصول إليها.

## خوارزميات التوجيه

الآن، دعنا نناقش بعض خوارزميات التوجيه الشائعة المستخدمة:

- **Round-robin**: يتم توزيع الطلبات ع

لى خوادم التطبيق بالتناوب.
- **Weighted Round-robin**: يعتمد على تقنية Round-robin البسيطة ويأخذ في اعتبار خصائص الخادم المختلفة مثل قدرة الحساب ومعالجة حركة المرور باستخدام أوزان يمكن تعيينها عن طريق سجلات DNS من قبل المسؤول.
- **Least Connections**: يتم إرسال طلب جديد إلى الخادم الذي يحتوي على أقل عدد من الاتصالات الحالية إلى العملاء. يتم احتساب القدرة الحسابية النسبية لكل خادم عند تحديد الخادم الذي يحتوي على أقل عدد من الاتصالات.
- **Least Response Time**: يرسل الطلبات إلى الخادم الذي تم اختياره باستخدام معادلة تجمع بين أسرع وقت استجابة وأقل عدد من الاتصالات النشطة.
- **Least Bandwidth**: يقيس حركة المرور بالميجابت في الثانية (ميغابت في الثانية) ويقوم بإرسال طلبات العملاء إلى الخادم الذي يحتوي على أدنى ميجابت في الثانية من حركة المرور.
- **Hashing**: يوزع الطلبات بناءً على مفتاح نحدده مثل عنوان IP الخاص بالعميل أو عنوان URL للطلب.

## المزايا

تلعب توزيع الحمل أيضًا دورًا رئيسيًا في منع التوقف، وتشمل المزايا الأخرى لتوزيع الحمل ما يلي:

- التوسعية
- الاحتياطية
- المرونة
- الكفاءة

## توزيع الأحمال المكررة

كما يمكن أن نتوقع، فإن توزيع الحمل نفسه يمكن أن يكون نقطة فردية للفشل. للتغلب على ذلك، يمكن استخدام خادم آخر أو عدد "N" من خوادم التوزيع في وضع عنقودي.

وإذا كان هناك اكتشاف للفشل وفشل الخادم التوزيع "النشط"، يمكن لخادم آخر "السلبي" أن يتولى السيطرة مما يجعل نظامنا أكثر قدرة على تحمل الأخطاء.

## المميزات

فيما يلي بعض الميزات المطلوبة بشكل شائع لخوادم التوزيع:

- **التوسع التلقائي**: تشغيل وإيقاف الموارد استجابةً لظروف الطلب.
- **جلسات لاصقة**: القدرة على تعيين نفس المستخدم أو الجهاز إلى نفس المصدر للحفاظ على حالة الجلسة على المصدر.
- **فحص الصحة**: القدرة على تحديد ما إذا كان مصدر ما غير متصل أو يعمل بشكل سيئ لإزالته من مجموعة توزيع الحمل.
- **الاتصالات الثابتة**: السماح للخادم بفتح اتصال ثابت مع العميل مثل WebSocket.
- **التشفير**: التعامل مع الاتصالات المشفرة مثل TLS و SSL.
- **الشهادات**: تقديم شهادات للعميل ومصادقة شهادات العميل.
- **ضغط البيانات**: ضغط الاستجابات.
- **التخزين المؤقت**: قد يقدم خادم توزيع الحمل القدرة على تخزين مؤقت للاستجابات.
- **تسجيل الأحداث**: تسجيل بيانات الطلب والاستجابة يمكن أن يكون مسارًا تدقيقًا هامًا أو مصدرًا لبيانات التحليل.
- **تتبع الطلبات**: تعيين معرف فريد لكل طلب لأغراض التسجيل والمراقبة وإصلاح الأخطاء.
- **إعادة التوجيه**: القدرة على إعادة توجيه طلب وارد بناءً على عوامل مثل المسار المطلوب.
- **استجابة ثابتة**: إرجاع استجابة ثابتة للطلب مثل رسالة خطأ.

## أمثلة

فيما يلي بعض حلول توزيع الح

مل المستخدمة على نطاق واسع في الصناعة:

- [Amazon Elastic Load Balancing](https://aws.amazon.com/elasticloadbalancing)
- [Azure Load Balancing](https://azure.microsoft.com/en-in/services/load-balancer)
- [GCP Load Balancing](https://cloud.google.com/load-balancing)
- [DigitalOcean Load Balancer](https://www.digitalocean.com/products/load-balancer)
- [Nginx](https://www.nginx.com)
- [HAProxy](http://www.haproxy.org)



# التجميع (التَّكْتُل)

في المستوى العالي، تكون المجموعة الحاسوبية مجموعة من جهازين أو أكثر، أو عقدتين، تعمل متوازية لتحقيق هدف مشترك. يسمح ذلك بتوزيع الأعباء التي تتألف من عدد كبير من المهام الفردية التي يمكن توازنها بين العقد في التجمُّع. ونتيجةً لذلك، يمكن لهذه المهام استغلال الذاكرة المشتركة وقوة المعالجة لكل جهاز لزيادة الأداء العام.

لبناء تجميع حاسوبي، يجب أن يكون العقد الفردي متصل بشبكة لتمكين التواصل بين العقد. يمكن بعد ذلك استخدام البرامج لربط العقد معًا وتشكيل التجميع. قد يحتوي التجميع على جهاز تخزين مشترك و/أو تخزين محلي في كل عقد.

![cluster](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-I/clustering/cluster.png)

عادةً، يُعين عقدة واحدة على الأقل كعقدة قائدة وتعمل كنقطة الدخول إلى التجمُّع. قد تكون العقدة القائدة مسؤولة عن تفويض العمل الوارد إلى العقد الآخر وإذا لزم الأمر، تجميع النتائج وإرجاع الاستجابة إلى المستخدم.

في الأفضل، يعمل التجميع كما لو أنه نظام واحد. يجب على المستخدم الوصول إلى التجمُّع ألا يحتاج إلى معرفة ما إذا كان النظام عبارة عن تجمُّع أم جهاز فردي. علاوة على ذلك، يجب أن يتم تصميم التجمُّع لتقليل التأخير ومنع التكدس في التواصل بين العقد.

## أنواع التجمُّع

يمكن عمومًا تصنيف التجميعات الحاسوبية إلى ثلاثة أنواع:

1. **مرتفعة الاستعداد (فشل تلقائي)**
2. **توزيع الحمل**
3. **الحوسبة العالية الأداء**

## التكوينات

تتكون أكثر التكوينات المستخدمة بشكل شائع للتجميعات عالية الاستعداد (HA) من نمطين هما: "نشط-نشط" و "نشط-سلبي".

### "نشط-نشط"

![active-active](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-I/clustering/active-active.png)

عادةً، يتألف التجميع "نشط-نشط" من على الأقل عقدين، يعمل كلاهما بنفس نوع الخدمة بنفس الوقت. الغرض الرئيسي من تجميع "نشط-نشط" هو تحقيق توازن الحمولة. يقوم جهاز توزيع الحمولة بتوزيع الأعباء عبر جميع العقد لمنع أي عقدة فردية من أن تتحمل حمولة زائدة. نظرًا لتوافر المزيد من العقد للخدمة، سيكون هناك أيضًا تحسين في الإنتاجية وأوقات الاستجابة.

### "نشط-سلبي"

![active-passive](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-I/clustering/active-passive.png)

مثل تكوين التجميع "نشط-نشط"، يتكون تجميع "نشط-سلبي" أيضًا من على الأقل عقدين. ومع ذلك، كما يوحي الاسم "نشط-سلبي"، لن تكون جميع العقد نشطة. على سبيل المثال، في حالة وجود عقدين، إذا كان العقد الأول نشطًا بالفعل، فإن العقد الثاني يجب أن يكون سلبيًا أو في وضع الاستعداد.

## المزايا

أربعة مزايا رئيسية للتجمُّع الحاسوبي هي:

- التوفر العالي
- التوسعية
- الأداء
- التكل

فة الفعالة

## توازن الحمل مقابل التجميع

تشترك توازن الحمل في بعض الخصائص المشتركة مع التجميع، ولكنهما عمليات مختلفة. يوفر التجميع الاستعدادية ويزيد من القدرة والتوافر. السيرفرات في التجمُّع يدركون بعضهم البعض ويعملون معًا نحو هدف مشترك. ومع ذلك، في حالة توازن الحمل، لا تدرك السيرفرات بعضها البعض. بدلاً من ذلك، يتفاعلون مع الطلبات التي يتلقونها من جهاز توزيع الحمل.

يمكننا استخدام توازن الحمل بالاشتراك مع التجمُّع، لكنه أيضًا قابل للتطبيق في الحالات التي تنطوي على السيرفرات المستقلة التي تشترك في هدف مشترك مثل تشغيل موقع ويب أو تطبيق تجاري أو خدمة ويب أو مورد آخر من موردي تكنولوجيا المعلومات.

## التحديات

أكثر التحديات وضوحًا التي يقدمها التجمُّع هي زيادة تعقيد التثبيت والصيانة. يجب تثبيت نظام التشغيل والتطبيق وتبعياته على كل عقدة بشكل منفصل وتحديثها بانتظام.

يصبح هذا أكثر تعقيدًا إذا كانت العقد في التجميع غير متجانسة. يجب أيضًا مراقبة استخدام الموارد لكل عقدة عن كثب، ويجب أن يتم تجميع السجلات لضمان أن البرامج تتصرف بشكل صحيح.

بالإضافة إلى ذلك، يصبح إدارة التخزين أكثر صعوبة، ويجب أن يمنع جهاز التخزين المشترك من كتابة العقد بعضها البعض ويجب الاحتفاظ بمخازن البيانات الموزعة متزامنة.

## أمثلة

يُستخدم التجمُّع بشكل شائع في الصناعة، وغالبًا ما تُقدم العديد من التقنيات وضع التجمُّع بأنواع مختلفة. على سبيل المثال:

- الحاويات (مثل [Kubernetes](https://kubernetes.io)، [Amazon ECS](https://aws.amazon.com/ecs))
- قواعد البيانات (مثل [Cassandra](https://cassandra.apache.org/_/index.html)، [MongoDB](https://www.mongodb.com))
- التخزين المؤقت (مثل [Redis](https://redis.io/docs/manual/scaling))

# التخزين المؤقت (Caching)

_"هناك فقط شيئين صعبين في علم الحاسوب: إبطال التخزين المؤقت وتسمية الأشياء." - فيل كارلتون_

![التخزين المؤقت](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-I/caching/caching.png)

الهدف الأساسي للتخزين المؤقت هو زيادة أداء استرداد البيانات عن طريق تقليل الحاجة للوصول إلى الطبقة البطيئة الأساسية للتخزين. يتم التضحية بالقدرة من أجل السرعة، حيث يخزن التخزين المؤقت عادةً مجموعة من البيانات بشكل مؤقت، بالمقارنة مع قواعد البيانات التي يكون عادةً بياناتها كاملة ودائمة.

يستغل التخزين المؤقت مبدأ قرب المرجعية _"البيانات التي طلبت مؤخرًا من المرجح أن يتم طلبها مرة أخرى"._

## التخزين المؤقت والذاكرة

مثل ذاكرة الحاسوب، يعتبر التخزين المؤقت ذاكرة سريعة ومدمجة تقوم بتخزين البيانات في تسلسل من المستويات، حيث يبدأ المستوى الأول (L1) ويتقدم تدريجيًا إلى المستوى التالي وهكذا. تحمل هذه المستويات التسميات L1، L2، L3، وهكذا. يتم أيضًا كتابة التخزين المؤقت عند الطلب، مثل عند وجود تحديث ويجب حفظ محتوى جديد في التخزين المؤقت لاستبدال المحتوى القديم الذي تم حفظه.

بغض النظر عما إذا كان التخزين المؤقت يتم قراءته أو كتابته، يتم ذلك بشكل تدريجي على شكل كتلة. كل كتلة تحمل علامة (tag) تشمل الموقع الذي تم تخزين البيانات فيه بالتخزين المؤقت. عندما يتم طلب البيانات من التخزين المؤقت، يتم البحث عن البيانات من خلال العلامات للعثور على المحتوى المطلوب في المستوى الأول (L1) من الذاكرة. إذا لم يتم العثور على البيانات الصحيحة، يتم إجراء بحث إضافي في المستوى الثاني (L2).

إذا لم يتم العثور على البيانات هناك، يتم مواصلة البحث في المستوى الثالث (L3)، ثم المستوى الرابع (L4)، وهكذا حتى يتم العثور عليها وقرائتها وتحميله

ا. إذا لم يتم العثور على البيانات في التخزين المؤقت على الإطلاق، يتم كتابتها فيه لاستردادها بسرعة في المرة القادمة.

## الاصطدام والفاقد في التخزين المؤقت

### الاصطدام (Cache hit)

يصف الاصطدام الحالة عندما يتم تقديم المحتوى بنجاح من التخزين المؤقت. تتم البحث في العلامات في الذاكرة بسرعة، وعندما يتم العثور على البيانات وقرائتها، يعتبر ذلك اصطدامًا ناجحًا.

**التخزين المؤقت البارد، الدافئ، والساخن**

يمكن وصف الاصطدام بأنه بارد، دافئ، أو ساخن. في كل حالة من هذه الحالات، يتم وصف سرعة قراءة البيانات.

التخزين المؤقت الساخن يحدث عندما يتم قراءة البيانات من الذاكرة بأسرع معدل ممكن. يحدث هذا عند استرداد البيانات من المستوى الأول (L1).

التخزين المؤقت البارد هو أبطأ معدل ممكن لقراءة البيانات، لكنه ما زال ناجحًا، لأن البيانات تم العثور عليها في المستوى الأدنى من التسلسل الهرمي مثل المستوى الثالث (L3) أو أدنى.

التخزين المؤقت الدافئ يستخدم لوصف البيانات التي تم العثور عليها في المستوى الثاني (L2) أو الثالث (L3). إنه ليس بسرعة التخزين المؤقت الساخن، لكنه أسرع من التخزين المؤقت البارد. عمومًا، يتم استخدام مصطلح التخزين المؤقت الدافئ للتعبير عن بطءه واقترابه من التخزين المؤقت البارد.

### الفاقد (Cache miss)

يشير الفاقد إلى حالة عدم العثور على البيانات عند البحث في الذاكرة. عندما يحدث هذا، يتم نقل المحتوى وكتابته في التخزين المؤقت.

## إبطال التخزين المؤقت

إبطال التخزين المؤقت هو عملية تعلن فيها نظام الحاسوب إدخالات التخزين المؤقت كغير صالحة ويقوم بإزالتها أو استبدالها. إذا تم تعديل البيانات، يجب إبطالها في التخزين المؤقت، فإذا لم يتم ذلك، فقد يتسبب ذلك في تواتر غير متناسق في سلوك التطبيق. هناك ثلاثة أنواع من أنظمة التخزين المؤقت:

### التخزين المؤقت المتجاوب بالكتابة (Write-through cache)

![التخزين المؤقت المتجاوب بالكتابة](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-I/caching/write-through-cache.png)

يتم كتابة البيانات في التخزين المؤقت وفي قاعدة البيانات المقابلة في وقت واحد.

**المزايا**: استرداد سريع، استقامة البيانات الكاملة بين التخزين المؤقت والتخزين الدائم.

**العيوب**: وقت الانتظار الأعلى لعمليات الكتابة.

### التخزين المؤقت المتجاوب بالتجاوز (Write-around cache)

![التخزين المؤقت المتجاوب بالتجاوز](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-I/caching/write-around-cache.png)

تذهب الكتابة مباشرة إلى قاعدة البيانات أو التخزين الدائم، متجاوزةً التخزين المؤقت.

**المزايا**: يمكن أن يؤدي ذلك إلى تقليل الانتظار.

**العيوب**: يزيد من احتمال فقدان التخزين المؤقت بسبب قراءة المعلومات من قاعدة البيانات في حالة فقدان التخزين المؤقت. بالتالي، قد يؤدي ذلك إلى زيادة عدد الفاقدين في التخزين المؤقت، مما يؤدي إلى زيادة زمن الانتظار لعمليات القراءة في التطبيقات التي تقوم بالكتابة وإعادة قراءة المعلومات بسرعة. القراءة تحدث من التخزين الخلفي الأبطأ وتعاني من ارتفاع زمن الانتظار.

### التخزين المؤقت المتأخر في الكتابة (Write-back cache)

![التخزين المؤقت المتأخر في الكتابة](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-I/caching/write-back-cache.png)

يتم كتابة البيانات فقط في طبقة التخزين المؤقت ويتم تأكيد الكتابة بمجرد اكتمال الكتابة في التخزين المؤقت. يتم مزامنة هذه الكتابة في وقت لاحق مع قاعدة البيانات.

**المزايا**: يؤدي إلى تقليل وقت الانتظار وزيادة الإنتاجية لتطبيقات الكتابة المكثفة.

**العيوب**: هناك خطر فقدان البيانات في حالة تعطل التخزين المؤقت. يمكن تحسين هذا من خلال الحصول على موافقة عن كتابة واحدة من أكثر من نسخة في التخزين المؤقت.

## سياسات الطرد من التخزين المؤقت

فيما يلي بعض أشهر سياسات الطرد من التخزين المؤقت:

- **الأولوية للأولوية للأولوية للأولوية (FIFO)**: يقوم التخزين المؤقت بطرد البلوك الذي تم الوصول إليه أولاً بدون اعتبار لكيفية وكم مرة تم الوصول إليه قبل ذلك.
- **الأولوية للأخير للأولوية للأخير (LIFO)**: يقوم التخزين المؤقت بطرد البلوك الذي تم الوصول إليه مؤخرًا بشكل أولوي دون اعتبار لكيفية وكم مرة تم الوصول إليه قبل ذلك.
- **المستخدم الأقل للأولوية للأخير (LRU)**: يقوم بطرد العناصر التي تم استخدامها بشكل أقل في البداية.
- **المستخدم الأكثر للأولوية للأخير (MRU)**: يقوم بطرد العناصر التي تم استخدامها بشكل أكثر من LRU.
- **الأقل استخدامًا للأولوية للأخير (LFU)**: يحسب مدى استخدام العنصر. يتم طرد تلك التي تم استخدامها بشكل أقل في البداية.
- **الاستبدال العشوائي (RR)**: يختار عنصر مرشح بشكل عشوائي ويقوم بطرده لإفساح المساحة عند الحاجة.

## التخزين المؤقت الموزع

![التخزين المؤقت الموزع](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-I/caching/distributed-cache.png)

التخزين المؤقت الموزع هو نظام يجمع بين ذاكرة الوصول العشوائي (RAM) لعدة أجهزة حاسوب متصلة في شبكة واحدة في مخزن بيانات مؤقت واحد مستخدمًا للوصول السريع إلى البيانات. بينما يكون معظم التخزينات المؤقتة تقليديًا في جهاز خادم واحد أو جزء من الأجهزة، يمكن للتخزين المؤقت الموزع أن ينمو ليتجاوز حدود الذاكرة لجهاز كمبيوتر واحد عن طريق ربط عدة أجهزة معًا.

## التخزين المؤقت العالمي

![التخزين المؤقت العالمي](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-I/caching/global-cache.png)

كما يوحي الاسم، سنمتلك تخزين مؤقت مشترك واحد سيستخدمه جميع عقد التطبيق. عندما لا يتم العثور على البيانات المطلوبة في التخزين المؤقت العالمي، فمسؤولية التخزين المؤقت هو العثور على الجزء المفقود من البيانات من مخزن البيانات الأساسي.

## الحالات الاستخدامية

يمكن أن يكون للتخزين المؤقت العديد من الحالات الاستخدامية في العالم الحقيقي مثل:

- التخزين المؤقت لقاعدة البيانات
- شبكة تسليم المحتوى (CDN)
- التخزين المؤقت لنظام اسم النطاق (DNS)
- التخزين المؤقت لواجهة برمجة التطبيق (API)

**متى لا يجب استخدام التخزين المؤقت؟**

لنلق نظرة أيضًا على بعض السيناريوهات التي يجب ألا نستخدم فيها التخزين المؤقت:

- التخزين المؤقت لا يكون مفيدًا عندما يستغرق الوصول إلى التخزين المؤقت بنفس الوقت الذي يستغرقه الوصول إلى مخزن البيانات الأساسي.
- التخزين المؤقت لا يعمل بشكل جيد عندما تكون الطلبات تتكرر بشكل منخفض (أكبر فوض

وية)، لأن أداء التخزين المؤقت يعتمد على أنماط الوصول إلى الذاكرة المتكررة.
- التخزين المؤقت لا يكون مفيدًا عندما يتغير البيانات بشكل متكرر، حيث يتجاوز الإصدار المخزن مؤقتًا ويجب الوصول إلى مخزن البيانات الأساسي في كل مرة.

_من المهم أن نلاحظ أن التخزين المؤقت لا يجب أن يُستخدم كتخزين دائم للبيانات. فهي تُنفذ عادةً في الذاكرة العشوائية لأنها أسرع، وبالتالي يجب أن تُعتبر غير دائمة._

## المزايا

فيما يلي بعض المزايا للتخزين المؤقت:

- يحسن الأداء
- يقلل من التأخير
- يخفف العبء على قاعدة البيانات
- يقلل من تكلفة الشبكة
- يزيد من قدرة القراءة

## أمثلة

وفيما يلي بعض التقنيات المستخدمة عادة للتخزين المؤقت:

- [Redis](https://redis.io)
- [Memcached](https://memcached.org)
- [Amazon Elasticache](https://aws.amazon.com/elasticache)
- [Aerospike](https://aerospike.com)



# شبكة توزيع المحتوى (CDN)

شبكة توزيع المحتوى (CDN) هي مجموعة من الخوادم الموزعة جغرافيًا تعمل معًا لتوفير تسليم سريع للمحتوى على الإنترنت. عمومًا، يتم تقديم الملفات الثابتة مثل HTML/CSS/JS والصور ومقاطع الفيديو من CDN.

![cdn-map](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-I/content-delivery-network/cdn-map.png)

## لماذا استخدام CDN؟

تزيد شبكة توزيع المحتوى (CDN) من توافر المحتوى والتكرارية مع تقليل تكاليف النطاق الترددي وتحسين الأمان. يمكن أن يحسن تقديم المحتوى من خلال CDNs الأداء بشكل كبير حيث يحصل المستخدمون على المحتوى من مراكز البيانات القريبة منهم ولا يتعين على خوادمنا تلبية الطلبات التي يقوم CDN بتحقيقها.

## كيفية عمل CDN؟

![cdn](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-I/content-delivery-network/cdn.png)

في CDN، يحتوي الخادم الأصلي على النسخ الأصلية من المحتوى بينما تكون خوادم الحافة (الحافة) كثيرة وموزعة في مواقع مختلفة حول العالم.

لتقليل المسافة بين الزائرين وخادم موقع الويب، تقوم CDN بتخزين نسخة مخزنة من محتواها في عدة مواقع جغرافية معروفة باسم مواقع الحافة. تحتوي كل موقع حافة على العديد من خوادم التخزين المسؤولة عن تقديم المحتوى للزوار ضمن نطاقها.

بمجرد أن يتم تخزين المحتوى الثابت على جميع خوادم CDN لموقع معين، سيتم تقديم جميع طلبات زوار الموقع اللاحقة للمحتوى الثابت من هذه الخوادم الحافة بدلاً من الأصل، وبالتالي يتم تقليل العبء على الأصل وتحسين القدرة على التوسع.

على سبيل المثال، عندما يطلب شخص ما في المملكة المتحدة موقعنا الذي قد يتم استضافته في الولايات المتحدة، سيتم تقديمه من أقرب موقع حافة مثل موقع لندن. وهذا أسرع بكثير من طلب الزائر للخادم الأصلي والذي سيزيد من وقت الاستجابة.

## الأنواع

تنقسم CDN عمومًا إلى نوعين:

### CDNs الدفع

تتلقى CDNs الدفع محتوى جديد عند حدوث تغييرات على الخادم. نحن نتحمل مسؤولية توفير المحتوى، وتحميله مباشرة إلى CDN، وإعادة كتابة عناوين URL للإشارة إلى CDN. يمكننا تكوين متى ينتهي مفعول المحتوى ومتى يتم تحديثه. يتم تحميل المحتوى فقط عندما يكون جديدًا أو تم تغييره، مما يقلل من حركة المرور ولكن يزيد من التخزين.

تعمل مواقع ذات حركة مرور قليلة أو المواقع التي لا يتم تحديث محتواها كثيرًا بشكل جيد مع CDNs الدفع. يتم وضع المحتوى على CDNs مرة واحدة، بدلاً من إعادة سحبه بفترات منتظمة.

### CDNs الاستحضار

في حالة CDNs الاستحضار، يتم تحديث الذاكرة المؤقتة استنادًا إلى الطلب. عندما يرسل العميل طلبًا يتطلب استحضار الأصول الثابتة من CDN إذا كانت لديها، فإنه سيقوم بجلب الأصول المحدثة حديثًا من الخادم الأصلي وملء ذاكرته المؤقتة بهذا الأصل الجديد، ثم يرسل هذ

ا الأصل المؤقت الجديد للمستخدم.

خلافًا لـ CDNs الدفع، يتم ذلك بأقل قدر من الصيانة لأن تحديثات الذاكرة المؤقتة على خوادم CDN تتم استنادًا إلى طلبات من العميل إلى الخادم الأصلي. يعمل مع CDNs الاستحضار المواقع ذات حركة مرور كبيرة بشكل جيد، حيث يتم توزيع الحركة بشكل أكثر توازناً مع الحفاظ على المحتوى المطلوب مؤخرًا على الـ CDN.

## العيوب

كما نعلم، الأشياء الجيدة تأتي بتكاليف إضافية، لذلك دعونا نناقش بعض العيوب لـ CDNs:

- **تكاليف إضافية**: قد يكون استخدام CDN مكلفًا، خاصة بالنسبة للخدمات التي تتمتع بحركة مرور عالية.
- **قيود**: قامت بعض المنظمات والدول بحظر نطاقات أو عناوين IP لـ CDNs الشهيرة.
- **الموقع**: إذا كان معظم جمهورنا موجود في بلد لا تحتوي فيه CDN على خوادم، فقد يتعين على البيانات على موقعنا عبور مسافة أكبر مما هو الحال بدون استخدام أي CDN.

## أمثلة

فيما يلي بعض CDNs المستخدمة على نطاق واسع:

- [Amazon CloudFront](https://aws.amazon.com/cloudfront)
- [Google Cloud CDN](https://cloud.google.com/cdn)
- [Cloudflare CDN](https://www.cloudflare.com/cdn)
- [Fastly](https://www.fastly.com/products/cdn)


# البروكسي (Proxy)

يعد البروكسي (Proxy) خادمًا وسيطًا بين العميل وخادم الأصل. يتلقى طلبات من العملاء ويحولها إلى خوادم الأصل. عادةً ما يُستخدم البروكسي لتصفية الطلبات وتسجيل الطلبات أو أحيانًا تحويل الطلبات (بإضافة/إزالة العناوين الرأسية، التشفير/فك التشفير، أو الضغط).

## الأنواع

هناك نوعان من البروكسي:

### بروكسي إلى الأمام (Forward Proxy)

البروكسي إلى الأمام، المعروف أيضًا باسم بروكسي أو خادم بروكسي أو بروكسي ويب، هو خادم يجلس أمام مجموعة من أجهزة العميل. عندما تقوم تلك الأجهزة بطلبات للمواقع والخدمات على الإنترنت، يقوم خادم البروكسي بالتقاط هذه الطلبات ثم التواصل مع خوادم الويب نيابةً عن تلك العملاء، كوسيط.

![forward-proxy](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-I/proxy/forward-proxy.png)

**الفوائد**

إليك بعض فوائد بروكسي إلى الأمام:

- حجب الوصول إلى محتوى معين
- السماح بالوصول إلى محتوى مقيد جغرافيًا
- توفير الاختفاء
- تجنب قيود التصفح الأخرى

على الرغم من أن البروكسيات توفر فوائد الاختفاء، إلا أنها يمكنها متابعة معلوماتنا الشخصية. إعداد وصيانة خادم بروكسي يمكن أن يكون مكلفًا ويتطلب تكوينات.

### بروكسي عكسي (Reverse Proxy)

البروكسي العكسي هو خادم يجلس أمام خادم ويب واحد أو أكثر، ويعترض طلبات العملاء. عندما يرسل العملاء طلبات لخادم الأصل لموقع ويب، تُعترض هذه الطلبات من قبل خادم البروكسي العكسي.

الفرق بين بروكسي إلى الأمام وبروكسي عكسي طفيف ولكنه مهم. طريقة بسيطة للتلخيص هي أن البروكسي إلى الأمام يجلس أمام عميل ويضمن أنه لا يتصل أي خادم أصلي أبدًا مباشرةً مع تلك العميل بالتحديد. من ناحية أخرى، يجلس البروكسي العكسي أمام خادم أصلي ويضمن أن أي عميل لا يتصل أبدًا مباشرةً مع ذلك الخادم الأصلي.

![reverse-proxy](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-I/proxy/reverse-proxy.png)

إدخال البروكسي العكسي يؤدي إلى زيادة التعقيد. يعتبر البروكسي العكسي الفردي نقطة فشل فردية، وتكوين عدة بروكسيات عكسية (مثل الحوجة) يزيد من التعقيد أكثر.

**الفوائد**

إليك بعض فوائد استخدام بروكسي عكسي:

- تحسين الأمان
- التخزين المؤقت
- التشفير SSL
- توازن الحمولة
- القدرة على التوسع والمرونة

## توازن الحمولة مقابل البروكسي العكسي

انتظر، أليس البروكسي العكسي مشابهًا لتوازن الحمولة؟ حسنًا، ليس كذلك، حيث يكون توازن الحمولة مفيدًا عندما يكون لدينا عدة خوادم. غالبًا ما يوجه موزعو الحمولة حركة المرور إلى مجموعة من الخوادم التي تؤدي نفس الوظيفة، بينما يمكن أن يكون البروكسي العكسي مفيدًا حتى مع خادم واحد فقط أو خادم تطبيق واحد. يمكن أن يعمل البر

وكسي العكسي أيضًا كموزع للحمولة ولكن ليس العكس. 

## أمثلة

فيما يلي بعض تقنيات البروكسي المستخدمة على نطاق واسع:

- [Nginx](https://www.nginx.com)
- [HAProxy](http://www.haproxy.org)
- [Traefik](https://doc.traefik.io/traefik)
- [Envoy](https://www.envoyproxy.io)

# التوفُّر (Availability)

التوفر هو الوقت الذي يظل فيه النظام قائمًا لأداء وظيفته المطلوبة في فترة زمنية محددة. إنها مقياس بسيط لنسبة الوقت الذي يظل فيه النظام أو الخدمة أو الجهاز قائمًا تحت الظروف العادية.

## تسميات التوفُّر بالأرقام

غالبًا ما يتم تقدير التوفُّر بنسبة الوقت الفعال (أو الوقت الخامل) كنسبة من الوقت الذي تكون فيه الخدمة متوفرة. وعادةً ما يُقاس بعدد الأرقام التسعة.

$$
التوفُّر = \frac{وقت العمل}{(وقت العمل + وقت التعطُّل)}
$$

إذا كان التوفُّر متوفر بنسبة 99.00%، يُقال إنه يمتلك "توفُّر متواجد لمدة 2 تسعة"، وإذا كان 99.9%، يُسمى "3 تسعات"، وهكذا.

| التوفُّر (بالنسبة المئوية) | وقت التعطُّل (سنويًا) | وقت التعطُّل (شهريًا) | وقت التعطُّل (أسبوعيًا) |
| ------------------------ | ------------------ | ----------------- | ------------------ |
| 90% (تسعة واحدة)       | 36.53 يوم         | 72 ساعة          | 16.8 ساعة         |
| 99% (تسعتان)           | 3.65 يوم          | 7.20 ساعة        | 1.68 ساعة         |
| 99.9% (ثلاث تسعات)     | 8.77 ساعة         | 43.8 دقيقة       | 10.1 دقائق        |
| 99.99% (أربع تسعات)    | 52.6 دقيقة        | 4.32 دقيقة       | 1.01 دقيقة        |
| 99.999% (خمس تسعات)    | 5.25 دقيقة        | 25.9 ثانية       | 6.05 ثواني        |
| 99.9999% (ست تسعات)    | 31.56 ثانية       | 2.59 ثواني       | 604.8 ميلّي ثانية |
| 99.99999% (سبع تسعات)  | 3.15 ثانية        | 263 ميلّي ثانية | 60.5 ميلّي ثانية |
| 99.999999% (ثمان تسعات) | 315.6 ميلّي ثانية | 26.3 ميلّي ثانية | 6 ميلّي ثانية     |
| 99.9999999% (تسع تسعات) | 31.6 ميلّي ثانية  | 2.6 ميلّي ثانية  | 0.6 ميلّي ثانية   |

## التوفُّر التتابعي مقابل التوفُّر الموازي

إذا كانت الخدمة تتكون من مكونات متعددة عرضة للفشل، فإن التوفُّر الكلي للخدمة يعتمد على ما إذا كانت المكونات في تتابع أو موازية.

### التتابع

يقل التوفُّر الكلي عندما تكون مكونتان في تتابع.

$$
التوفُّر \space (الكلي) = التوفُّر \space (Foo) * التوفُّر \space (Bar)
$$

على سبيل المثال، إذا كان لدى `Foo` و `Bar` كل منهما توفُّر بنسبة 99.9%، فإن توفُّرهما الإجمالي في

 التتابع سيكون 99.8%.

### الموازاة

يزداد التوفُّر الكلي عندما تكون مكونتان في الموازاة.

$$
التوفُّر \space (الكلي) = 1 - (1 - التوفُّر \space (Foo)) * (1 - التوفُّر \space (Bar))
$$

على سبيل المثال، إذا كان لدى `Foo` و `Bar` كل منهما توفُّر بنسبة 99.9%، فإن توفُّرهما الإجمالي في الموازاة سيكون 99.9999%.

## التوفُّر مقابل الاعتمادية

إذا كان النظام موثوقًا به، فهو متوفّر. ومع ذلك، إذا كان متوفّرًا، فليس بالضرورة أنه موثوقٌ به. بعبارة أخرى، يُسهم الاعتمادية العالية في التوفُّر العالي، ولكن من الممكن تحقيق التوفُّر العالي حتى مع نظام غير موثوق.

## التوفُّر العالي مقابل القدرة على التحمّل

كلا التوفُّر العالي والقدرة على التحمُّل ينطبقان على الأساليب التي توفّر مستويات عالية من الوقت الفعال. ومع ذلك، تختلف وسيلة تحقيق الهدف.

يتميّز النظام القادر على التحمّل بعدم انقطاع الخدمة، لكنه يتطلب تكلفة أعلى بشكل كبير، بينما يكون النظام ذو التوفُّر العالي لديه انقطاعات خدمة طفيفة. يتطلب التحمُّل توفُّرًا كاملاً للأجهزة، بحيث إذا فشل النظام الرئيسي، بدون فقدان في الوقت الفعال، يجب على نظام آخر أن يتولى المهمة.

# التوسعية (Scalability)

التوسعية هي مقياس لمدى استجابة النظام للتغييرات عن طريق إضافة أو إزالة الموارد لتلبية المطالب.

![scalability](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-I/scalability/scalability.png)

لنناقش أنواع مختلفة من التوسعية:

## التوسعية الرأسية

التوسعية الرأسية (المعروفة أيضًا بالتوسع الصعودي) توسع قدرة النظام عن طريق إضافة مزيد من الطاقة إلى الجهاز الحالي. بعبارة أخرى، يُشار بالتوسعية الرأسية إلى تحسين قدرة التطبيق عن طريق زيادة سعة الأجهزة.

### المزايا

- سهولة التنفيذ
- أسهل للإدارة
- استقرار البيانات

### العيوب

- خطر توقف طويل للنظام
- أصعب للترقية
- قد يكون نقطة فشل واحدة

## التوسعية الأفقية

التوسعية الأفقية (المعروفة أيضًا بالتوسع التوازي) توسع نطاق النظام عن طريق إضافة المزيد من الأجهزة. يعمل ذلك على تحسين أداء الخادم عن طريق إضافة مزيد من النسخ إلى مجموعة الخوادم الحالية، مما يتيح توزيع الأحمال بشكل أكثر تكافؤًا.

### المزايا

- زيادة التكرار
- تحسين التحمُّل للأخطاء
- مرونة وكفاءة
- أسهل للترقية

### العيوب

- زيادة التعقيد
- عدم اتساق البيانات
- زيادة الضغط على الخدمات النازلة


# التخزين (Storage)

التخزين هو آلية تمكّن النظام من الاحتفاظ بالبيانات، إما بشكل مؤقت أو دائم. عادةً ما يتم تجاوز هذا الموضوع في سياق تصميم النظام، ولكن من المهم أن نمتلك فهمًا أساسيًا لبعض أنواع التقنيات الشائعة للتخزين التي يمكن أن تساعدنا في ضبط مكونات التخزين. لنناقش بعض المفاهيم المهمة للتخزين:

## مجموعات RAID

مجموعات RAID (Redundant Array of Independent Disks) هي طريقة لتخزين نفس البيانات على الأقراص الصلبة أو محركات الأقراص الصلبة الثابتة (SSD) المتعددة لحماية البيانات في حالة فشل محرك الأقراص.

هناك مستويات RAID مختلفة، ولكن ليس جميعها لهدف توفير الاحتياط. دعنا نناقش بعض مستويات RAID المستخدمة بشكل شائع:

- **RAID 0**: يُعرف أيضًا بـ "التشطيب"، يتم تجزئة البيانات بالتساوي عبر جميع الأقراص في المجموعة.
- **RAID 1**: يُعرف أيضًا بـ "التماثل"، يحتوي ما لا يقل عن قرصين على نسخة دقيقة لمجموعة من البيانات. إذا فشل أحد الأقراص، فسيستمر الآخرون في العمل.
- **RAID 5**: التشطيب مع الزائدة. يتطلب استخدام ما لا يقل عن 3 أقراص، يتم تجزئة البيانات عبر عدة أقراص مثل RAID 0، لكنه يحتوي أيضًا على زائدة موزعة عبر الأقراص.
- **RAID 6**: التشطيب مع زائدة مزدوجة. يشبه RAID 6 RAID 5، لكن بيانات الزائدة يتم كتابتها على قرصين.
- **RAID 10**: يجمع بين التشطيب مع التماثل من RAID 0 و RAID 1. يوفر الأمان عن طريق تكرار جميع البيانات على الأقراص الثانوية بينما يتم استخدام التشطيب عبر كل مجموعة من الأقراص لتسريع نقل البيانات.

### المقارنة

دعنا نقارن كل مستويات RAID المختلفة:

| المميزات         | RAID 0     | RAID 1     | RAID 5     | RAID 6       | RAID 10    |
| ------------------ | --------- | --------- | --------- | ------------ | ---------- |
| الوصف             | تشطيب    | تماثل      | تشطيب مع زائدة | تشطيب مع زائدة مزدوجة | تشطيب وتماثل  |
| الأقراص الدنيا    | 2         | 2         | 3         | 4            | 4          |
| أداء القراءة     | عالي    | عالي    | عالي    | عالي      | عالي      |
| أداء الكتابة     | عالي    | متوسط    | عالي    | عالي      | متوسط    |
| التكلفة           | منخفضة | عالية   | منخفضة | منخفضة      | عالية   |
| الاحتياط          | لا يوجد | فشل أحد الأقراص | فشل أحد الأقراص | فشل قرصين | حتى فشل واحد في كل مجموعة فرعية |
| استخدام السعة    | 100٪    | 50٪     | 67٪-94٪ | 50٪-80٪     | 50٪       |

## الأجلة

الأجلة هي كمية ثابتة من التخزين على قرص أو شريط. غالبًا ما يُستخدم مصطلح "الأجلة" كمرادف للتخزين نفسه، ولكن يُمكن أن يحتوي قرص واحد على أكثر من وحدة أجلة أو يمكن لوحدة أجلة أن تمتد عبر أكثر من قرص واحد.

## التخزين السلسلي

التخزين السلسلي هو حلاً لتخزين البيانات على شكل ملفات وتقديمها ل

لمستخدمين النهائيين على هيئة هيكل أدلة هرمي. الميزة الرئيسية هي توفير حلاً يسهل استخدامه لتخزين الملفات واستردادها. لتحديد ملف في التخزين السلسلي، يتطلب الأمر المسار الكامل للملف. إنه اقتصادي ومنظم بسهولة وعادةً ما يُوجد على محركات الأقراص الثابتة، وهذا يعني أنها تظهر بنفس الشكل تمامًا للمستخدم وعلى القرص الثابت.

مثال: [Amazon EFS](https://aws.amazon.com/efs)، [Azure Files](https://azure.microsoft.com/en-in/services/storage/files)، [Google Cloud Filestore](https://cloud.google.com/filestore)، إلخ.

## التخزين القطعي

التخزين القطعي يقسم البيانات إلى قطع (مجموعات) ويخزنها كأجزاء منفصلة. يتم منح كل قطعة من البيانات مُعرفًا فريدًا، مما يتيح لنظام التخزين وضع القطع الأصغر من البيانات في الموقع الأكثر ملاءمة.

يقوم التخزين القطعي أيضًا بفصل البيانات عن بيئات المستخدم، مما يتيح لهذه البيانات أن تُنتشر عبر بيئات متعددة. ينشئ هذا مسارات متعددة للبيانات ويتيح للمستخدم استردادها بسرعة. عندما يطلب المستخدم أو التطبيق البيانات من نظام التخزين القطعي، يقوم النظام التخزيني الأساسي بإعادة تجميع قطع البيانات وتقديم البيانات للمستخدم أو التطبيق.

مثال: [Amazon EBS](https://aws.amazon.com/ebs).

## التخزين بالكائنات

التخزين بالكائنات، المعروف أيضًا باسم التخزين القائم على الكائنات، يقسم ملفات البيانات إلى أجزاء تُسمى بالكائنات. ثم يقوم بتخزين هذه الكائنات في مستودع واحد، والذي يمكن أن ينتشر عبر أنظمة متعددة متصلة بالشبكة.

مثال: [Amazon S3](https://aws.amazon.com/s3)، [Azure Blob Storage](https://azure.microsoft.com/en-in/services/storage/blobs)، [Google Cloud Storage](https://cloud.google.com/storage)، إلخ.

## NAS

NAS (Network Attached Storage) هو جهاز تخزين متصل بالشبكة يسمح بتخزين البيانات واستردادها من موقع مركزي للمستخدمين المخول لهم الوصول عبر الشبكة. يتمتع أجهزة NAS بالمرونة، مما يعني أنه عند الحاجة إلى تخزين إضافي، يمكننا إضافته إلى ما لدينا. إنه أسرع وأقل تكلفة، ويوفر جميع فوائد السحابة العامة في الموقع، مما يمنحنا التحكم الكامل.

## HDFS

نظام الملفات الموزع Hadoop (HDFS) هو نظام ملفات موزع مصمم للعمل على الأجهزة الرخيصة. HDFS متين للغاية وتم تصميمه ليُنشَّر على أجهزة منخفضة التكلفة. يوفر HDFS وصولًا عالي الإنتاجية إلى بيانات التطبيق وهو مناسب للتطبيقات التي تحتوي على مجموعات بيانات كبيرة. يتشابه HDFS إلى حد كبير مع أنظمة الملفات الموزعة الحالية.

تم تصميم HDFS لتخزين الملفات الكبيرة جدًا عبر أجهزة في مجموعة كبيرة. يتم تخزين كل ملف كمتسلسلة من الكتل، وكل كتلة في المل

ف باستثناء الكتلة الأخيرة تكون نفس الحجم. يتم تكرار كتل الملف للحصول على تحمل الأخطاء.

## قواعد البيانات وأنظمة إدارة قواعد البيانات

## ما هي قاعدة البيانات؟

قاعدة البيانات هي مجموعة من المعلومات المنظمة والمهيكلة، والتي يتم تخزينها عادة بشكل إلكتروني في نظام كمبيوتري. قاعدة البيانات غالبًا ما يتم التحكم فيها بواسطة نظام إدارة قواعد البيانات (DBMS). يُشار إلى المعلومات ونظام إدارة قواعد البيانات، جنبًا إلى جنب مع التطبيقات المرتبطة بهم، باسم نظام قاعدة البيانات، وعادةً يُختصر إلى مصطلح "قاعدة بيانات" فقط.

## ما هو نظام إدارة قواعد البيانات (DBMS)؟

تتطلب قاعدة البيانات عادة برنامجًا شاملًا للبرمجيات المعروف باسم نظام إدارة قواعد البيانات (DBMS). يعمل نظام إدارة قواعد البيانات كواجهة بين قاعدة البيانات والمستخدمين النهائيين أو البرامج، مما يتيح للمستخدمين استرداد البيانات وتحديثها وإدارتها وتحسين تنظيمها. يوفر نظام إدارة قواعد البيانات أيضًا الإشراف والتحكم في قواعد البيانات، مما يتيح العديد من العمليات الإدارية مثل مراقبة الأداء والضبط والنسخ الاحتياطي والاسترداد.

## المكونات

إليك بعض المكونات الشائعة التي توجد في قواعد البيانات المختلفة:

### مخطط (Schema)

يكمن دور المخطط في تعريف شكل هيكل البيانات، وتحديد أنواع البيانات التي يمكن وضعها في أي مكان. يمكن تنفيذ المخططات بصرامة عبر قاعدة البيانات بأكملها، أو بصورة فضفاضة على جزء من قاعدة البيانات، أو قد لا تكون موجودة على الإطلاق.

### جدول (Table)

يحتوي كل جدول على عدة أعمدة تمامًا مثل جدول في جدول بيانات الجداول. يمكن أن يحتوي الجدول على أقل من عمودين وما يصل إلى مائة عمود أو أكثر، اعتمادًا على نوع المعلومات التي يتم وضعها في الجدول.

### عمود (Column)

يحتوي العمود على مجموعة من قيم البيانات من نوع محدد، قيمة واحدة لكل صف في قاعدة البيانات. يمكن أن يحتوي العمود على قيم نصية أو أرقام أو قيم معينة أو الطوابق الزمنية وما إلى ذلك.

### صف (Row)

تُسجل البيانات في جدول في صفوف. يمكن أن يحتوي الجدول على آلاف أو ملايين الصفوف التي تحمل معلومات محددة.

## أنواع

فيما يلي أنواع مختلفة من قواعد البيانات:

- **[SQL](https://karanpratapsingh.com/courses/system-design/sql-databases)**
- **[NoSQL](https://karanpratapsingh.com/courses/system-design/nosql-databases)**
  - المستند (Document)
  - المفتاح-القيمة (Key-value)
  - الرسم البياني (Graph)
  - السلاسل الزمن

ية (Timeseries)
  - العمود الواسع (Wide column)
  - متعدد النماذج (Multi-model)

قواعد البيانات SQL وNoSQL هي مواضيع واسعة وسيتم مناقشتها بشكل منفصل في [قواعد بيانات SQL](https://karanpratapsingh.com/courses/system-design/sql-databases) و[قواعد بيانات NoSQL](https://karanpratapsingh.com/courses/system-design/nosql-databases). تعرف كيف تقارن بينهما في [قواعد بيانات SQL مقابل NoSQL](https://karanpratapsingh.com/courses/system-design/sql-vs-nosql-databases).

## التحديات

بعض التحديات الشائعة التي تواجه أثناء تشغيل قواعد البيانات بمقياس كبير:

- **استيعاب زيادات كبيرة في حجم البيانات**: انفجار البيانات القادمة من الحساسات والأجهزة المتصلة وعشرات المصادر الأخرى.
- **ضمان أمان البيانات**: انتشار اختراقات البيانات في كل مكان هذه الأيام، من المهم أكثر من أي وقت مضى ضمان أمان البيانات ولكن يمكن الوصول إليها بسهولة من قبل المستخدمين.
- **التحاق بالطلب**: تحتاج الشركات إلى الوصول إلى بياناتها في الوقت الحقيقي لدعم صنع القرار في الوقت المناسب ولاستغلال الفرص الجديدة.
- **إدارة وصيانة قاعدة البيانات والبنية التحتية**: بينما تصبح قواعد البيانات أكثر تعقيدًا وتزداد حجوم البيانات، تواجه الشركات تكاليف توظيف مواهب إضافية لإدارة قواعد البيانات الخاصة بها.
- **إزالة الحدود عن قابلية التوسع**: تحتاج الأعمال إلى النمو إذا أرادت أن تبقى على قيد الحياة، ويجب أن تكبر إدارة البيانات معها. لكن من الصعب جدًا التنبؤ بكمية الطاقة التي ستحتاجها الشركة، خاصةً مع قواعد البيانات على الأجهزة الموجودة في الموقع.
- **ضمان متطلبات إقامة البيانات أو سيادة البيانات أو التأخير**: تواجه بعض المنظمات حالات استخدام يكون فيها العمل أفضل عند التشغيل في المواقع. في تلك الحالات، يعتبر الأنظمة المهندسة التي تم تكوينها مسبقًا وتحسينها مسبقًا لتشغيل قاعدة البيانات هي الخيار الأمثل.


# قواعد بيانات SQL

قاعدة بيانات SQL (أو العلاقية) هي مجموعة من عناصر البيانات ذات العلاقات المحددة مسبقًا بينها. يتم تنظيم هذه العناصر كمجموعة من الجداول بأعمدة وصفوف. تُستخدم الجداول لاحتواء المعلومات حول الكائنات التي سيتم تمثيلها في قاعدة البيانات. تحمل كل عمود في الجدول نوعًا معينًا من البيانات ويُخزّن الحقل القيمة الفعلية للسمة. تُمثل الصفوف في الجدول مجموعة من القيم المتعلقة بكائن أو كيان واحد.

يمكن تمييز كل صف في الجدول بمعرّف فريد يُسمى مفتاح رئيسي (Primary Key)، ويمكن جعل صفوف بين جداول متعددة ذات علاقة باستخدام مفاتيح أجنبية (Foreign Keys). يمكن الوصول إلى هذه البيانات بعدة طرق مختلفة دون إعادة تنظيم جداول قاعدة البيانات نفسها. تتبع قواعد قواعد بيانات SQL عادة نموذج الاتساق [ACID](https://karanpratapsingh.com/courses/system-design/acid-and-base-consistency-models#acid).

## العروض المادية

العرض المادي هو مجموعة بيانات محسوبة مسبقًا مُشتقة من مواصفات الاستعلام وتُخزن للاستخدام لاحقًا. نظرًا لأن البيانات محسوبة مسبقًا، فإن استعلام العرض المادي أسرع من تنفيذ استعلام ضد جدول البيانات الأساسي للعرض. يمكن أن تكون هذه الفروق في الأداء ذات أهمية بالغة عند تشغيل استعلام بشكل متكرر أو عندما يكون الاستعلام معقدًا بما يكفي.

يتيح أيضًا العرض المادي تجزئة البيانات ويحسن أداء الاستعلامات المعقدة التي تعمل على مجموعات بيانات كبيرة مما يقلل من حمولات الشبكة. هناك استخدامات أخرى للعروض المادية، ولكنها تستخدم في الغالب للأداء والتكرار.

## مشكلة استعلام N+1

تحدث مشكلة الاستعلام N+1 عندما يقوم طبقة الوصول إلى البيانات بتنفيذ N تعليمة SQL إضافية لاسترداد نفس البيانات التي يمكن استردادها عند تنفيذ استعلام SQL الأساسي. كلما ازدادت قيمة N، زادت عدد التعليمات التي سيتم تنفيذها، وأكبر تأثير على الأداء.

يُرى هذا الأمر بشكل شائع في GraphQL وأدوات ORM (Object-Relational Mapping) ويمكن معالجته بتحسين استعلام SQL أو باستخدام مُحمّل البيانات (dataloader) الذي يجمع الطلبات المتتالية ويجعل طلب بيانات واحد تحت الغطاء.

## المزايا

دعنا نلقي نظرة على بعض المزايا في استخدام قواعد البيانات العلاقية:

- بسيطة ودقيقة
- سهولة الوصول
- استقرار البيانات
- مرونة

## العيوب

فيما يلي عيوب قواعد البيانات العلاقية:

- مكلفة الصيانة
- تطور المخطط الصعب
- تأثيرات الأداء (الانضمام، التجانس، وما إلى ذلك)
- صعوبة التوسع بسبب القابلية الأفقية الضعيفة

## أمثلة

فيما يلي بعض قواعد البيانات العلاقية المستخدمة بشكل شائع:

- [PostgreSQL](https://www.postgresql.org)
- [MySQL](https://www.mysql.com)
- [MariaDB](https://mariadb.org)
- [Amazon Aurora](https://aws.amazon.com/rds/aurora)


# قواعد البيانات NoSQL

NoSQL هي فئة واسعة تشمل أي قاعدة بيانات لا تستخدم SQL كلغة رئيسية للوصول إلى البيانات. تسمى هذه الأنواع من قواعد البيانات أحيانًا بقواعد البيانات غير العلاقية. على عكس قواعد البيانات العلاقية، لا يجب أن تتوافق البيانات في قاعدة بيانات NoSQL مع مخطط محدد مسبقًا. تتبع قواعد البيانات NoSQL عادة نموذج الاتساق [BASE](https://karanpratapsingh.com/courses/system-design/acid-and-base-consistency-models#base).

فيما يلي أنواع مختلفة من قواعد البيانات NoSQL:

### قاعدة الوثائق

قاعدة بيانات الوثائق (المعروفة أيضًا باسم قاعدة بيانات موجهة الوثائق أو مخزن الوثائق) هي قاعدة بيانات تخزن المعلومات في وثائق. إنها قواعد بيانات عامة الاستخدام تخدم مجموعة متنوعة من الحالات الاستخدامية لكل من التطبيقات التحليلية والمعاملاتية.

**المزايا**

- بديهية ومرنة
- سهولة التوسع الأفقي
- عدم وجود مخطط

**العيوب**

- عدم وجود مخطط
- غير علاقي

**أمثلة**

- [MongoDB](https://www.mongodb.com)
- [Amazon DocumentDB](https://aws.amazon.com/documentdb)
- [CouchDB](https://couchdb.apache.org)

### قيمة المفتاح

إحدى أبسط أنواع قواعد البيانات NoSQL، حيث تحفظ قواعد البيانات قيم البيانات كمجموعة من أزواج المفتاح والقيمة التي تتكون من عنصري بيانات لكل منهما. يُشار أحيانًا إلى هذا النوع أيضًا بمتجر المفاتيح والقيمة.

**المزايا**

- بسيطة وأداءها عالي
- قابلية توسعية عالية لحجم المرور الكبير
- إدارة الجلسة
- البحث المحسّن

**العيوب**

- CRUD الأساسي
- لا يمكن تصفية القيم
- نقص القدرة على فهرسة وفحص البيانات
- غير محسّنة للاستعلامات المعقدة

**أمثلة**

- [Redis](https://redis.io)
- [Memcached](https://memcached.org)
- [Amazon DynamoDB](https://aws.amazon.com/dynamodb)
- [Aerospike](https://aerospike.com)

### قاعدة البيانات الرسمية

قاعدة بيانات الرسمية هي قاعدة بيانات NoSQL تستخدم هياكل رسمية للاستعلامات الدلالية مع العقد والحواف والخصائص لتمثيل وتخزين البيانات بدلاً من الجداول أو الوثائق.

تربط الرسم البيانات في المتجر بمجموعة من العقد والحواف، حيث تمثل الحواف العلاقات بين العقد. تسمح العلاقات بربط البيانات في المتجر معًا مباشرة وفي كثير من الحالات يمكن استردادها بعملية واحدة.

**المزايا**

- سرعة الاستعلام
- ليونة ومرونة
- تمثيل بيانات صريح

**العيوب**

- معقدة
- لا يوجد لغة استعلام موحدة

**حالات الاستخدام**

- اكتشاف الاحتيال
- محركات التوصية
- الشبكات الاجتماعية
- رسم الشبكات

**أمثلة**

- [Neo4j](https://neo4j.com)
- [ArangoDB](https://www.arangodb.com)
- [Amazon Neptune](https://aws.amazon.com/neptune)
- [JanusGraph](https://janusgraph.org)


### قاعدة بيانات السلاسل الزمنية

قاعدة بيانات السلاسل الزمنية هي قاعدة بيانات مُحسّنة للبيانات المُختَمَرة بالوقت، أو ما يُعرف بالسلاسل الزمنية.

**المزايا**

- الإدخال والاسترجاع السريع
- تخزين البيانات بكفاءة

**حالات الاستخدام**

- بيانات الإنترنت of Things (IoT)
- تحليل المقاييس
- رصد التطبيقات
- فهم الاتجاهات المالية

**أمثلة**

- [InfluxDB](https://www.influxdata.com)
- [Apache Druid](https://druid.apache.org)

### الأعمدة الواسعة

قواعد البيانات الأعمدة الواسعة، المعروفة أيضًا باسم متاجر الأعمدة الواسعة، هي عديمة التخطيط. يتم تخزين البيانات في أُسُر الأعمدة بدلاً من الصفوف والأعمدة.

**المزايا**

- قابلة للتوسع بشكل كبير، يمكنها التعامل مع بيتابايت من البيانات
- مثالية لتطبيقات بيانات الكبير الحية

**العيوب**

- مكلفة
- زمن الكتابة المتزايد

**حالات الاستخدام**

- تحليل الأعمال
- تخزين البيانات على أساس السمات

**أمثلة**

- [BigTable](https://cloud.google.com/bigtable)
- [Apache Cassandra](https://cassandra.apache.org)
- [ScyllaDB](https://www.scylladb.com)

### قاعدة البيانات متعددة النماذج

تجمع قواعد البيانات متعددة النماذج بين نماذج قواعد البيانات المختلفة (مثل العلاقية، الرسمية، قيمة المفتاح، الوثيقة، إلخ) في واجهة موحدة واحدة. يعني ذلك أنها يمكن أن تستوعب أنواع بيانات مختلفة وفهارس واستعلامات، وتخزين البيانات في أكثر من نموذج واحد.

**المزايا**

- المرونة
- مناسبة للمشاريع المعقدة
- توحيد البيانات

**العيوب**

- معقدة
- أقل نضجًا

**أمثلة**

- [ArangoDB](https://www.arangodb.com)
- [Azure Cosmos DB](https://azure.microsoft.com/en-in/services/cosmos-db)
- [Couchbase](https://www.couchbase.com)

# قواعد بيانات SQL مقابل قواعد بيانات NoSQL

في عالم قواعد البيانات، هناك نوعان رئيسيان من الحلول، وهما قواعد بيانات SQL (العلاقية) وقواعد بيانات NoSQL (غير العلاقية). تختلف كل منهما في الطريقة التي بُني بها، ونوع المعلومات التي يخزنها، وكيفية تخزينها. تتميز قواعد البيانات العلاقية بأنها مُنظَّمة ولها مخططات محددة مسبقًا، بينما تكون قواعد بيانات NoSQL غير منظمة وموزعة ولديها مخطط ديناميكي.

## الاختلافات على المستوى العالي

فيما يلي بعض الاختلافات على المستوى العالي بين قواعد البيانات SQL وقواعد البيانات NoSQL:

### التخزين

تخزن قواعد البيانات SQL البيانات في جداول، حيث يُمثل كل صف كيانًا ويُمثل كل عمود نقطة بيانات عن ذلك الكيان.

تحتوي قواعد بيانات NoSQL على نماذج تخزين بيانات مختلفة مثل مفتاح-قيمة، الرسم، الوثيقة، وما إلى ذلك.

### المخطط

في قواعد البيانات SQL، يتوافق كل سجل مع مخطط ثابت، مما يعني أنه يجب أن يتم تحديد الأعمدة واختيارها قبل إدخال البيانات ويجب أن يحتوي كل صف على بيانات لكل عمود. يمكن تعديل المخطط لاحقًا، ولكن ذلك ينطوي على تعديل قاعدة البيانات باستخدام عمليات الترحيل.

أما في قواعد بيانات NoSQL، فالمخططات ديناميكية. يمكن إضافة الحقول على الطاير، ولا يجب أن يحتوي كل سجل (أو ما يعادله) على بيانات لكل حقل.

### الاستعلام

تستخدم قواعد بيانات SQL لغة الاستعلام المهيكلة (SQL) لتعريف وتلاعب البيانات، وهي قوية جدًا.

في قاعدة بيانات NoSQL، تتركز الاستعلامات على مجموعة من الوثائق. تختلف قواعد البيانات المختلفة في بناء جملة الاستعلام.

### التوسعية

في معظم الحالات الشائعة، تكون قواعد بيانات SQL قابلة للتوسع بشكل رأسي، مما قد يكلف الكثير من المال. يمكن توسيع قاعدة بيانات علاقية عبر خوادم متعددة، لكن هذه عملية تحدية وتستغرق الكثير من الوقت.

من ناحية أخرى، ت

كون قواعد بيانات NoSQL قابلة للتوسع بشكل أفقي، مما يعني أنه يمكننا إضافة المزيد من الخوادم بسهولة إلى بنية قاعدة بيانات NoSQL لمعالجة حركة المرور الكبيرة. يمكن لأي جهاز أو حاسوب سحابي رخيص أن يستضيف قواعد بيانات NoSQL، مما يجعلها أكثر كفاءة من حيث التكلفة من التوسع الرأسي. كما توزع العديد من تقنيات NoSQL البيانات تلقائياً عبر الخوادم.

### الموثوقية

غالبية قواعد البيانات العلاقية متوافقة مع نموذج ACID. لذا، عندما يتعلق الأمر بموثوقية البيانات وضمان أداء العمليات بأمان، تظل قواعد البيانات SQL هي الاختيار الأفضل.

يتنازل معظم حلول NoSQL عن الامتثال لمعيار ACID من أجل الأداء والتوسعية.

## الأسباب

كما هو الحال دائمًا، يجب أن نختار التقنية التي تناسب المتطلبات بشكل أفضل. لذا، دعنا نلقي نظرة على بعض الأسباب لاختيار قاعدة بيانات بناءً على SQL أو NoSQL:

**لقواعد البيانات SQL**

- البيانات المُنظَّمة بمخطط صارم
- البيانات العلاقية
- الحاجة للانضمامات المعقدة
- المعاملات
- استرجاع البيانات بالفهرس سريع جداً

**لقواعد البيانات NoSQL**

- مخطط ديناميكي أو مرن
- البيانات غير العلاقية
- عدم الحاجة للانضمامات المعقدة
- العبء الكبير جداً للبيانات
- الإنتاجية العالية جداً للمداخل والمخارج لكل ثانية (IOPS)


# استنساخ قواعد البيانات

الاستنساخ هو عملية تتضمن مشاركة المعلومات لضمان التوافق بين الموارد المكررة مثل قواعد البيانات المتعددة، بهدف تحسين الموثوقية ومقاومة الأخطاء أو سهولة الوصول.

## استنساخ رئيسي-عبد

يخدم الماستر القراءة والكتابة، ويقوم بتكرار الكتابات إلى واحد أو أكثر من العبيد، التي تخدم فقط القراءة. يمكن للعبيد أيضاً تكرار عبيد إضافيين بتنسيق شبه شجري. إذا تعطل الماستر، يمكن للنظام أن يستمر في العمل في وضع القراءة فقط حتى يتم ترقية عبد ليصبح ماستر أو توفير ماستر جديد.

![استنساخ رئيسي-عبد](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-II/database-replication/master-slave-replication.png)

### المزايا

- النُسخ الاحتياطي لقاعدة البيانات بتأثير ضئيل على الماستر.
- يمكن للتطبيقات قراءة من العبيد دون التأثير على الماستر.
- يمكن أخذ العبيد دون اتصال عن الخط ومزامنتها مرة أخرى مع الماستر دون أي فترة توقف.

### العيوب

- يؤدي الاستنساخ إلى إضافة مزيد من الأجهزة وتعقيد إضافي.
- توقف الماستر يعني إمكانية فقدان البيانات.
- جميع الكتابات يجب أن تتم أيضًا على الماستر في هندسة الماستر-عبد.
- كلما زاد عدد العبيد للقراءة، زاد عدد الكتابات التي يجب أن تكرر، وهو ما سيزيد من تأخير الاستنساخ.

## استنساخ ماستر-ماستر

يخدم كل من الماسترين القراءة/الكتابة ويتنسقان مع بعضهما. إذا تعطل أحد الماسترين، يمكن للنظام أن يستمر في العمل مع كل من القراءة والكتابة.

![استنساخ ماستر-ماستر](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-II/database-replication/master-master-replication.png)

### المزايا

- يمكن للتطبيقات قراءة من كلا الماسترين.
- يوزع حمل الكتابة على كلا عقدة ماستر.
- يوفر الفشل الذاتي البسيط والتلقائي والسريع.

### العيوب

- ليس بسيطاً مثل ماستر-عبد من حيث التكوين والنشر.
- إما أن يكون قليلًا في التوافق أو أن يزيد وقت الكتابة بسبب التزامن.
- يتعين حل المشاكل عند إضافة المزيد من عقدات الكتابة ومع زيادة وقت التأخير.

## الاستنساخ المتزامن مقابل الاستنساخ غير المتزامن

الفرق الرئيسي بين الاستنساخ المتزامن والاستنساخ غير المتزامن هو كيفية كتابة البيانات إلى النسخة المكررة. في الاستنساخ المتزامن، يتم كتابة البيانات إلى التخزين الأساسي والنسخة المكررة في نفس الوقت. وبالتالي، يجب أن تظل النسخة الأساسية والنسخة المكررة متزامنتين دائماً.

بالمقابل، يقوم الاستنساخ غير المتزامن بنسخ البيانات إلى النسخة المكررة بعد كتابة البيانات بالفعل إلى التخزين الأساسي. على الرغم من أن عملية الاستنساخ قد تحدث في الوقت الحقيقي، إلا أنه من الأكثر شيوعاً أن تحدث الاستنساخ بناءً على جدول زمني وهو أكثر فعالية من حيث التكلفة.

# الفهارس

الفهارس معروفة جيدًا عندما يتعلق الأمر بقواعد البيانات، حيث تُستخدم لتحسين سرعة عمليات استرداد البيانات من مخزن البيانات. تعمل الفهارس على تحسين القراءات السريعة على حساب زيادة تكاليف التخزين وبطء عمليات الكتابة (نظرًا لأننا يجب أن نكتب البيانات ونحدث الفهرس أيضًا). تُستخدم الفهارس لتحديد موقع البيانات بسرعة دون الحاجة إلى فحص كل صف في جدول قاعدة بيانات. يمكن إنشاء الفهارس باستخدام عمود واحد أو أكثر من جدول قاعدة بيانات، وذلك لتوفير الأساس للبحث العشوائي السريع والوصول الفعال إلى السجلات المرتبة.

![الفهارس](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-II/indexes/indexes.png)

الفهرس هو هيكل بيانات يمكن أن يُعتبر كجدول فهرس يُشير إلينا إلى المكان الذي توجد فيه البيانات الفعلية. لذا عندما نقوم بإنشاء فهرس على عمود في جدول، نقوم بتخزين ذلك العمود ومؤشر إلى الصف كله في الفهرس. تُستخدم الفهارس أيضًا لإنشاء آراء مختلفة لنفس البيانات. بالنسبة لمجموعات البيانات الكبيرة، هذه طريقة ممتازة لتحديد مرشحات مختلفة أو مخططات الترتيب دون اللجوء إلى إنشاء نسخ إضافية متعددة من البيانات.

إحدى الخصائص التي يمكن أن تكون بها فهارس قاعدة البيانات هي أنها يمكن أن تكون **كثيفة** أو **منقطعة**. يأتي كل من هذه الخصائص مع تجاربه الخاصة. دعنا نلقي نظرة على كيفية عمل كل نوع من الفهارس:

## الفهرس الكثيف

في الفهرس الكثيف، يتم إنشاء سجل فهرس لكل صف في الجدول. يمكن تحديد السجلات مباشرةً حيث يحتوي كل سجل في الفهرس على قيمة مفتاح البحث والمؤشر إلى السجل الفعلي.

![الفهرس الكثيف](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-II/indexes/dense-index.png)

تتطلب الفهارس الكثيفة صيانة أكثر من الفهارس المنقطعة عند وقت الكتابة. نظرًا لأن كل صف يجب أن يكون لديه إدخال، يجب أن تقوم قاعدة البيانات بإدارة الفهرس عند الإدخال والتحديث والحذف. يتطلب وجود إدخال لكل صف أيضًا أن تستهلك الفهارس الكثيفة المزيد من الذاكرة. تتمثل فائدة الفهرس الكثيف في أنه يمكن العثور على القيم بسرعة مع البحث الثنائي فقط. لا تفرض الفهارس الكثيفة أيضًا أية متطلبات ترتيب على البيانات.

## الفهرس المنقطع

في الفهرس المنقطع، يتم إنشاء سجلات فهرس فقط لبعض السجلات.

![الفهرس المنقطع](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-II/indexes/sparse-index.png)


الفهارس المنقطعة تتطلب صيانة أقل من الفهارس الكثيفة عند وقت الكتابة حيث تحتوي فقط على مجموعة من القيم. هذا العبء الأخف يعني أن الإدخالات والتحديثات والحذف سيكونون أسرع. بالنظر إلى أنها تحتوي على عدد أقل من الإدخالات أيضًا، فإن ذلك يعني أن الفهرس سيستخدم ذاكرة أقل. يكون البحث عن البيانات أبطأ نظرًا لأنه عادة ما يتبع البحث الثنائي مسحًا عبر الصفحة. تكون الفهارس المنقطعة اختيارية أيضًا عند العمل مع البيانات المرتبة.

# التطوير والتجانس

## المصطلحات

قبل أن نتقدم أكثر، دعنا نلقي نظرة على بعض المصطلحات المستخدمة بشكل شائع في التطوير والتجانس.

### المفاتيح

**المفتاح الأساسي (Primary key)**: عمود أو مجموعة من الأعمدة يمكن استخدامها لتحديد بشكل فريد كل صف في الجدول.

**المفتاح المركب (Composite key)**: مفتاح أساسي يتكون من عدة أعمدة.

**المفتاح العظمى (Super key)**: مجموعة من جميع المفاتيح التي يمكن أن تحدد بشكل فريد جميع الصفوف الموجودة في جدول.

**المفتاح المرشح (Candidate key)**: السمات التي تحدد الصفوف بشكل فريد في جدول.

**المفتاح الخارجي (Foreign key)**: إشارة إلى المفتاح الأساسي لجدول آخر.

**المفتاح البديل (Alternate key)**: المفاتيح التي ليست مفاتيح أساسية يطلق عليها المفاتيح البديلة.

**المفتاح الاستبدالي (Surrogate key)**: قيمة تُنشأ تلقائيًا من قبل النظام تحدد كل إدخال بشكل فريد في جدول عندما لا يمكن لعمود آخر أن يحمل خصائص مفتاح أساسي.

### الاعتماديات

**الاعتمادية الجزئية (Partial dependency)**: تحدث عندما يحدد المفتاح الأساسي بعض السمات الأخرى.

**الاعتمادية الوظيفية (Functional dependency)**: هو العلاقة القائمة بين سمتين، عادة بين المفتاح الأساسي وسمة غير مفتاحية ضمن جدول.

**الاعتمادية الوظيفية الناقلة (Transitive functional dependency)**: تحدث عندما تحدد بعض السمة غير المفتاحية سمة أخرى.

### التشوهات

تحدث تشوهات قاعدة البيانات عندما يكون هناك عيب في قاعدة البيانات ناتج عن تخطيط غير صحيح أو تخزين كل شيء في قاعدة بيانات مستوية. يتم التعامل مع ذلك عمومًا من خلال عملية التطوير والتجانس.

هناك ثلاثة أنواع من تشوهات قاعدة البيانات:

**تشوه الإدخال (Insertion anomaly)**: يحدث عندما لا يمكننا إدخال بعض السمات في قاعدة البيانات بدون وجود سمات أخرى.

**تشوه التحديث (Update anomaly)**: يحدث في حالة وجود استدراج البيانات والتحديث الجزئي. بعبارة أخرى، يتطلب تحديث صحيح لقاعدة البيانات إجراءات أخرى مثل الإضافة أو الحذف أو كليهما.

**تشوه الحذف (Deletion anomaly)**: يحدث ع

ندما يتطلب حذف بعض البيانات حذف بيانات أخرى.

**مثال**

لنأخذ الجدول التالي الذي لم يتم تطويره:

| المعرف  | الاسم   | الدور              | الفريق |
| --- | ------ | ----------------- | ---- |
| 1   | بيتر  | مهندس برمجيات | أ    |
| 2   | براين  | مهندس ديفوبس   | ب    |
| 3   | هايلي | مدير منتجات   | ج    |
| 4   | هايلي | مدير منتجات   | ج    |
| 5   | ستيف  | مهندس واجهة مستخدم | د    |

فلنتخيل أننا قمنا بتوظيف شخص جديد "جون" ولكنهم قد لا يتم تعيينهم إلى فريق على الفور. سيتسبب هذا في "تشوه الإدخال" حيث لا يوجد بعد سمة الفريق.

ثم، لنقل أن هايلي من الفريق ج تمت ترقيتها، لكي نعكس هذا التغيير في قاعدة البيانات، سيكون علينا تحديث 2 صفوف للحفاظ على التوافق وهذا قد يتسبب في "تشوه التحديث".

أخيرًا، نود إزالة الفريق ب ولكن للقيام بذلك يجب علينا أيضًا إزالة معلومات إضافية مثل الاسم والدور، وهذا مثال على "تشوه الحذف".

## التطوير

التطوير هو عملية تنظيم البيانات في قاعدة بيانات. يشمل ذلك إنشاء الجداول وإقامة العلاقات بين تلك الجداول وفقًا للقواعد المصممة لحماية البيانات وجعل قاعدة البيانات أكثر مرونة من خلال القضاء على التكرار والاعتماديات المتضاربة.

### لماذا نحتاج إلى التطوير؟

الهدف من التطوير هو القضاء على تكرار البيانات وضمان تجانس البيانات. تسمح قاعدة البيانات التي تم تطويرها بالتمديد لتوفير أنواع جديدة من البيانات دون تغيير الهيكل الحالي كثيرًا. نتيجة لذلك، تتأثر التطبيقات التي تتفاعل مع قاعدة البيانات بأدنى قدر.

### أشكال التطوير

التطوير هي سلسلة من الإرشادات للتأكد من أن قاعدة البيانات متطورة. دعونا نناقش بعض أشكال التطوير الأساسية:

**1NF**

لكي يكون الجدول في الصيغة الطبيعية الأولى (1NF)، يجب أن يتبع القواعد التالية:

- لا يُسمح بوجود مجموعات متكررة.
- تحديد كل مجموعة من البيانات ذات الصلة بمفتاح أساسي.
- يجب أن يكون لمجموعة البيانات ذات الصلة جدول منفصل.
- لا يُسمح بخلط أنواع البيانات في نفس العمود.

**2NF**

لكي يكون الجدول في الصيغة الطبيعية الثانية (2NF)، يجب أن يتبع القواعد التالية:

- يستوفي الصيغة الطبيعية الأولى (1NF).
- لا يجب أن يكون هناك أي اعتمادية جزئية.

**3NF**

لكي يكون الجدول في الصيغة الطبيعية الثالثة (3NF)، يجب أن يتبع القواعد التالية:

- يستوفي الصيغة الطبيعية الثانية (2NF).
- لا يُسمح بالاعتماديات الوظيفية الناقلة.

**BCNF**

الصيغة الطبيعية لبويس كود (BCNF) هي نسخة أقوى بقليل من الصيغة الطبيعية الثالثة (3NF) تُستخدم لمعالجة بعض أنواع التشوهات التي لا تتعامل معها 3NF كما تم تعريفها أصلاً. في بعض الأحيان يُعرف أيضًا باسم الصيغة الطبيعية 3.5 (3.5NF).

لكي يكون الجدول في ال

صيغة الطبيعية لبويس كود (BCNF)، يجب أن يتبع القواعد التالية:

- يستوفي الصيغة الطبيعية الثالثة (3NF).
- بالنسبة لكل اعتمادية وظيفية X → Y، يجب أن يكون X المفتاح العظمى.

_هناك المزيد من أشكال التطوير مثل 4NF و 5NF و 6NF ولكننا لن نناقشها هنا. تحقق من هذا [الفيديو المذهل](https://www.youtube.com/watch؟v=GFQaEYEc8_8) الذي يدخل في التفاصيل._

في قاعدة بيانات ذات صلة، يُصف العلاقة عادة بأنها "مطورة" إذا كانت تستوفي الصيغة الطبيعية الثالثة. يكون معظم العلاقات الحاصلة على الصيغة الطبيعية الثالثة خالية من تشوهات الإدخال والتحديث والحذف.

كما هو الحال مع العديد من القواعد والمواصفات الرسمية، فإن السيناريوهات الواقعية لا تسمح دائمًا بالامتثال المثالي. إذا قررت خرق أحد القواعد الثلاث الأولى للتطوير، تأكد من أن تطبيقك يتوقع أي مشاكل يمكن أن تحدث، مثل تكرار البيانات والاعتماديات غير المتسقة.

## التجانس

التجانس هو تقنية تحسين قاعدة البيانات تنطوي على إضافة بيانات مكررة في جدول واحد أو أكثر. يمكن أن يساعد هذا في تجنب الانضمامات المكلفة في قاعدة بيانات ذات صلة. يحاول التجانس تحسين أداء القراءة على حساب بعض أداء الكتابة. يتم كتابة نسخ مكررة من البيانات في جداول متعددة لتجنب الانضمامات المكلفة.

بمجرد أن تصبح البيانات منتشرة باستخدام تقنيات مثل التجزئة والتجزئة، يزيد إدارة الانضمامات عبر الشبكة من تعقيدات المزيد. قد يتجنب التجانس الحاجة إلى الانضمامات المعقدة.

_ملاحظة: التجانس لا يعني عكس التطوير._

### المزايا

دعونا نلقي نظرة على بعض المزايا للتجانس:

- تُسرِّع استرداد البيانات.
- يُسهِّل كتابة الاستعلامات.
- تقليل عدد الجداول.
- سهل الإدارة.

### العيوب

فيما يلي بعض العيوب للتجانس:

- يُكلِّف إدخالات وتحديثات.
- زيادة تعقيد تصميم قاعدة البيانات.
- زيادة تكرار البيانات.
- زيادة فرص عدم الاتساق في البيانات.

# ACID وBASE نماذج التجانس

لنتناول نماذج التجانس ACID وBASE.

## ACID

تتمثل كلمة ACID في Atomicity وConsistency وIsolation وDurability. تُستخدم خصائص ACID للحفاظ على سلامة البيانات أثناء معالجة المعاملات.

من أجل الحفاظ على التجانس قبل وبعد المعاملة، يتبع قواعد البيانات العلاقية خصائص ACID. دعنا نفهم هذه المصطلحات:

### Atomicity (الذرية)

جميع العمليات في المعاملة ناجحة أو يتم التراجع عن كل العمليات.

### Consistency (التجانس)

عند الانتهاء من المعاملة، تكون قاعدة البيانات صالحة هيكليًا.

### Isolation (العزلة)

المعاملات لا تتنافس مع بعضها البعض. يُقيد الوصول الصراعي للبيانات من قبل قاعدة البيانات بحيث تبدو المعاملات كأنها تعمل بتسلسل.

### Durability (الدوام)

بمجرد الانتهاء من المعاملة وتمت كتابة الكتابات والتحديثات على القرص، فإنها ستظل في النظام حتى في حالة حدوث فشل في النظام.

## BASE

مع زيادة كمية البيانات ومتطلبات التوفر العالي، تغيرت أيضًا طريقة تصميم قواعد البيانات بشكل كبير. لزيادة القدرة على التوسع وفي نفس الوقت تحقيق التوفر العالي، ننقل المنطق من قاعدة البيانات إلى خوادم منفصلة. بهذه الطريقة، تصبح قاعدة البيانات أكثر استقلالية وتركز على عملية فعلية لتخزين البيانات.

في عالم قواعد البيانات NoSQL، تكون المعاملات ACID أقل شيوعًا حيث قامت بعض قواعد البيانات بتخفيف متطلبات التجانس الفوري، والانتعاش الفوري للبيانات والدقة للحصول على فوائد أخرى، مثل التوسع والمرونة.

خصائص BASE هي أضعف بكثير من ضمانات ACID، لكن ليس هناك تطابق مباشر بنسبة واحدة لواحد بين نماذج التجانس الاثنين. دعنا نفهم هذه المصطلحات:

### Basic Availability (التوفر الأساسي)

تبدو قاعدة البيانات تعمل معظم الوقت.

### Soft-state (الحالة الناعمة)

التخزينات لا يجب أن تكون متسقة للكتابة، ولا يجب أن تكون النسخ المختلفة متسقة تمامًا في كل الأوقات.

### Eventual consistency (التجانس التدريجي)

قد لا تكون البيانات متسقة على الفور ولكن في النهاية، ستصبح متسقة. القراءات في النظام لا تزال ممكنة على الرغم من أنها قد لا تعطي الاستجابة الصحيحة بسبب عدم التسلسل.

## مزايا ACID مقابل BASE

لا يوجد إجابة صحيحة لما إذا كان تطبيقنا يحتاج إلى نموذج تجانس ACID أو BASE. تم تصميم كل من النماذج لتلبية متطلبات مختلفة. عند اختيار قاعدة بيانات، يجب أن نأخذ في الاعتبار خصائص كلتا النموذجين ومتطلبات تطبيقنا.

بفضل التجانس الضعيف لنموذج BASE، يحتاج المطورون إلى أن يكونوا أكثر ذكاء ودقة بشأن البيانات المتسقة إذا اختاروا تخزين BASE لتطبيقهم. من الضروري أن ت

كون ملمًا بسلوك قاعدة البيانات BASE التي اخترتها والعمل ضمن هذه القيود.

من ناحية أخرى، يمكن أن يكون التخطيط حول قيود BASE أحيانًا عيبًا كبيرًا مقارنة ببساطة المعاملات ACID. قاعدة بيانات ACID كاملة التجانس هي الاختيار المثالي لحالات الاستخدام التي يكون فيها موثوقية البيانات والتجانس أمرًا أساسيًا.

# نظرية CAP

تنص نظرية CAP على أن النظام الموزع يمكن أن يقدم فقط اثنين من الصفات الثلاث المطلوبة: التجانس (Consistency)، التوفر (Availability)، وتحمل التجزئة (Partition tolerance).

![نظرية-CAP](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-II/cap-theorem/cap-theorem.png)

لنلقي نظرة مفصلة على الصفات الثلاث للنظام الموزع المشار إليها في نظرية CAP.

### التجانس (Consistency)

التجانس يعني أن جميع العملاء يرى نفس البيانات في نفس الوقت، بغض النظر عن العقدة التي يتصلون بها. لتحقيق ذلك، يجب عند كتابة البيانات إلى عقدة واحدة، أن يتم توجيهها أو نسخها على الفور عبر جميع العقد في النظام قبل أن تعتبر الكتابة "ناجحة".

### التوفر (Availability)

التوفر يعني أن أي عميل يطلب البيانات يحصل على استجابة، حتى إذا كانت إحدى أو أكثر من العقد متوقفة.

### تحمل التجزئة (Partition tolerance)

تحمل التجزئة يعني أن النظام يستمر في العمل على الرغم من فقدان الرسائل أو فشل جزئي. يمكن للنظام الذي يتحمل التجزئة الاستمرار في العمل حتى في حالة حدوث فشل في الشبكة لا يؤدي إلى فشل الشبكة بأكملها. يتم تكريس البيانات بشكل كاف عبر تجميعات العقد والشبكات للحفاظ على استمرارية النظام عبر الانقطاعات المتقطعة.

## التجارة بين التجانس والتوفر

نحن نعيش في عالم مادي ولا يمكننا ضمان استقرار الشبكة، لذلك يجب على قواعد البيانات الموزعة اختيار تحمل التجزئة (P). هذا يعني التجارة بين التجانس (C) والتوفر (A).

### قاعدة بيانات CA

توفر قاعدة بيانات CA التجانس والتوفر عبر جميع العقد. لا يمكنها فعل ذلك إذا كان هناك تجزء بين أي عقدتين في النظام، وبالتالي لا يمكن تحقيق التحمل من الأخطاء.

**مثال**: [PostgreSQL](https://www.postgresql.org)، [MariaDB](https://mariadb.org).

### قاعدة بيانات CP

توفر قاعدة بيانات CP التجانس وتحمل التجزئة على حساب التوفر. عند حدوث تجزء بين أي عقدتين، يجب على النظام إيقاف العقدة غير المتسقة حتى يتم حل التجزء.

**مثال**: [MongoDB](https://www.mongodb.com)، [Apache HBase](https://hbase.apache.org).

### قاعدة بيانات AP



توفر قاعدة بيانات AP التوفر وتحمل التجزئة على حساب التجانس. عند حدوث تجزء، تظل جميع العقد متاحة ولكن العقد في النهاية الخاطئة قد يعود بإصدار أقدم من البيانات مقارنة بالآخرين. عند حل التجزء، غالبًا ما تقوم قواعد البيانات AP بإعادة مزامنة العقد لإصلاح جميع التناقضات في النظام.

**مثال**: [Apache Cassandra](https://cassandra.apache.org)، [CouchDB](https://couchdb.apache.org).



# نظرية PACELC

نظرية PACELC هي توسيع لنظرية CAP. تنص نظرية CAP على أنه في حالة تجزء الشبكة في نظام موزع، يجب على الشخص الاختيار بين التوفر (A) والتجانس (C).

توسع نظرية PACELC نظرية CAP عن طريق إدخال التأخير (L) كسمة إضافية للنظام الموزع. تنص النظرية على أنه على الرغم من غياب التجزء، يجب على الشخص الاختيار بين التأخير (L) والتجانس (C).

_وصفت نظرية PACELC لأول مرة من قبل [دانيال جي. أبادي](https://scholar.google.com/citations?user=zxeEF2gAAAAJ)._

![نظرية-PACELC](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-II/pacelc-theorem/pacelc-theorem.png)

تم تطوير نظرية PACELC لمعالجة نقطة ضعف رئيسية في نظرية CAP حيث لا تتيح أي احتمالية للأداء أو التأخير.

على سبيل المثال، وفقًا لنظرية CAP، يمكن اعتبار قاعدة بيانات متاحة إذا كانت الاستعلام يرجع استجابة بعد 30 يومًا. من الواضح أن مثل هذا التأخير سيكون غير مقبول لأي تطبيق في العالم الحقيقي.

# العمليات النقل

العملية النقل هي سلسلة من عمليات قاعدة البيانات التي يتم اعتبارها "وحدة عمل واحدة". تنجح العمليات في العملية النقل بالكامل، أو تفشل تمامًا. بهذه الطريقة، تدعم مفهوم العملية النقل سلامة البيانات عند فشل جزء من النظام. ليست كل قواعد البيانات تختار دعم العمليات النقل ACID، غالبًا لأنهم يفضلون الأولويات الأخرى التي يصعب أو لا يمكن تنفيذها معًا نظريًا.

_عادة، تدعم قواعد البيانات العلائقية العمليات النقل ACID، ولا تدعم قواعد البيانات غير العلائقية (هناك استثناءات)._

## الحالات

يمكن أن تكون العملية النقل في قاعدة البيانات في إحدى الحالات التالية:

![حالات-العملية-النقل](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-II/transactions/transaction-states.png)

### نشط

في هذه الحالة، يتم تنفيذ العملية النقل. هذه هي الحالة الأولية لكل عملية نقل.

### تم الاستكمال جزئيًا

عند تنفيذ العملية النهائية للعملية النقل، يكون في حالة استكمال جزئي.

### تم الاستكمال

إذا نفذت العملية النقل جميع عملياتها بنجاح، يكون في حالة استكمال. يتم تأكيد جميع تأثيراتها بشكل دائم على نظام قاعدة البيانات.

### فشل

تكون العملية النقل في حالة فشل إذا فشل أي من الفحوصات التي أجرتها نظام استرداد قاعدة البيانات. لا يمكن للعملية النقل التي فشلت الاستمرار في التقدم.

### ملغى

إذا فشل أي من الفحوصات ووصلت العملية النقل إلى حالة فشل، يقوم مدير الاسترداد بإلغاء جميع عمليات الكتابة على قا

عدة البيانات ليعيد قاعدة البيانات إلى حالتها الأصلية قبل تنفيذ العملية النقل. تُلغى العمليات النقل في هذه الحالة.

يمكن لوحدة استرداد قاعدة البيانات اختيار إحدى العمليتين بعد إلغاء العملية النقل:

- إعادة تشغيل العملية النقل.
- إنهاء العملية النقل.

### انتهى

إذا لم يكن هناك أي تراجع أو جاءت العملية النقل من الحالة المستكملة، فإن النظام متسق وجاهز لعملية نقل جديدة وتم إنهاء العملية القديمة.

# المعاملات الموزعة

المعاملة الموزعة هي مجموعة من العمليات على البيانات التي يتم تنفيذها عبر قواعد بيانات اثنين أو أكثر. عادةً ما يتم تنسيقها عبر عقدات منفصلة متصلة بشبكة، ولكن قد تشمل أيضًا قواعد بيانات متعددة على خادم واحد.

## لماذا نحتاج إلى المعاملات الموزعة؟

على عكس المعاملة ACID على قاعدة بيانات واحدة، تتضمن المعاملة الموزعة تعديل البيانات على قواعد بيانات متعددة. وبناءً عليه، يعد معالجة المعاملات الموزعة أكثر تعقيدًا، لأن قاعدة البيانات يجب أن تنسق الالتزام أو التراجع عن التغييرات في المعاملة كوحدة مكتملة ذاتية.

بعبارة أخرى، يجب أن تقوم كل العقدات بالتأكيد على الالتزام أو العودة إلى الخلف وإلغاء المعاملة بالكامل. وهذا هو السبب في أننا بحاجة إلى المعاملات الموزعة.

الآن، دعنا نلقي نظرة على بعض الحلول الشائعة للمعاملات الموزعة:

## الالتزام المرحلي ذو المرحلتين

![two-phase-commit](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-II/distributed-transactions/two-phase-commit.png)

بروتوكول الالتزام المرحلي ذو المرحلتين (2PC) هو خوارزمية موزعة تنسق جميع العمليات التي تشارك في المعاملة الموزعة حول ما إذا كان يجب الالتزام أو إلغاء (التراجع) المعاملة.

تحقق هذه الخوارزمية هدفها حتى في العديد من حالات فشل النظام المؤقت وبالتالي يُستخدم على نطاق واسع. ومع ذلك، فإنها ليست مقاومة لجميع تكوينات الفشل الممكنة، وفي حالات نادرة، يلزم التدخل اليدوي لتصحيح النتيجة.

هذا البروتوكول يتطلب عقدة مُنسِّقة، والتي تنسق وتراقب بالأساس المعاملة عبر عقدات مختلفة. يحاول المُنسِّق إنشاء توافق بين مجموعة من العمليات في مرحلتين، ومن هنا يأتي الاسم.

### المراحل

يتكون الالتزام المرحلي ذو المرحلتين من المراحل التالية:

**مرحلة التحضير**

تنطوي مرحلة التحضير على تجميع عقدة المنسق الرأي المتفق عليه من كل عقدات المشاركة. سيتم إلغاء المعاملة ما لم تكن كل العقدات قد ردت أنها "مستعدة".

**مرحلة الالتزام**

إذا كان جميع المشاركين يُجيبون على المُنسِّق أنهم "مستعدون"، فإن المُنسِّق يُطلب من جميع العقدات الالتزام بالمعاملة. إذا حدث فشل، فإن المعاملة ستُراجع.

### المشاكل

قد تحدث المشاكل التالية في بروتوكول الالتزام المرحلي ذو المرحلتين:

- ماذا لو حدث فشل في إ

حدى العقدات؟
- ماذا لو فشل المُنسِّق نفسه؟
- إنها بروتوكول معوق.

## الالتزام المرحلي ذو المرحلة الثلاثة

![three-phase-commit](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-II/distributed-transactions/three-phase-commit.png)

الالتزام المرحلي ذو المرحلة الثلاثة (3PC) هو تمديد للالتزام المرحلي ذو المرحلتين حيث يتم تجزئة مرحلة الالتزام إلى مرحلتين. يساعد هذا في حل مشكلة الحجب التي تحدث في بروتوكول الالتزام المرحلي ذو المرحلتين.

### المراحل

يتكون الالتزام المرحلي ذو المرحلة الثلاثة من المراحل التالية:

**مرحلة التحضير**

هذه المرحلة هي نفسها كمرحلة الالتزام المرحلي ذو المرحلتين.

**مرحلة الالتزام الجزئي**

يُصدر المنسِّق رسالة الالتزام الجزئي ويجب على جميع العقدات المشاركة التأكيد عليها. إذا فشلت العقدة في استلام هذه الرسالة في الوقت المناسب، فإن المعاملة ستُراجع.

**مرحلة الالتزام**

تكون هذه الخطوة مشابهة أيضًا لبروتوكول الالتزام المرحلي ذو المرحلتين.

### لماذا تُفيد مرحلة الالتزام الجزئي؟

تحقق مرحلة الالتزام الجزئي من النقاط التالية:

- إذا تم العثور على عقدات المشاركة في هذه المرحلة، فهذا يعني أن كل المشاركين قد أكملوا المرحلة الأولى. تكون إكمال مرحلة التحضير مضمونًا.
- يمكن لكل مرحلة الانتهاء الزمني وتجنب الانتظار غير المحدود.

## السيجا

![sagas](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-II/distributed-transactions/sagas.png)

السيجا هو تسلسل من المعاملات المحلية. يُحدث كل معاملة محلية قاعدة البيانات وينشر رسالة أو حدثًا لتشغيل المعاملة المحلية التالية في السيجا. إذا فشلت المعاملة المحلية لأنها تخالف قاعدة أعمال معينة، فإن السيجا تنفذ سلسلة من المعاملات التعويضية التي تُلغي التغييرات التي تم إجراؤها بواسطة المعاملات المحلية السابقة.

### التنسيق

هناك نهجان شائعان للتنفيذ:

- **الكوروغرافيا**: تنشر كل معاملة محلية أحداث المجال التي تشغل المعاملات المحلية في خدمات أخرى.
- **الأوركسترا**: يخبر الساقن المشاركين بالمعاملات المحلية التي يجب تنفيذها.

### المشاكل

- النمط السيجا صعب جدا للتصحيح.
- هناك خطر من التبعية الدورية بين مشاركي السيجا.
- يفرض عدم وجود عزل بيانات المشارك يتسبب في تحديات متانة.
- الاختبار صعب لأنه يجب أن تكون كل الخدمات تعمل لمحاكاة المعاملة.

# التجزئة (Sharding)

قبل أن نتحدث عن التجزئة (Sharding)، دعنا نتحدث عن تجزئة البيانات:

## تجزئة البيانات

تجزئة البيانات هي تقنية لتقسيم قاعدة بيانات إلى أجزاء أصغر. إنه عملية تقسيم قاعدة بيانات أو جدول عبر عدة أجهزة لتحسين قابلية الإدارة والأداء وتوفر القاعدة البياناتية.

### الأساليب

هناك العديد من الطرق المختلفة التي يمكن استخدامها لتقرير كيفية تجزئة قاعدة بيانات التطبيق إلى قواعد بيانات أصغر متعددة. فيما يلي اثنتان من أكثر الطرق شيوعًا التي تستخدمها التطبيقات ذات الحجم الكبير:

**التجزئة الأفقية (أو التجزئة)**

في هذا الاستراتيجية، نقوم بتجزئة بيانات الجدول أفقيًا استنادًا إلى نطاق القيم المحددة بواسطة _مفتاح التجزئة_. يُشار أيضًا إلى هذا بـ **_تجزئة قاعدة البيانات_**.

**التجزئة العمودية**

في التجزئة العمودية، نقوم بتجزئة البيانات عموديًا استنادًا إلى الأعمدة. نقوم بتقسيم الجداول إلى جداول صغيرة نسبيًا تحتوي على عناصر قليلة، وتكون كل جزء موجودًا في قسم منفصل.

في هذا البرنامج التعليمي، سنركز بشكل خاص على التجزئة.

## ما هي التجزئة؟

التجزئة هو نمط له علاقة بـ _التجزئة الأفقية_، وهو الممارسة الخاصة بفصل صفوف جدول واحد إلى جداول متعددة مختلفة، تُعرف باسم الأقسام أو التجزئات. كل تجزئة لديها نفس البنية والأعمدة، ولكنها تحتوي أيضًا على مجموعة فرعية من البيانات المشتركة. وبالمثل، البيانات الموجودة في كل تجزئة فريدة ومستقلة عن البيانات الموجودة في التجزئات الأخرى.

![sharding](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-II/sharding/sharding.png)

التبرير للتجزئة هو أنه بعد نقطة معينة، فإنه أرخص وأكثر جدوى لتوسيع القاعدة بأكملها عن طريق إضافة المزيد من الأجهزة بدلاً من التوسع عموديًا عن طريق إضافة خوادم قوية. يمكن تنفيذ التجزئة على مستوى التطبيق أو مستوى قاعدة البيانات.

## معايير التجزئة

هناك عدد كبير من المعايير المتاحة لتجزئة البيانات. بعض المعايير الأكثر شيوعًا المستخدمة هي:

### استنادًا إلى القيمة المجموعة

تقوم هذه الاستراتيجية بتقسيم الصفوف إلى أجزاء مختلفة بناءً على خوارزمية التجزئة بدلاً من تجميع صفوف قاعدة البيانات بناءً على الفهارس المتواصلة.

يعتبر عيب هذه الطريقة أنه يصبح من الصعب تكلفة إضافة / إزالة خوادم قاعدة البيانات ديناميكيًا.

### استنادًا إلى القائمة

في التجزئة القائمة، ي

تم تعريف كل جزء واختياره بناءً على القائمة من القيم في عمود بدلاً من مجموعة من النطاقات المتواصلة للقيم.

### استنادًا إلى النطاق

يقوم تجزئة النطاق بتعيين البيانات إلى عدة أجزاء استنادًا إلى نطاقات من قيم المفتاح التجزئة. بعبارة أخرى، نقوم بتجزئة الجدول بحيث يحتوي كل جزء على صفوف ضمن نطاق معين محدد بمفتاح التجزئة.

يجب أن تكون النطاقات متتالية ولكن غير تداخلية، حيث يحدد كل نطاق الحد الأدنى والحد الأعلى غير المتضمن لجزء. يتم إضافة قيم مفتاح التجزئة المساوية أو أعلى من الحد الأعلى للنطاق إلى الجزء التالي.

### التجزئة المركبة

كما يوحي الاسم، تقوم التجزئة المركبة بتجزئة البيانات بناءً على اثنين أو أكثر من تقنيات التجزئة. هنا نقوم بتجزئة البيانات باستخدام تقنية واحدة أولاً، ثم يتم تجزئة كل جزء إلى أجزاء فرعية باستخدام نفس الطريقة أو طريقة أخرى.

## المزايا

لكن لماذا نحتاج إلى التجزئة؟ هنا بعض المزايا:

- **التوافر**: يوفر استقلالية منطقية لقاعدة البيانات المجزأة، مما يضمن توافرًا عاليًا لتطبيقنا. يمكن إدارة الأقسام الفردية بشكل مستقل.
- **قابلية التوسع**: يثبت أنه يزيد من التوسعية عن طريق توزيع البيانات عبر عدة أقسام.
- **الأمان**: يساعد على تحسين أمان النظام من خلال تخزين البيانات الحساسة وغير الحساسة في أقسام مختلفة. يمكن أن يوفر ذلك إدارة وأمانًا أفضل للبيانات الحساسة.
- **أداء الاستعلام**: يحسن أداء النظام. بدلاً من استعلام قاعدة البيانات بأكملها، يجب الآن على النظام الاستعلام عن قسم أصغر فقط.
- **إدارة البيانات**: يقسم الجداول والفهارس إلى وحدات أصغر وأكثر قابلية للإدارة.

## العيوب

- **التعقيد**: يزيد التجزئة من تعقيد النظام بشكل عام.
- **الانضمام عبر التجزئة**: بمجرد أن يتم تجزئة قاعدة بيانات ونشرها عبر العديد من الأجهزة، فإن الانضمامات التي تتعدى التجزئة الأساسية للقاعدة بيانات غالبًا ما لا تكون فعالة من حيث الأداء لأنه يجب استرداد البيانات من العديد من الخوادم.
- **إعادة التوازن**: إذا كان توزيع البيانات غير متجانس أو يوجد الكثير من الحمل على جزء واحد، في مثل هذه الحالات، يجب علينا إعادة توازن أقسامنا بحيث يتم توزيع الط

لبات بالتساوي على قدر الإمكان بين الأقسام.

## متى يجب استخدام التجزئة؟

فيما يلي بعض الأسباب التي قد تجعل التجزئة الاختيار الصحيح:

- استغلال الأجهزة الحالية بدلاً من الأجهزة ذات الأداء العالي.
- الحفاظ على البيانات في مناطق جغرافية مختلفة.
- النمو بسرعة من خلال إضافة مزيد من الأقسام.
- أفضل أداء حيث يكون كل جهاز تحت أقل قدر من الحمل.
- عندما يكون هناك حاجة للمزيد من الاتصالات المتزامنة.


# الهاش المتسق (Consistent Hashing)

دعنا نفهم أولاً المشكلة التي نحاول حلها.

## لماذا نحتاج إلى ذلك؟

في أساليب توزيع البيانات القائمة على الهاش التقليدية، نستخدم دالة الهاش لعمل هاش لمفاتيح التجزئة (مثل معرّف الطلب أو عنوان IP). ثم إذا استخدمنا العملية الباقي عند قسمة عدد المعالجات النهائي (الخادم أو قواعد البيانات). سيكون هذا لنا العقدة التي نريد توجيه طلبنا إليها.

![الهاش البسيط](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-II/consistent-hashing/simple-hashing.png)

$$
\begin{align*}
& هاش(المفتاح_1) \to موقع_1 \bmod N = العقدة_0 \\
& هاش(المفتاح_2) \to موقع_2 \bmod N = العقدة_1 \\
& هاش(المفتاح_3) \to موقع_3 \bmod N = العقدة_2 \\
& ... \\
& هاش(المفتاح_n) \to موقع_n \bmod N = العقدة_{n-1}
\end{align*}
$$

حيث:

`المفتاح`: معرّف الطلب أو عنوان IP.

`الهاش`: نتيجة دالة الهاش.

`N`: إجمالي عدد العقد.

`العقدة`: العقدة التي سيتم توجيه الطلب إليها.

المشكلة مع هذا النهج هو إذا أضفنا أو أزلنا عقدة، فسوف يتسبب ذلك في تغيير `N`، مما يعني أن استراتيجية التعيين لدينا ستتعطل حيث ستكون نفس الطلبات الآن تتم تعيينها إلى خادم مختلف. وبناءً على ذلك، سيتعين علينا إعادة توزيع الغالبية من الطلبات مما يكون غير كفوء جدًا.

نريد توزيع الطلبات بشكل متساوٍ على العقد المختلفة بحيث يمكننا إضافة أو إزالة العقد بأدنى مجهود. لذلك، نحتاج إلى نظام توزيع لا يعتمد مباشرة على عدد العقد (أو الخوادم) بحيث عند إضافة أو إزالة العقد، يتم تقليل عدد المفاتيح التي يجب إعادة توزيعها إلى أدنى حد.

يحل الهاش المتسق هذه المشكلة القابلية للتوسع الأفقي من خلال ضمان أنه في كل مرة نقوم فيها بالتوسع أو التضاءل، لا يتعين علينا إعادة ترتيب جميع المفاتيح أو لمس جميع الخوادم.

الآن بعد أن فهمنا المشكلة، دعونا نناقش الهاش المتسق بالتفصيل.

## كيف يعمل؟

الهاش المتسق هو نظام هاش موزع يعمل بشكل مستقل عن عدد العقد في جدول الهاش الموزع عن طريق تعيينهم موضعًا على دائرة مجردة أو حلقة هاش. يتيح ذلك توسيع الخوادم والكائنات دون التأثير على النظام الكلي.

![الهاش المتسق](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-II/consistent-hashing/consistent-hashing.png)

باستخدام الهاش المتسق، سيتطلب إعادة التوزيع فقط `K/N` من البيانات.

$$
R = K/N
$$

حيث:

`R`: البيانات التي ستتطلب إعادة توزيعها.

`K`: عدد مفاتيح التجزئة.

`N`: عدد العقد.

مخرج دالة الهاش هو نطاق يسمى `0...m-1` والذي يمكننا تمثيله على حلقة الهاش. نحن نقوم بعمل هاش للطلبات وتوزيعها على الحلقة اعتمادًا على ناتج الهاش. ب

المثل، نقوم أيضًا بعمل هاش للعقد وتوزيعها على نفس الحلقة أيضًا.

$$
\begin{align*}
& هاش(المفتاح_1) = الموضع_1 \\
& هاش(المفتاح_2) = الموضع_2 \\
& هاش(المفتاح_3) = الموضع_3 \\
& ... \\
& هاش(المفتاح_n) = الموضع_{m-1}
\end{align*}
$$

حيث:

`المفتاح`: معرف الطلب/العقدة أو عنوان IP.

`الموضع`: الموضع على حلقة الهاش.

`m`: إجمالي نطاق حلقة الهاش.

الآن، عندما يأتي الطلب نستطيع ببساطة توجيهه إلى أقرب عقدة باتجاه عقارب الساعة (يمكن أن تكون عكس عقارب الساعة أيضًا). وهذا يعني أنه عند إضافة عقدة جديدة أو إزالتها، يمكننا استخدام العقدة الأقرب ويتعين إعادة توجيه كسرعة جزء من الطلبات فقط.

من الناحية النظرية، يجب أن يوزع الهاش المتسق الحمل بشكل متساوٍ ولكنه لا يحدث في الواقع. عادةً ما يكون توزيع الحمل غير متساوٍ وقد تنتهي الخادمة بالتعامل مع الغالبية من الطلبات لتصبح مركزًا للنظام. يمكننا حل هذه المشكلة عن طريق إضافة عقدة إضافية ولكن ذلك قد يكون مكلفًا.

دعونا نرى كيف يمكننا التعامل مع هذه المشكلات.

## العقدات الافتراضية

من أجل ضمان توزيع الحمل بشكل أكثر تساوٍ، يمكننا إدخال فكرة العقدة الافتراضية، المعروفة أيضًا بـ VNode.

بدلاً من تعيين موضع واحد لعقدة واحدة، يتم تقسيم نطاق الهاش إلى مجموعات أصغر ويتم تعيين كل عقدة فعلية عدة من هذه المجموعات الأصغر. يُعتبر كل هذه النطاقات الفرعية عقدة افتراضية. بالتالي، العقدات الافتراضية هي عمليا عقدات فعلية موضوعة مرات متعددة عبر حلقة الهاش لتقليل التغييرات على نطاق المعين للعقدة.

![العقدات الافتراضية](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-II/consistent-hashing/virtual-nodes.png)

لهذا، يمكننا استخدام عدد `k` من دوال الهاش.

$$
\begin{align*}
& هاش_1(المفتاح_1) = الموضع_1 \\
& هاش_2(المفتاح_2) = الموضع_2 \\
& هاش_3(المفتاح_3) = الموضع_3 \\
& . . . \\
& هاش_k(المفتاح_n) = الموضع_{m-1}
\end{align*}
$$

حيث:

`المفتاح`: معرف الطلب/العقدة أو عنوان IP.

`k`: عدد دوال الهاش.

`الموضع`: الموضع على حلقة الهاش.

`m`: إجمالي نطاق حلقة الهاش.

مع المساعدة من العقدات الافتراضية، يمكننا توزيع الحمل بشكل أكثر تساوٍ عبر العقدات الفعلية في المجموعة عن طريق تقسيم نطاقات الهاش إلى مجموعات فرعية أصغر. يتسرع عملية إعادة التوازن بعد إضافة أو إزالة العقدة. وهذا أيضًا يساعدنا على تقليل احتمالية نقاط الانفجار.

## التكرار البيانات

لضمان توفير الاتاحة العالية والمتانة، يقوم الهاش المتسق بتكرار كل عنصر بيانات على عدة عقد (N) في النظ

ام حيث قيمة `N` مكافئة لـ_عامل التكرار_.

عامل التكرار هو عدد العقدات التي ستتلقى نسخة من نفس البيانات. في أنظمة الاعتدال النهائي، يتم ذلك بطريقة غير متزامنة.

## المزايا

لنلقي نظرة على بعض المزايا للهاش المتسق:

- يجعل التوسع السريع لأعلى ولأسفل أكثر تنبؤا.
- ييسّر التجزئة والتكرار عبر العقدات.
- يمكن القابلية للتوسع والاتاحة.
- يقلل من نقاط الانفجار.

## العيوب

فيما يلي بعض العيوب للهاش المتسق:

- يزيد من التعقيد.
- الفشل التتابعي.
- موزع الحمل ممكن أن يظل غير متساوٍ.
- يمكن أن يكون إدارة المفاتيح مكلفة عندما يفشل العقد مؤقتًا.

## الأمثلة

لنلقي نظرة على بعض الأمثلة حيث يُستخدم الهاش المتسق:

- تجزئة البيانات في [Apache Cassandra](https://cassandra.apache.org).
- توزيع الحمل عبر مضيفي تخزين متعددين في [Amazon DynamoDB](https://aws.amazon.com/dynamodb).

# التجزئة القاعدة

التجزئة (أو التجزئة الوظيفية) تقسم قواعد البيانات حسب الوظيفة. تعمل هندسة التجزئة على جعل العديد من قواعد البيانات الفعلية المتميزة تظهر كقاعدة بيانات منطقية واحدة للمستخدمين النهائيين.

يتم ربط جميع المكونات في التجزئة بمخططات فيدرالية واحدة أو أكثر تعبر عن التشابه في البيانات في جميع أنحاء التجزئة. تُستخدم هذه المخططات الفدرالية لتحديد المعلومات التي يمكن مشاركتها بواسطة مكونات التجزئة وتوفير أساس مشترك للتواصل بينهم.

![تجزئة القاعدة](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-II/database-federation/database-federation.png)

توفر التجزئة أيضًا رؤية متماسكة وموحدة للبيانات المستمدة من مصادر متعددة. يمكن أن تتضمن مصادر البيانات للأنظمة المتجزئة قواعد البيانات وأشكالًا مختلفة من البيانات المهيكلة وغير المهيكلة.

## السمات

لنلقِ نظرة على بعض السمات الرئيسية لقاعدة بيانات متجزئة:

- **الشفافية**: تخفي قاعدة البيانات المتجزئة اختلافات المستخدم وتنفيذات مصادر البيانات الأساسية. لذلك لا يحتاج المستخدمون إلى أن يكونوا على دراية بمكان تخزين البيانات.
- **التباين**: قد تختلف مصادر البيانات في العديد من الطرق. يمكن لنظام قاعدة البيانات المتجزئة التعامل مع أجهزة مختلفة وبروتوكولات الشبكة ونماذج البيانات وغيرها.
- **القابلية للتوسعة**: قد يكون هناك حاجة لمصادر جديدة لتلبية احتياجات الأعمال المتغيرة. يجب أن يجعل نظام قاعدة بيانات متجزئة جيد تكوين مصادر جديدة بسهولة.
- **الاستقلالية**: قاعدة بيانات متجزئة لا تغير مصادر البيانات الحالية، وواجهاتها يجب أن تظل كما هي.
- **تكامل البيانات**: يمكن لقاعدة بيانات متجزئة أن تدمج البيانات من بروتوكولات مختلفة وأنظمة إدارة قواعد البيانات وغيرها.

## المزايا

إليك بعض المزايا لقواعد البيانات المتجزئة:

- مشاركة البيانات المرن

ة.
- الاستقلالية بين مكونات قاعدة البيانات.
- الوصول إلى البيانات المتباينة بطريقة موحدة.
- عدم الارتباط القوي بين التطبيقات وقواعد البيانات القديمة.

## العيوب

وفيما يلي بعض العيوب لقواعد البيانات المتجزئة:

- يزيد من تعقيد الأجهزة والتعقيد الإضافي.
- تعقيد دمج البيانات من قاعدتي بيانات.
- الاعتماد على مصادر بيانات مستقلة.
- أداء الاستعلام وقابلية التوسعة.

# بنية الطبقات N-Tier

تقسم بنية الطبقات N-Tier التطبيق إلى طبقات منطقية وأطباق مادية. الطبقات هي طريقة لفصل المسؤوليات وإدارة التبعيات. تحمل كل طبقة مسؤولية محددة. يمكن للطبقة العلوية استخدام الخدمات في الطبقة الأدنى، لكن ليس العكس.

![بنية الطبقات N-Tier](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-III/n-tier-architecture/n-tier-architecture.png)

تفصل الأطباق بشكل مادي وتعمل على أجهزة منفصلة. يمكن للطبقة أن تستدعي طبقة أخرى مباشرة، أو تستخدم الرسائل اللاحقة. على الرغم من أنه يمكن أن يتم استضافة كل طبقة في طبقة منفصلة، إلا أن ذلك ليس مطلوبًا. قد تتم استضافة عدة طبقات على نفس الطبقة. يحسن فصل الأطباق ماديًا القابلية للتوسع والصلابة ويضيف تأخيرًا من التواصل الشبكي الإضافي.

يمكن أن تكون بنية الطبقات N-Tier من نوعين:

- في بنية الطبقات المغلقة، يمكن للطبقة استدعاء الطبقة التالية مباشرة أدناها فقط.
- في بنية الطبقات المفتوحة، يمكن للطبقة استدعاء أي من الطبقات أدناها.

تحد من بنية الطبقات المغلقة التبعيات بين الطبقات. ومع ذلك، قد يؤدي ذلك إلى إنشاء حركة مرور عبر الشبكة غير ضرورية، إذا قامت طبقة واحدة بنقل الطلبات إلى الطبقة التالية فقط.

## أنواع بنية الطبقات N-Tier

لنلقِ نظرة على بعض أمثلة بنية الطبقات N-Tier:

### بنية الطبقات 3-Tier

تُستخدم بنية 3-Tier على نطاق واسع وتتكون من الطبقات التالية المختلفة:

- **طبقة العرض**: تتعامل مع تفاعلات المستخدم مع التطبيق.
- **طبقة المنطق التجاري**: تقبل البيانات من طبقة التطبيق، وتتحقق من صحتها وفقًا لمنطق الأعمال وتمررها إلى طبقة الوصول إلى البيانات.
- **طبقة الوصول إلى البيانات**: تستقبل البيانات من طبقة المنطق التجاري وتنفذ العمليات اللازمة على قاعدة البيانات.

### بنية الطبقات 2-Tier

في هذه البنية، تعمل طبقة العرض على العميل وتتواصل مع مخزن البيانات. لا توجد طبقة منطق التجارة أو طبقة فورية بين العميل والخادم.

### بنية طبقة واحدة أو 1-Tier

هو النوع الأبسط حيث يكون مكافئًا لتشغيل التطبيق على جهاز كمبيوتر شخصي. يتواجد جميع المكونات اللازمة لتشغيل التطبيق على تطبيق واحد أو خادم واحد.

## المزايا

إليك بعض المزايا لاستخدام بنية الطبقات N-Tier:

- يمكن تحسين التوافر.
- أفضل أمان حيث يمكن للطبقات أن تتصرف كحاجز نار.
- تتيح لنا الطبقات المنفصلة توسيعها حسب الحاجة.
- يحسن الصيانة حيث يم

كن لأشخاص مختلفين إدارة طبقات مختلفة.

## العيوب

وفيما يلي بعض العيوب لبنية الطبقات N-Tier:

- تزيد من تعقيد النظام ككل.
- تزيد من تأخير الشبكة مع زيادة عدد الطبقات.
- مكلفة حيث سيكون لكل طبقة تكلفة أجهزتها الخاصة.
- من الصعب إدارة أمان الشبكة.

# وسطاء الرسائل

وسيط الرسائل هو برنامج يمكن التطبيقات والأنظمة والخدمات من التواصل مع بعضها البعض وتبادل المعلومات. يقوم وسيط الرسائل بذلك من خلال ترجمة الرسائل بين بروتوكولات الرسائل الرسمية. وهذا يتيح للخدمات المتعاونة التحدث مع بعضها البعض مباشرة، حتى إذا كانت مكتوبة بلغات مختلفة أو مُنفَّذَة على منصات مختلفة.

![وسيط الرسائل](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-III/message-brokers/message-broker.png)

يمكن لوسطاء الرسائل التحقق من صحة الرسائل وتخزينها وتوجيهها وتسليمها إلى الوجهات المناسبة. يعملون كوسطاء بين التطبيقات الأخرى، مما يسمح للمرسلين بإصدار الرسائل دون معرفة مكان المستقبلين، سواء كانوا نشطين أم لا أو عددهم. ويُسهِّل ذلك الفصل بين العمليات والخدمات ضمن الأنظمة.

## النماذج

تقدم وسطاء الرسائل نمطين أساسيين لتوزيع الرسائل أو أنماط الرسائل:

- **[توزيع النقاط إلى النقاط](https://karanpratapsingh.com/courses/system-design/message-queues)**: هذا هو نمط التوزيع المستخدم في طوابير الرسائل مع علاقة واحد-إلى-واحد بين مرسل الرسالة والمستقبل.
- **[توزيع النشر-الاشتراك](https://karanpratapsingh.com/courses/system-design/publish-subscribe)**: في هذا النمط التوزيعي للرسائل، المعروف أيضًا بـ "النشر/الاشتراك"، يقوم منتج كل رسالة بنشرها إلى موضوع، ويشترك عدة مستهلكين للرسائل في المواضيع التي يرغبون في استقبال الرسائل منها.

_سنناقش هذه الأنماط التوزيعية للرسائل بالتفصيل في الدروس التالية._

## وسطاء الرسائل مقابل منصات تدفق الأحداث

يمكن لوسطاء الرسائل دعم نمطين أو أكثر لتوزيع الرسائل، بما في ذلك طوابير الرسائل والنشر/الاشتراك، بينما تقدم منصات تدفق الأحداث نماذج توزيع نشر/الاشتراك فقط. صُممت منصات تدفق الأحداث للاستخدام مع حجم كبير من الرسائل، وهي قابلة للتوسعة بسهولة. يمكنها ترتيب تدفقات السجلات إلى فئات تُسمى "المواضيع" وتخزينها لفترة زمنية محددة. على عكس وسطاء الرسائل، إلا أن منصات تدفق الأحداث لا يمكنها ضمان تسليم الرسائل أو تتبع المستهلكين الذين تلقوا الرسائل.

تقدم منصات تدفق الأحداث مزيدًا من القابلية للتوسعة من وسطاء الرسائل ولكنها تحتوي على مزيد من الميزات التي تضمن القدرة على التحمل من الأخطاء مثل إعادة إرسال الرسائل، بالإضافة إلى إمكانيات توجيه الرسائل وتكوين الطوابير المحدودة.

## وسطاء الرسائل مقابل حافلة خدمات الأعمال (ESB)

[بنية حافلة خدمات الأعمال (ESB)](https://karanpratapsingh.com/courses/system-design/enterprise-service-bus) معقدة ويمكن أن تكون صعبة التكامل ومكلفة التطوير. يُعَدُّ عملية تحديد المشكلات عند حدوث مشاكل في بيئات الإنتاج صعبة، وليس سهلا

ً القيام بالتوسع والتحديث.

بينما تعتبر وسطاء الرسائل بديلًا "خفيف الوزن" لبنية ESB توفر وظائف مماثلة، وهي آلية للاتصال بين الخدمات، وبتكلفة أقل. إنها مناسبة تمامًا للاستخدام في [هندسة بنية الميكروسيرفس](https://karanpratapsingh.com/courses/system-design/monoliths-microservices#microservices) التي أصبحت أكثر انتشارًا مع تراجع شعبية بنية ESB.

## أمثلة

فيما يلي بعض وسطاء الرسائل الشائعة المستخدمة:

- [NATS](https://nats.io)
- [Apache Kafka](https://kafka.apache.org)
- [RabbitMQ](https://www.rabbitmq.com)
- [ActiveMQ](https://activemq.apache.org)

# طوابير الرسائل

طوابير الرسائل هي شكل من أشكال التواصل بين الخدمات يُمكّن التواصل الغير متزامن. تستقبل بشكل غير متزامن الرسائل من المُرسلين وتُرسلها للمستهلكين.

تُستخدم الطوابير لإدارة الطلبات بشكل فعال في أنظمة التوزيع الضخمة. في الأنظمة الصغيرة التي تحمل أحمال معالجة وقواعد بيانات صغيرة، يمكن أن تكون الكتابات سريعة بشكل متوقع. ومع ذلك، في الأنظمة المعقدة والكبيرة يمكن أن تستغرق الكتابات فترة زمنية غير محددة تقريبًا.

![طوابير الرسائل](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-III/message-queues/message-queue.png)

## كيفية العمل

تُخزن الرسائل في الطابور حتى تُعالَج وتُحذَف. يتم معالجة كل رسالة مرة واحدة فقط بواسطة مستهلك واحد. فيما يلي كيفية عملها:

- ينشر المُرسل وظيفة إلى الطابور، ثم يُعلم المُستخدم بحالة الوظيفة.
- يقوم المُستهلك بالحصول على الوظيفة من الطابور، ومعالجتها، ثم يُعلِن أن الوظيفة مُكتَمَلة.

## المزايا

دعونا نناقش بعض المزايا في استخدام طوابير الرسائل:

- **قابلية التوسع**: تُمكِّن طوابير الرسائل التوسع بالضبط حيث نحتاج إليه. عندما تتزايد أعباء العمل، يمكن للعديد من نسخ التطبيق الخاص بنا أن تضيف كل الطلبات إلى الطابور دون خطر التصادُم.
- **فصل الأجزاء**: تُزيل طوابير الرسائل التبعية بين الأجزاء وتُبسِّط بشكل كبير تنفيذ التطبيقات المفصولة.
- **الأداء**: تُمكِّن طوابير الرسائل التواصل غير المتزامن، مما يعني أن النقاط النهائية التي تنتج وتستهلك الرسائل تتفاعل مع الطابور وليس مع بعضها البعض. يمكن للمنتجين إضافة الطلبات إلى الطابور دون الانتظار لاستكمالها.
- **الموثوقية**: تجعل الطوابير بياناتنا دائمة وتُقَلِّل من الأخطاء التي تحدث عندما تنقطع أجزاء مختلفة من نظامنا عن العمل.

## الميزات

لنناقش الآن بعض الميزات المطلوبة في طوابير الرسائل:

### تسليم بواسطة الدفع أو الجلب

توفر معظم طوابير الرسائل الخيارين لاسترداد الرسائل، وال

دفع والجلب. الجلب يعني الاستعلام المتواصل عن الطابور للحصول على رسائل جديدة. الدفع يعني أن المُستهلك يُعلِم عندما تكون هناك رسالة مُتاحة. يمكن أن نستخدم أيضًا الجلب للسماح للمستلمين بالانتظار لوقت محدد لوصول رسائل جديدة.

### طوابير التسلسل الأول في الدخول أولاً (FIFO)

في هذه الطوابير، يتم معالجة أقدم (أو أول) إدخال، يُطلق عليه أحيانًا اسم "الرأس" من الطابور، أولاً.

### جدولة أو تأجيل التسليم

تدعم طوابير الرسائل العديد منها إعداد وقت تسليم محدد للرسالة. إذا كان لدينا تأجيل مشترك لجميع الرسائل، فيمكننا إعداد طابور تأخير.

### التسليم مرة واحدة على الأقل

قد تخزن طوابير الرسائل عدة نسخ من الرسائل لضمان التوفر العالي، وإعادة إرسال الرسائل في حالة فشل الاتصال أو وجود أخطاء لضمان أنها تُسلَّم مرة واحدة على الأقل.

### التسليم بالضبط مرة واحدة

عندما لا يمكن تحمُّل التكرارات، ستضمن طوابير الرسائل من نوع FIFO (التسلسل الأول في الدخول أولاً) أن يتم توصيل كل رسالة بالضبط مرة واحدة (وفقًا للتسلسل) من خلال تصفية التكرارات تلقائيًا.

### طوابير الرسائل ذات الرسائل الخاطئة

طابور الرسائل ذات الرسائل الخاطئة هو طابور يُرسل له رسائل لا يمكن مُعالجتها بنجاح من طوابير أخرى. يُسهِّل ذلك إرسالها جانبًا للفحص اللاحق دون حجب معالجة الطابور أو إنفاق دورات وحدة المعالجة المركزية على رسالة قد لا يتم استهلاكها بنجاح.

### الترتيب

توفر معظم طوابير الرسائل الترتيب الذي يُضمِن تسليم الرسائل بنفس الترتيب الذي تم إرسالها تقريبًا، وأن يتم تسليم الرسالة على الأقل مرة واحدة.

### رسائل الأقراص السامة

رسائل الأقراص السامة هي رسائل خاصة يمكن استقبالها، لكنها لا يمكن معالجتها. إنها آلية تُستخدم للإشارة إلى المستهلك بإنهاء عمله حتى لا يكون في انتظار مدخلات جديدة بعد الآن، وتشبه إغلاق مقبس في نموذج العميل/الخادم.

### الأمان

تُوثِّق طوابير الرسائل التطبيقات التي تُحاول الوصول إلى الطابور، وهذا يسمح لنا بتشفير الرسائل عبر الشبكة وفي الطابور نفسه.

### طوابير المهام

تتلقَّى طوابير المهام المهام والبيانات المرتبطة بها، تُشغِّلها ثم تسلِّم نتائجها. يمكن أن تدعم جداول المهام الجدولة ويمكن استخدامها لتشغيل المهام المكثفة في الحساب في الخلفية.

## التحكُّم في العكسيَّة

إذا بدأت الطوابير تنمو بشكل كبير، فإن حجم الطابور يمكن أن يصبح أكبر من الذاكرة، مما يؤدي إلى فقدان ذاكرة التخزين المؤقت وقراءات القرص وحتى أداءًا أبطأ. يمكن أن يساعد التحكُّم في العكسيَّة عن طريق تحديد حجم الطابور، وبالتالي الحفاظ على معد

ل الإنتاج العالي وأوقات الاستجابة الجيدة للوظائف الموجودة بالفعل في الطابور. عندما يمتلئ الطابور، يحصل العملاء على رمز حالة انشغال الخادم أو HTTP 503 للمحاولة مرة أخرى في وقت لاحق. يمكن للعملاء إعادة المحاولة في وقت لاحق، ربما باستخدام استراتيجية العكسيَّة التعايضيَّة.

# النشر والاشتراك

بشكل مماثل لطابور الرسائل، يعد النشر والاشتراك أيضًا نوعًا من التواصل بين الخدمات الذي يسهل التواصل الغير متزامن. في نموذج النشر والاشتراك، يتم دفع أي رسالة مُنشَرة على موضوع (توبيك) فورًا إلى جميع المشتركين في هذا الموضوع.

المشتركين في موضوع الرسالة غالبًا ما يؤدون وظائف مختلفة، ويمكن لكل منهم أن يقوم بشيء مختلف بالرسالة بشكل متوازي. المُنشئ لا يحتاج لمعرفة من يستخدم المعلومات التي يتم بثها، والمشتركون لا يحتاجون لمعرفة مصدر الرسالة. هذا النمط من التواصل مختلف قليلاً عن طوابير الرسائل، حيث يعرف المكوِّن الذي يرسل الرسالة غالبًا الوجهة التي يتم إرسالها إليها.

## كيفية العمل

على عكس طوابير الرسائل التي تجمع الرسائل حتى يتم استردادها، تقوم مواضيع الرسائل بنقل الرسائل مع قليل أو بدون انتظار وتدفعها على الفور إلى جميع المشتركين. إليك كيفية العمل:

- يوفر موضوع الرسالة آلية خفيفة الوزن لبث إشعارات الأحداث الغير متزامنة والنقاط النهائية التي تسمح للمكونات البرمجية بالاتصال بالموضوع لإرسال واستقبال هذه الرسائل.
- لبث رسالة، يُدفع مكوِّن يُسمَّى "الناشر" ببساطة رسالة إلى الموضوع.
- سيتلقى جميع المكوِّنات المشتركة في الموضوع (المعروفة باسم "المشتركين") كل رسالة تم بثها.

## المزايا

استكمالًا لذلك، دعنا نتناول المزيد من المزايا في استخدام النشر والاشتراك:

- **توزيع الحمل**: يتيح نمط النشر والاشتراك التوزيع الفوري للإشعارات الأحداثية، وهو مفيد جدًا في التطبيقات التي تحتاج إلى معالجة كميات كبيرة من الأحداث بسرعة. حيث يُمكن للمشتركين تجزئة العمل ومعالجة الإشعارات المتوفرة بالتوازي، مما يزيد من كفاءة المعالجة ويسرع من الاستجابة.
- **التوجيه الديناميكي والاكتشاف التلقائي**: تمكننا نماذج النشر والاشتراك من الاكتشاف التلقائي للخدمات والتواصل معها بشكل أسهل وأكثر طبيعية وأقل عرضة للأخطاء. يمكن للناشر أن ينشر الرسائل على الموضوع بسهولة دون الحاجة إلى معرفة مين يستخدم المعلومات التي يتم بثها. وعندئذٍ، يمكن لأي طرف مهتم أن يشترك بنقطة النهاية الخاصة به إلى الموضوع وبدء تلقي هذه الرسائل. يمكن للمشتركين التغيير والترقية والتضاعف أو الاختفاء، ويقوم النظام بضبط نفسه بشكل ديناميكي وفقًا لذلك.
- **فصل البرمجيات وتوسيعها بشكل مستقل**: يعزل نمط النشر والاشتراك الناشرين والمشتركين ويسمح لهم بالعمل بشكل مستقل عن بعضهم البعض، مما يتيح لنا تطويرهم وتوسيعهم بشكل منفصل. هذا يساعد على الحد من الترابط الزائد بين المكونات ويجعل النظام أكثر مرونة وسهل الصيانة.
- **تبسيط التواصل**: يقلل نمط النشر والاشتراك من التعقيد بشكل عام. عوضًا عن إدارة الاتصالات بين المرسل والمستقبل بشكل مباشر ومنفرد، يُدار التواصل من خلال موضوع الرسالة الواحد الذي يُدير الاشتراكات ويقرر أي رسائل يجب تسليمها إلى أي من المشتركين.

## الميزات

لنتحدث الآن عن بعض الميزات المطلوبة في نمط النشر والاشتراك:

### تسليم الدفع

تقدم رسائل النشر والاشتراك إشعارات الأحداث الغير متزامنة على الفور عند نشر الرسائل إلى موضوع الرسالة. يتم إخطار المشتركين عند توفُّر رسالة.

### بروتوكولات ت

سليم متعددة

في نمط النشر والاشتراك، يمكن لمواضيع الرسائل الاتصال بأنواع متعددة من النقاط النهائية، مثل طوابير الرسائل ووظائف بلا سيرفر وخوادم HTTP وغيرها.

### النشر الشامل

يحدث هذا السيناريو عندما يتم إرسال رسالة إلى موضوع ومن ثم تكرارها ودفعها إلى العديد من النقاط النهائية. يوفر النشر الشامل إشعارات أحداث غير متزامنة والتي تتيح المعالجة المتوازية.

### التصفية

تسمح هذه الميزة للمشترك بإنشاء سياسة تصفية الرسالة بحيث تحصل على الإشعارات التي تهمه فقط، بدلاً من استلام كل رسالة فردية يتم نشرها إلى الموضوع.

### المتانة

يقدم خدمات رسائل النشر والاشتراك عادةً متانة عالية جدًا، وتوصيل مرة واحدة على الأقل، من خلال حفظ نسخ من نفس الرسالة على العديد من الخوادم.

### الأمان

تقوم مواضيع الرسائل بتوثيق التطبيقات التي تحاول نشر المحتوى، وهذا يسمح لنا باستخدام نقاط نهاية مشفرة وتشفير الرسائل أثناء الانتقال عبر الشبكة.

## الأمثلة

فيما يلي بعض التقنيات المستخدمة على نطاق واسع في رسائل النشر والاشتراك:

- [Amazon SNS](https://aws.amazon.com/sns)
- [Google Pub/Sub](https://cloud.google.com/pubsub)

# سيّر الخدمات المؤسسي (ESB)

سيّر الخدمات المؤسسي (ESB) هو نمط معماري يقوم بتنفيذ التكاملات بين التطبيقات من خلال مكون برمجي مركزي. يقوم ESB بتحويل نماذج البيانات، ويتعامل مع الاتصالات، وينفذ توجيه الرسائل، ويحول بين بروتوكولات الاتصال، وقد يدير تركيب طلبات متعددة. يمكن للESB جعل هذه التكاملات والتحويلات متاحة على شكل واجهة خدمة لإعادة الاستخدام من قبل التطبيقات الجديدة.

## المزايا

نظريًا، يقدم ESB المركزي إمكانية توحيد وتبسيط التواصل والرسائل والتكامل بين الخدمات عبر المؤسسة بشكل كبير. وإليك بعض المزايا في استخدام ESB:

- **تحسين إنتاجية المطورين**: يمكّن المطورين من دمج التقنيات الجديدة في جزء واحد من التطبيق دون لمس باقي التطبيق.
- **توسيع أسهل وأكثر فعالية من حيث التكلفة**: يمكن توسيع المكونات بشكل مستقل عن الآخرين.
- **مرونة أكبر**: فشل مكون واحد لا يؤثر على الآخرين، ويمكن لكل خدمة صغيرة أن تلتزم بمتطلبات التوفر الخاصة بها دون المخاطرة بتوفر العناصر الأخرى في النظام.

## العيوب

بينما نجحت نظم ESB في العديد من المؤسسات، أصبحت ESB في العديد من المؤسسات معروضة كعامل قيد. وإليك بعض العيوب في استخدام ESB:

- يمكن أن تؤدي القيام بتغييرات أو تحسينات في التكامل إلى تأثير آخرين يستخدمون نفس التكامل.
- يمكن أن يؤدي فشل نقطة واحدة إلى تعطيل جميع الاتصالات.
- يؤثر التحديثات على ESB عادةً على التكاملات الحالية، وبالتالي يتطلب إجراء اختبارات كبيرة لأداء أي تحديث.
- يتم إدارة ESB بشكل مركزي مما يجعل التعاون بين الفرق التقنية أمرًا تحديًا.
- تعقيد التكوين والصيانة عالي.

## الأمثلة

وفيما يلي بعض تقنيات سيّر الخدمات المؤسسي (ESB) المستخدمة على نطاق واسع:

- [Azure Service Bus](https://azure.microsoft.com/en-in/services/service-bus)
- [IBM App Connect](https://www.ibm.com/in-en/cloud/app-connect)
- [Apache Camel](https://camel.apache.org)
- [Fuse ESB](https://www.redhat.com/en/technologies/jboss-middleware/fuse)

# التمثيلات النمطية والخدمات المتناهية الصغر

## التمثيلات النمطية

التمثيل النمطي هو تطبيق مستقل ومستقل ذاتيًا. يتم بناؤه كوحدة واحدة وهو مسؤول ليس فقط عن مهمة معينة، بل يمكنه أداء كل الخطوات المطلوبة لتلبية احتياج الأعمال.

## المزايا

فيما يلي بعض المزايا للتمثيلات النمطية:

- سهولة التطوير أو التصحيح.
- تواصل سريع وموثوق.
- رصد واختبار سهل.
- دعم عمليات النقل الداخلي (ACID).

## العيوب

بعض العيوب الشائعة للتمثيلات النمطية:

- يصبح الصيانة صعبة عندما ينمو حجم قاعدة الشفرة.
- تطبيق مرتبط تمامًا وصعب التوسع.
- يتطلب الالتزام بتكنولوجيا محددة.
- في كل تحديث، يتم إعادة نشر التطبيق بأكمله.
- يقلل من الموثوقية حيث يمكن لعلة واحدة أن تتسبب في تعطيل النظام بأكمله.
- صعوبة في التوسع أو اعتماد التقنيات الجديدة.

## التمثيلات النمطية القابلة للتجزئة

التمثيل النمطي القابل للتجزئة هو نهج نبني وننفذ من خلاله تطبيقًا واحدًا (هذا هو الجزء "التمثيل النمطي")، ولكننا نبنيه بطريقة تقسم فيها الشفرة إلى وحدات مستقلة لكل الميزات المطلوبة في تطبيقنا.

يقلل هذا النهج من التبعية الناتجة عن وحدة بحيث يمكننا تحسين أو تغيير وحدة دون التأثير على الوحدات الأخرى. عندما يتم القيام به بشكل صحيح، يمكن أن يكون هذا مفيدًا حقًا على المدى الطويل حيث يقلل من التعقيد الناتج عن الحفاظ على التمثيل النمطي عندما ينمو النظام.

## الخدمات المتناهية الصغر

تتألف معمارية الخدمات المتناهية الصغر من مجموعة من الخدمات الصغيرة والمستقلة حيث يكون لكل خدمة مجموعة من القدرات التجارية والمحددة ضمن سياق محدد. يعتبر السياق المحدد تقسيمًا طبيعيًا للمنطق التجاري يوفر حدًا واضحًا داخله يوجد نموذج مجال.

لكل خدمة قا

عدة شفرة منفصلة يمكن إدارتها بواسطة فريق تطوير صغير. يمكن نشر الخدمات بشكل مستقل ويمكن للفريق تحديث خدمة موجودة دون إعادة بناء التطبيق بأكمله ونشره.

تكون الخدمات مسؤولة عن الاحتفاظ ببياناتها الخاصة أو الحالة الخارجية (قاعدة بيانات لكل خدمة). يختلف ذلك عن النموذج التقليدي، حيث يتم التعامل مع الاحتفاظ بالبيانات.

## السمات

يتميز نمط الخدمات المتناهية الصغر بالخصائص التالية:

- **ترابط فضفاض**: يجب أن تكون الخدمات مرتبطة فضفاضة حتى يمكن نشرها وتوجيهها بشكل مستقل. سيؤدي ذلك إلى فك تمركز فرق التطوير وبالتالي يمكنهم تطوير ونشر بسرعة مع حد أدنى من القيود والتبعيات التشغيلية.
- **صغيرة ومركزة**: إنها تتعلق بالنطاق والمسؤوليات وليس بالحجم، يجب أن تكون الخدمة مركزة على مشكلة محددة. ببساطة، "إنها تقوم بشيء واحد وتفعله بشكل جيد". في الواقع، يمكن أن تكون مستقلة عن التطبيق الأساسي.
- **مصممة للأعمال التجارية**: يتم تنظيم معمارية الخدمات المتناهية الصغر عادة حول قدرات وأولويات الأعمال التجارية.
- **المرونة والتحمل**: يجب تصميم الخدمات بطريقة تضمن استمرارية العمل في حالة الفشل أو الأخطاء. في البيئات التي تتم فيها تنفيذ الخدمات بشكل مستقل، تحمل الفشل أمرًا بالغ الأهمية.
- **قابلية الصيانة العالية**: يجب أن تكون الخدمة سهلة الصيانة والاختبار لأن الخدمات التي لا يمكن الصيانة لها ستكتب مرة أخرى.

## المزايا

فيما يلي بعض المزايا لمعمارية الخدمات المتناهية الصغر:

- خدمات فضفاضة الترابط.
- يمكن نشر الخدمات بشكل مستقل.
- مرنة لأكثر من فريق تطوير.
- تحسين تحمل الأخطاء وعزل البيانات.
- تحسين قابلية التوسع حيث يمكن توسيع كل خدمة بشكل مستقل.
- يلغي التزامًا طويل الأمد بتكنولوجيا محددة.

## العيوب

معمارية الخدمات المتناهية الصغر تحمل مجموعة من التحديات الخاصة بها:

- تعقيد النظام الموزع.
- اختبار أكثر صعوبة.
- مكلفة للصيانة (الخوادم الفردية وقواعد البيانات وما إلى ذلك).
- التواصل بين الخدمات له تحدياته الخاصة.
- سلامة واتساق البيانات.
- ازدحام الشبكة وتأخير البيانات.

## أفضل الممارسات

دع

ونا نناقش بعض أفضل الممارسات لمعمارية الخدمات المتناهية الصغر:

- نمذجة الخدمات حول المجال التجاري.
- يجب أن تكون الخدمات فضفاضة الترابط وذات تماسك وظيفي عالي.
- عزل الأخطاء واستخدام استراتيجيات مرونة لمنع تأثير الأخطاء داخل الخدمة من التوسع.
- يجب أن تتواصل الخدمات فقط من خلال واجهات برمجة تطبيق مصممة بشكل جيد. تجنب تسريب تفاصيل التنفيذ.
- يجب أن تكون تخزين البيانات خاصة بالخدمة التي تمتلك البيانات.
- تجنب الارتباط بين الخدمات. يمكن أن تسبب الارتباطات قاعدة بيانات مشتركة وبروتوكولات اتصال صارمة.
- تفكيك كل شيء. تعتبر الفرق الفردية مسؤولة عن تصميم وبناء الخدمات. تجنب مشاركة الشفرة أو نماذج البيانات.
- الفشل السريع باستخدام [مفتاح الكهرباء](https://karanpratapsingh.com/courses/system-design/circuit-breaker) لتحقيق التحمل من الأخطاء.
- التأكد من أن تغييرات واجهة البرمجة التطبيقية متوافقة مع الإصدار السابق.

## الفخاخ

فيما يلي بعض الفخاخ الشائعة لمعمارية الخدمات المتناهية الصغر:

- تحديد حدود الخدمة بناءً على المجال التجاري.
- الاستهانة بمدى صعوبة بناء نظام موزع.
- قاعدة بيانات مشتركة أو تبعيات مشتركة بين الخدمات.
- نقص الالتزام التجاري.
- نقص الملكية الواضحة.
- نقص الهوية.
- محاولة فعل كل شيء [ACID بدلاً من BASE](https://karanpratapsingh.com/courses/system-design/acid-and-base-consistency-models).
- نقص التصميم للتحمل من الأخطاء قد يؤدي إلى حدوث فشل تدريجي.

## الحذر من التمثيل النمطي الموزع

التمثيل النمطي الموزع هو نظام يشبه معمارية الخدمات المتناهية الصغر ولكنه مرتبط تمامًا ضمن نفسه مثل التطبيق الأحادي. يأتي اعتماد معمارية الخدمات المتناهية الصغر مع الكثير من المزايا. ولكن أثناء القيام بذلك، هناك فرص جيدة أننا قد ننتهي بالتمثيل النمطي الموزع.

تكون خدماتنا فقط نمطي موزع إذا تطبق أي من هذه النقاط عليه:

- يتطلب التواصل بين الخد

مات وقت استجابة قليل.
- الخدمات لا تتحمل بسهولة.
- الاعتمادية بين الخدمات.
- مشاركة نفس الموارد مثل قواعد البيانات.
- أنظمة تعتمد على بعضها بقوة.

أحد الأسباب الرئيسية لبناء تطبيق باستخدام معمارية الخدمات المتناهية الصغر هو الحصول على قابلية للتوسعة. لذلك، يجب أن تكون الخدمات فضفاضة الترابط لتمكين كل خدمة من التمتع بالاستقلالية. تنفق معمارية التمثيل النمطي الموزع هذا وتسبب في أن يعتمد معظم المكونات على بعضها البعض، مما يزيد من تعقيد التصميم. 

## معمارية الخدمات المتناهية الصغر مقابل العمارة الموجهة للخدمة (SOA)

قد تكون قد شاهدت مصطلح "معمارية الخدمة الموجهة للخدمة (SOA)" في الإنترنت أحيانًا، وحتى ربما قد يتم استخدامها بشكل متبادل مع الخدمات المتناهية الصغر، ولكنهما مختلفان عن بعضهما البعض، والفرق الرئيسي بين النهجين يتمثل في "النطاق".

تعرف معمارية الخدمات الموجهة للخدمة (SOA) طريقة لجعل مكونات البرنامج قابلة لإعادة الاستخدام من خلال واجهات الخدمة. تستخدم هذه الواجهات معايير الاتصال المشتركة وتركز على تحقيق أقصى قدر من إعادة استخدام الخدمة التطبيقية بينما تكون الخدمات المتناهية الصغر هي مجموعة من وحدات الخدمة الصغيرة المستقلة التي تركز على استقلالية الفريق وفصل الأجزاء.

## لماذا لا تحتاج إلى الخدمات المتناهية الصغر

في النهاية، قد تكون تتساءل، يبدو أن التمثيلات النمطية فكرة سيئة للبدء، لماذا يستخدمها أحد؟

حسنًا، الأمر يعتمد. على الرغم من أن كل نهج له مزاياه وعيوبه الخاصة، يُنصح بالبدء بالتمثيل النمطي عند بناء نظام جديد. إنه أمر مهم أن نفهم أن الخدمات المتناهية الصغر ليست بالضرورة حلاً لكل المشاكل، بدلاً من ذلك، فهي تحل مشكلة تنظيمية. إن معمارية الخدمات المتناهية الصغر هي بشكل رئيسي حول أولوياتك التنظيمية وفريقك بقدر ما هي عن التقنية.

قبل اتخاذ قرار التحول إلى معمارية الخدمات المتناهية الصغر، يجب عليك طرح أسئلة مثل:

- "هل يكون فريق التطوير كبيرًا للعمل بفعالية على قاعدة شفرة مشتركة؟"
- "هل يتم حجب الفرق بسبب الفرق الأخرى؟"
- "هل تقدم الخدمات المتناهية الصغر قيمة تجارية واضحة لنا؟"
- "هل يكون نظامي الأعمال ناضجًا بما يكفي لاستخدام الخدمات المتناهية الصغر؟"
- "هل الهندسة المعمارية الحالية تقيدنا بفوق الرأس الاتصال؟"

إذا لم تتطلب تطبيقك تقسيمه إلى خدمات متناهية الصغر، فليس هناك حاجة لذلك. لا يوجد ضرورة مطلقة لأن يتم تقسيم كل التطبيقات إلى خدمات متناهية الصغر. غالبًا ما نستلهم الإلهام من الشركات مثل نيتفليكس واستخدامها لخدمات متناهية الصغر، ولكن نتجاهل حق

يقة أننا لسنا نيتفليكس. إنهم مرروا بالعديد من التجارب والنماذج قبل أن يحصلوا على حلاً جاهزًا للسوق، وأصبحت هذه الهندسة المعمارية مقبولة بالنسبة لهم عندما حددوا المشكلة التي كانوا يحاولون معالجتها.

لذلك، من المهم فهم بعمق إذا كانت شركتك حقًا تحتاج إلى الخدمات المتناهية الصغر. ما أحاول قوله هو أن الخدمات المتناهية الصغر هي حلاً للقضايا المعقدة وإذا لم تكن لشركتك قضايا معقدة، فلست بحاجة إليها.

# التصميم المعماري المستند إلى الأحداث (EDA)

التصميم المعماري المستند إلى الأحداث (EDA) يتعلق باستخدام الأحداث كوسيلة للتواصل داخل نظام معين. عمومًا، يتم استخدام وسيط رسائل لنشر الأحداث واستهلاكها بشكل غير متزامن. المُنشئ لا يعلم من يستهلك الحدث، والمستهلكون لا يعرفون بعضهم البعض. التصميم المعماري المستند إلى الأحداث هو ببساطة وسيلة لتحقيق ارتباط فضفاض بين الخدمات داخل النظام.

## ما هو الحدث؟

الحدث هو نقطة بيانات تُمثل تغييرات الحالة في النظام. لا يحدد ما يجب أن يحدث وكيفية تعديل النظام، بل يُخطِّر النظام بتغيير حالة معينة. عندما يقوم المستخدم بإجراء إجراء، يُحفِّز حدثًا.

## المكونات

تحتوي التصميمات المعمارية المستندة إلى الأحداث على ثلاثة مكونات رئيسية:

- **منتجو الأحداث**: ينشرون حدثًا للموجه.
- **الموجه الحدث**: يقوم بتصفية الأحداث ودفعها إلى المستهلكين.
- **مستهلكو الأحداث**: يستخدمون الأحداث لتعكس التغييرات في النظام.

![التصميم المعماري المستند إلى الأحداث](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-III/event-driven-architecture/event-driven-architecture.png)

_ملاحظة: النقاط في الرسم البياني تمثل أحداثًا مختلفة في النظام._

## الأنماط

هناك العديد من الطرق لتنفيذ التصميم المعماري المستند إلى الأحداث، والطريقة التي نستخدمها تعتمد على حالة الاستخدام، ولكن هنا بعض الأمثلة الشائعة:

- [الملحمات](https://karanpratapsingh.com/courses/system-design/distributed-transactions#sagas)
- [النشر والاشتراك](https://karanpratapsingh.com/courses/system-design/publish-subscribe)
- [تخزين الأحداث](https://karanpratapsingh.com/courses/system-design/event-sourcing)
- [القيام بالأوامر وتوزيع مسؤولية الاستعلام (CQRS)](https://karanpratapsingh.com/courses/system-design/command-and-query-responsibility-segregation)

_ملاحظة: يتم مناقشة كل من هذه الأساليب بشكل منفصل._

## المزايا

دعونا نناقش بعض المزايا:

- فصل المنتجين والمستهلكين.
- مُقيم جدًا وموزَّع.
- سهولة إضافة مستهلكين جدد.
- يحسن الرشاقة.

## التحديات

فيما يلي بعض التحديات المتعلقة بالتصميم المعماري المستند إلى الأحداث:

- توصيل مضمون.
- من الصعب التعامل مع الأخطاء.
- أنظمة مستندة إلى الأحداث هي معقدة بشكل عام.
- معالجة الأحداث بدقة مرة واحدة، بترتيبها.

## الحالات الاستخدامية

فيما يلي بعض حالات الاستخدام الشائعة حيث تكون التصاميم المعمارية المستندة إلى الأحداث مفيدة:

- البيانات الوصفية والمقاييس.
- سجلات الخادم والأمان.
- دمج الأنظمة غير المتجانسة.
- النشر على نطاق وتجهيز متوازي.

## الأمثلة

فيما يلي بعض التقنيات المستخدمة على نطاق واسع لتنفيذ التصاميم المعمارية المستندة إلى الأحداث:

- [NATS](https://nats.io)
- [Apache Kafka](https://kafka.apache.org)
- [Amazon EventBridge](https://aws.amazon.com/eventbridge)
- [Amazon SNS](https://aws.amazon.com/sns)
- [Google PubSub](https://cloud.google.com/pubsub)
# التخزين بالأحداث

بدلاً من تخزين الحالة الحالية للبيانات في مجال معين، يمكن استخدام متجر يسجل سلسلة كاملة من الإجراءات التي تم اتخاذها على تلك البيانات. يعمل المتجر كنظام تسجيل ويمكن استخدامه لتجسيد كائنات المجال.

![event-sourcing](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-III/event-sourcing/event-sourcing.png)

يمكن أن يبسط هذا المفهوم المهام في المجالات المعقدة، من خلال تجنب الحاجة إلى مزامنة نموذج البيانات ومجال الأعمال، مع تحسين الأداء والقابلية للتوسع والاستجابة. يمكن أن يوفر أيضًا الاستقرار للبيانات التي تخضع للمعاملات، والحفاظ على سجلات مراجعة كاملة وتاريخ يمكن أن يمكّن الإجراءات التعويضية.

## التخزين بالأحداث مقابل الهندسة المعمارية المدفوعة بالأحداث

يبدو أن العديد من الأشخاص يخلطون بين التخزين بالأحداث و [الهندسة المعمارية المدفوعة بالأحداث (EDA)](https://karanpratapsingh.com/courses/system-design/event-driven-architecture). الهندسة المعمارية المدفوعة بالأحداث تتعلق باستخدام الأحداث للتواصل بين حدود الخدمة. عمومًا، يتم استغلال وسيط الرسائل لنشر الأحداث واستهلاكها بشكل غير متزامن في حدود أخرى.

بينما التخزين بالأحداث يتعلق باستخدام الأحداث كحالة، وهو نهج مختلف لتخزين البيانات. بدلاً من تخزين الحالة الحالية، سنقوم بدلاً من ذلك بتخزين الأحداث. أيضًا، التخزين بالأحداث هو واحد من الأنماط المختلفة لتنفيذ الهندسة المعمارية المدفوعة بالأحداث.

## المزايا

لنتناقش عن بعض المزايا في استخدام التخزين بالأحداث:

- ممتاز لتقارير البيانات في الوقت الحقيقي.
- رائع للسلامة من الفشل، حيث يمكن إعادة تجسيد البيانات من مخزن الأحداث.
- مرن للغاية، حيث يمكن تخزين أي نوع من الرسائل.
- الطريقة المفضلة لتحقيق وظيفة السجلات التدقيق للأنظمة عالية الامتثال.

## العيوب

هذه هي العيوب التي تتضمنها التخزين بالأحداث:

- يتطلب بنية شبكة فعالة للغاية.
- يتطلب طريقة موثوقة للتحكم في تنسيق الرسائل، مثل سجل النطاق.
- ستحتوي الأحداث المختلفة على حمولات مختلفة.

# الفصل بين المسؤولية للأوامر والاستعلامات (CQRS)

الفصل بين المسؤولية للأوامر والاستعلامات (CQRS) هو نمط معماري يقسم أوامر النظام إلى أوامر واستعلامات. وقد وصف لأول مرة من قبل [Greg Young](https://twitter.com/gregyoung).

في CQRS، الأمر هو تعليم، توجيه لأداء مهمة محددة. إنها نية لتغيير شيء ما ولا تعيد قيمة، بل توضح فقط نجاح أو فشل التنفيذ. والاستعلام هو طلب للحصول على معلومات لا يتغير حالة النظام أو يسبب أي تأثير جانبي.

![الفصل-بين-المسؤولية-للأوامر-والاستعلامات](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-III/command-and-query-responsibility-segregation/command-and-query-responsibility-segregation.png)

المبدأ الأساسي لـ CQRS هو الفصل بين الأوامر والاستعلامات. إنهما يؤديان أدوارًا مختلفة بشكل جوهري داخل النظام، وفصلهما يعني أنه يمكن تحسين كل منهما حسب الحاجة، ومن هنا يمكن أن تستفيد الأنظمة الموزعة بشكل كبير.

## CQRS مع التخزين بالأحداث

غالبًا ما يتم استخدام نمط CQRS جنبًا إلى جنب مع نمط التخزين بالأحداث. تستخدم الأنظمة التي تعتمد على CQRS نماذج بيانات قراءة وكتابة منفصلة، مصممة للمهام ذات الصلة وعادة ما تكون موجودة في مخازن منفصلة بشكل فعلي.

عند استخدامها مع نمط التخزين بالأحداث، يعتبر مخزن الأحداث هو النموذج الكتابة وهو المصدر الرسمي للمعلومات. يوفر النموذج القراءة في نظام CQRS المشتقات المتعاملة مع البيانات، عادةً على شكل مشاهدات مجسمة بشكل كبير.

## المزايا

لنتناقش عن بعض المزايا في CQRS:

- يسمح بتوازن مستقل لأعباء العمليات والاستعلامات.
- تسهيل التوسع، والتحسينات، والتغييرات المعمارية.
- أقرب إلى منطق الأعمال مع فصل فعال.
- يمكن للتطبيق تجنب الانضمامات المعقدة عند الاستعلام.

## العيوب

هذه هي العيوب التي تتضمنها CQRS:

- تصميم تطبيق أكثر تعقيدا.
- قد تحدث فشل الرسائل أو تكرار الرسائل.
- التعامل مع الاتساق المستقبلي يشكل تحديا.
- زيادة جهود صيانة النظام.

## الاستخدام

ات

فيما يلي بعض السيناريوهات التي يمكن أن يكون فيها CQRS مفيدًا:

- يجب ضبط أداء قراءة البيانات بشكل منفصل عن أداء كتابة البيانات.
- من المتوقع أن يتطور النظام مع مرور الوقت وقد يحتوي على عدة إصدارات للنموذج، أو حيث تتغير القواعد التجارية بانتظام.
- التكامل مع أنظمة أخرى، خصوصاً بالاقتران مع التخزين بالأحداث، حيث لا يجب أن يؤثر الفشل الزمني لنظام فرعي واحد على توفر الآخرين.
- تحسين الأمان للتأكد من أن الجهات المختصة بالنطاق الصحيح تقوم بالكتابة على البيانات.

# بوابة واجهة برمجة التطبيقات (API Gateway)

بوابة واجهة برمجة التطبيقات (API Gateway) هي أداة إدارة واجهة برمجة التطبيقات تقع بين العميل ومجموعة من خدمات الخلفية. إنها نقطة دخول واحدة إلى النظام تجمع بين الهندسة الداخلية للنظام وتوفر واجهة برمجة التطبيقات التي تتناسب مع كل عميل. كما أن لها مسؤوليات أخرى مثل المصادقة، والرصد، والتوازن، والتخزين المؤقت، وتنظيم السرعة، وتسجيل الأحداث، وغيرها.

![بوابة-واجهة-برمجة-التطبيقات](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-III/api-gateway/api-gateway.png)

## لماذا نحتاج إلى بوابة واجهة برمجة التطبيقات؟

تكون حبيبات واجهات برمجة التطبيقات الناتجة عن الخدمات الميكروسيرفيسز غالبًا مختلفة عن ما يحتاجه العميل. توفر الخدمات الميكروسيرفيسز عادة واجهات برمجة التطبيقات متناهية الدقة، مما يعني أن العملاء يحتاجون للتفاعل مع العديد من الخدمات. ولذلك، يمكن أن توفر بوابة واجهة برمجة التطبيقات نقطة دخول واحدة لجميع العملاء مع بعض الميزات الإضافية وإدارة أفضل.

## الميزات

فيما يلي بعض الميزات المطلوبة لبوابة واجهة برمجة التطبيقات:

- المصادقة والتصريح.
- [اكتشاف الخدمة](https://karanpratapsingh.com/courses/system-design/service-discovery).
- [الوكيل العكسي](https://karanpratapsingh.com/courses/system-design/proxy#reverse-proxy).
- [التخزين المؤقت](https://karanpratapsingh.com/courses/system-design/caching).
- الأمان.
- إعادة المحاولة و[الكسر الدوائري](https://karanpratapsingh.com/courses/system-design/circuit-breaker).
- [توازن الحمل](https://karanpratapsingh.com/courses/system-design/load-balancing).
- تسجيل الأحداث والتعقب.
- تكوين واجهة برمجة التطبيقات.
- [تحديد معدل الحد](https://karanpratapsingh.com/courses/system-design/rate-limiting) والتنظيم.
- التحديثات.
- التوجيه.
- تفعيل العناوين البيضاء أو السوداء.

## المزايا

لنلقي نظرة على بعض المزايا في استخدام بوابة واجهة برمجة التطبيقات:

- تقوم بتجميع الهيكل الداخلي لواجهة برمجة التطبيقات.
- توفر نظرة مركزية لواجهة برمجة التطبيقات.
- تبسط كود العميل.
- تقدم ميزات المراقبة والتحليل والتعقب وغيرها من الميزات المماثلة.

## العيوب

فيما يلي بعض العيوب المحتملة لبوابة واجهة برمجة التطبيقات:

- قد تكون نقطة فشل واحدة ممكنة.
- قد تؤثر على الأداء.
- يمكن أن تصبح ضيق الزاوية إذا لم يتم توزيعها بشكل صحيح.
- قد يكون تكوينها تحدياً.

## نمط المستودع الخلفي للواجهة الأمامية (BFF)

في نمط المستودع الخلفي للواجهة الأمامية (BFF)، نقوم بإنشاء خدمات خلفية منفصلة ليتم استهلاكها بواسطة تطبيقات أو واجهات أمامية محددة. يكون هذا النمط مفيدًا عندما نرغب في تجنب تخصيص مستودع واحد لواجهات متعددة. تم وصف هذا النمط لأول مرة بواسطة [سام نيومان](https://samnewman.io).

أيضًا، في بعض الأحيان، قد

 لا يكون إخراج البيانات التي يعود بها الخدمات الميكروسيرفيسز إلى واجهة الأمام بالتنسيق الدقيق أو المرشح كما يحتاجه الواجهة الأمامية. لحل هذه المشكلة، يجب أن تحتوي واجهة الأمام على بعض المنطق لإعادة تنسيق البيانات، وبالتالي، يمكننا استخدام نمط BFF لتحويل بعض هذه المنطق إلى الطبقة الوسيطة.

![المستودع-الخلفي-للواجهة-الأمامية](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-III/api-gateway/backend-for-frontend.png)

الوظيفة الرئيسية لنمط المستودع الخلفي للواجهة الأمامية هي الحصول على البيانات المطلوبة من الخدمة المناسبة، وتنسيق البيانات، وإرسالها إلى الواجهة الأمامية.

_[GraphQL](https://karanpratapsingh.com/courses/system-design/rest-graphql-grpc#graphql) يؤدي بشكل جيد جدًا كمستودع خلفي للواجهة الأمامية (BFF)._

### متى يجب استخدام هذا النمط؟

يجب أن نفكر في استخدام نمط المستودع الخلفي للواجهة الأمامية (BFF) عندما:

- يجب الحفاظ على خدمة خلفية مشتركة أو ذات غرض عام ويجب أن تتم صيانتها مع هامش تطوير كبير.
- نريد تحسين الجزء الخلفي لمتطلبات واجهة محددة.
- يتم إجراء تخصيصات على جزء خلفي عام لاستيعاب واجهات متعددة.

# REST وGraphQL وgRPC

تصميم واجهة برمجة التطبيقات (API) جيدة هو دائمًا جزء حاسم من أي نظام. ولكن من المهم أيضًا اختيار التكنولوجيا المناسبة للAPI. لذلك، في هذا البرنامج التعليمي، سنناقش بإيجاز مختلف تقنيات API مثل REST وGraphQL وgRPC.

## ما هي واجهة برمجة التطبيقات؟

قبل أن ندخل في تقنيات واجهة برمجة التطبيقات، دعنا نفهم أولاً ما هي واجهة برمجة التطبيقات.

واجهة برمجة التطبيقات (API) هي مجموعة من التعريفات والبروتوكولات لبناء ودمج برمجيات التطبيق. يُشار إليها أحيانًا باسم اتفاقية بين مُزوِّد المعلومات ومُستخدِم المعلومات لتحديد المحتوى المطلوب من المنتج والمحتوى المطلوب من المستهلك.

ببساطة، إذا كنت ترغب في التفاعل مع جهاز كمبيوتر أو نظام لاسترداد المعلومات أو تنفيذ وظيفة ما، تساعدك واجهة برمجة التطبيقات على التواصل مع هذا النظام حتى يفهم وينفذ الطلب.

## REST

واجهة برمجة التطبيقات القائمة على نمط REST (تُعرف أيضًا بواجهة RESTful API) هي واجهة برمجة التطبيقات تتوافق مع قيود نمط REST المعماري وتسمح بالتفاعل مع خدمات الويب القائمة على REST. تعني REST "نقل الحالة التمثيلية" وتم تقديمها لأول مرة من قبل [روي فيلدينغ](https://roy.gbiv.com) في عام 2000.

_في واجهة برمجة التطبيقات القائمة على REST، الوحدة الأساسية هي المورد._

### المفاهيم

دعنا نناقش بعض المفاهيم المتعلقة بواجهة RESTful.

**القيود**

لكي يُعتبر API "RESTful"، يجب أن يتوافق مع القيود المعمارية التالية:

- **واجهة موحدة**: يجب أن يكون هناك طريقة موحدة للتفاعل مع خادم معين.
- **العميل - الخادم**: هيكل عميل - خادم يُدار عبر HTTP.
- **بدون حالة**: لا يتم تخزين سياق العميل على الخادم بين الطلبات.
- **قابل للتخزين المؤقت**: يجب أن يتضمن كل استجابة ما إذا كانت قابلة للتخزين المؤقت أو لا وكم من الوقت يمكن تخزين الاستجابات في جانب العميل.
- **نظام متعدد الطبقات**: يجب أن يتكون تصميم التطبيق من طبقات متعددة.
- **الكود عند الطلب**: إرجاع الكود القابل للتنفيذ لدعم جزء من تطبيقك. _(اختياري)_

**أفعال HTTP**

يحدد بروتوكول HTTP مجموعة من طرق الطلب للإشارة إلى الإجراء المرغوب في أدائه لمورد معين. على الرغم من أنها يمكن أن تكون أيضًا اسماء أشياء، إلا أن هذه الطرق طلب يُشار إليها أحيانًا باسم "أفعال HTTP". تنفذ كل منها دلالة مختلفة، ولكن يتم مشاركة بعض الميزات المشتركة بين مجموعة منها.

وفيما يلي بعض أفعال HTTP المستخدمة بشكل شائع:

- **GET**: طلب تمثيل المورد المحدد.
- **HEAD**: الاستجابة مماثلة لطلب `GET`، ولكن بدون هيئة الاستجابة.
- **POST**: يُرسل كيانًا إلى المورد المحدد، مما يتسبب في تغيير الحالة أو الآثار الجانبية على الخادم.
- **PUT**: استبدل جميع تمثيلات الم

ورد المستهدف بحمولة الطلب.
- **DELETE**: حذف المورد المحدد.
- **PATCH**: تطبيق التعديلات الجزئية على المورد.

**أكواد استجابة HTTP**

تُشير أكواد استجابة نظام بروتوكول نقل النص الفائق (HTTP) إلى ما إذا تم إكمال طلب HTTP المحدد بنجاح.

هناك خمس فئات محددة في المعيار:

- 1xx - استجابات إعلامية.
- 2xx - استجابات ناجحة.
- 3xx - استجابات إعادة توجيه.
- 4xx - استجابات خطأ العميل.
- 5xx - استجابات خطأ الخادم.

على سبيل المثال، تعني HTTP 200 أن الطلب تم بنجاح.

### المزايا

دعنا نناقش بعض المزايا لواجهة REST API:

- بسيطة وسهلة الفهم.
- مرنة وقابلة للتنقل.
- دعم جيد للتخزين المؤقت.
- العميل والخادم غير مرتبطين بشكل وثيق.

### العيوب

دعنا نناقش بعض العيوب لواجهة REST API:

- زيادة في جلب البيانات.
- في بعض الأحيان يتطلب جولات متعددة إلى الخادم.

### الحالات الاستخدامية

تُستخدم واجهات REST API تقريبًا عالميًا وهي المعيار الافتراضي لتصميم الAPIs. بصفة عامة، تعتبر واجهات REST API مرنة جدًا ويمكن أن تناسب تقريبًا جميع السيناريوهات.

### المثال

فيما يلي مثال على استخدام واجهة REST API التي تعمل على المورد **المستخدمين**.

| URI           | طريقة HTTP | الوصف                         |
| ------------- | ----------- | ------------------------------ |
| /users        | GET         | الحصول على جميع المستخدمين   |
| /users/\{id\} | GET         | الحصول على مستخدم بالمعرف   |
| /users        | POST        | إضافة مستخدم جديد            |
| /users/\{id\} | PATCH       | تحديث مستخدم بالمعرف        |
| /users/\{id\} | DELETE      | حذف مستخدم بالمعرف          |

_هناك الكثير للتعلم عندما يتعلق الأمر بواجهات REST API، يوصى بشدة بالبحث عن [Hypermedia as the Engine of Application State (HATEOAS)](https://en.wikipedia.org/wiki/HATEOAS)._

## GraphQL

[GraphQL](https://graphql.org) هو لغة استعلام ووقت تشغيل لخدمات واجهة برمجة التطبيقات (API) التي تُعطي العملاء بالضبط البيانات التي يطلبونها ولا شيء أكثر. تم تطويره بواسطة [فيسبوك](https://engineering.fb.com) وصدر كشف مصدره في عام 2015.

تم تصميم GraphQL لجعل واجهات البرمجة التطبيقات سريعة ومرنة وسهلة الاستخدام للمطورين. بالإضافة إلى ذلك، يمنح GraphQL مُشغلي الAPI المرونة لإضافة أو إسقاط الحقول دون التأثير على الاستعلامات الحالية. يمكن للمطورين بناء واجهات برمجة تطبيقات بأي طرق يفضلون، وسيضمن المواصفات GraphQL أنها ستعمل بطرق متوقعة للعملاء.

_في GraphQL، الوحدة الأساسية هي الاستعلام._

### المفاهيم

دعنا نناقش بإيجاز بعض المفاهيم الرئيسية في GraphQL:

**المخطط (Schema)**

يصف المخطط في GraphQL الوظائف التي يمكن للعملاء الاستفادة منها عند الاتصال بخادم GraphQL.

**الاستعلامات (Queries)**

الاستعلام هو طلب يتم إجراؤه بواسطة العميل. يمكن أن يتألف من حقول ومعاملات للاستعلام. يمكن أن يكون نوع العملية في الاستعلام أيضًا [طرح](https://graphql.org/learn/queries/#mutations) يوفر وسيلة لتعديل بيانات الخادم.

**المحللون (Resolvers)**

المحلل هو مجموعة من الوظائف التي تنشئ استج

ابات للاستعلام في GraphQL. ببساطة، يعمل المحلل كمعالج للاستعلام GraphQL.

### المزايا

دعنا نناقش بعض المزايا لGraphQL:

- يزيل جلب البيانات الزائد.
- مخطط معرف بشكل قوي.
- دعم توليد الشفرة.
- تحسين الحمولة.

### العيوب

دعنا نناقش بعض العيوب لGraphQL:

- يحول التعقيد إلى جانب الخادم.
- يصعب تخزين البيانات المؤقتة.
- الإصدار غامض.
- مشكلة N+1.

### الحالات الاستخدامية

يثبت GraphQL أهميته في الحالات التالية:

- تقليل استخدام عرض النطاق الترددي في التطبيق حيث يمكننا استعلام موارد متعددة في استعلام واحد.
- إنشاء نماذج أولية سريعة للأنظمة المعقدة.
- عند العمل مع نموذج بيانات شبيه بالرسم البياني.

### المثال

فيما يلي مخطط GraphQL يحدد نوعًا `User` ونوعًا `Query`.

```graphql
type Query {
  getUser: User
}

type User {
  id: ID
  name: String
  city: String
  state: String
}
```

باستخدام المخطط أعلاه، يمكن للعميل طلب الحقول المطلوبة بسهولة دون الحاجة إلى جلب المورد بأكمله أو تخمين ما قد ترجعه واجهة الAPI.

```graphql
{
  getUser {
    id
    name
    city
  }
}
```

سيعطي ذلك الاستعلام الاستجابة التالية للعميل.

```json
{
  "getUser": {
    "id": 123,
    "name": "Karan",
    "city": "San Francisco"
  }
}
```

_تعرف على المزيد حول GraphQL على [graphql.org](https://graphql.org)._

## gRPC

[gRPC](https://grpc.io) هو إطار عمل عالي الأداء مفتوح المصدر وحديث لـ [استدعاء الإجراءات عن بُعد (RPC)](https://en.wikipedia.org/wiki/Remote_procedure_call) يمكن تشغيله في أي بيئة. يمكنه الاتصال بكفاءة بالخدمات داخل وخارج مراكز البيانات مع دعم قابل للتوصيل للتوازن والتتبع وفحص الصحة والمصادقة والمزيد بحسب الاحتياجات.

### المفاهيم

دعنا نناقش بعض المفاهيم الرئيسية لـ gRPC.

**بروتوكولات البيانات**

توفر بروتوكولات البيانات آلية قابلة للتوسيع لتسلسل البيانات المنظمة بشكل هيكلي بطريقة متوافقة في اتجاهين. إنها مثل JSON، باستثناء أنها أصغر وأسرع، وتُولد الروابط اللغوية الأصلية.

**تعريف الخدمة**

مثل العديد من نظم RPC، يستند gRPC إلى فكرة تعريف خدمة وتحديد الطرق التي يمكن استدعاؤها عن بُعد مع معاملاتها وأنواع العودة.

### المزايا

دعنا نناقش بعض المزايا لـ gRPC:

- خفيف الوزن وفعال.
- أداء عالٍ.
- دعم توليد الشفرة المدمجة.
- تدفق ثنائي الاتجاه.

### العيوب

دعنا نناقش بعض العيوب لـ gRPC:

- جديد نسبيًا مقارنة بـ REST وGraphQL.
- دعم المتصفح محدود.
- منحنى التعلم شديد الانحدار.
- غير قابل للقراءة بالنسبة للإنسان.

### الحالات الاستخدامية

فيما يلي بعض حالات الاستخدام الجيدة لـ gRPC:

- الاتصال الزمني الحقيقي عبر التدفق الثنائي الاتجاهي.
- التواصل بين الخدمات بكفاءة في الخدمات الميكرو.
- التواصل منخفض التأخير وعالي الإنتاجية.
- البيئات متعددة اللغات.

### المثال

فيما يلي مثال أساسي لخدمة gRPC تم تعريفها في ملف `*.proto`. باستخدام هذا التعريف، يمكننا بسهولة توليد الشفرة لخدمة `HelloService` بلغة البرمجة التي نفضلها.

```protobuf
service HelloService {
  rpc SayHello (HelloRequest) returns (HelloResponse);
}

message HelloRequest {
  string greeting = 1;
}

message HelloResponse {
  string reply = 1;
}
```

## REST مقابل GraphQL مقابل gRPC

الآن بعد أن عرفنا كيف تعمل هذه التقنيات لتصميم الAPI، دعنا نقارن بينهم بناءً على المعايير التالية:

- هل سيتسبب في الارتباط القوي؟
- كيف هي الحاجة للاتصالات المستقلة (API الاستدعاءات المميزة للحصول على المعلومات المطلوبة؟)
- كيف هي الأداء؟
- مدى تعقيد التكامل؟
- كيف يعمل التخزين المؤقت؟
- دعم الأدوات المدمجة وتوليد الشفرة؟
- مدى اكتشافية الAPI؟
- مدى سهولة إصدار الAPI؟

| النوع    | الارتباط | الاتصالات | الأداء | التكامل | التخزين المؤقت | توليد الشفرة | اكتشافية الAPI | إصدار الAPI |
| ------- | -------- | ---------- | ------- | -------- | --------------- | ------------ | --------------- | ---------- |
| REST    | منخفض   | عالي       | جيد    | متوسط   | جيد           | سيء            | جيد            | سهل       |
| GraphQL | متوسط    | منخفض      | جيد    | عالي     | مخصص          | جيد            | جيد            | مخصص      |
| gRPC    | عالي     | متوسط      | عظيم    | منخفض   | مخصص          | عظيم          | سيء            | صعب       |

### أي تكنولوجيا API أفضل؟

حسنًا، الجواب ليس أي منهم. لا يوجد حلاً سحريًا حيث لكل من هذه التقنيات مزاياها وعيوبها. يهتم المستخدمون فقط باستخدام API بطريقة متسقة، لذلك تأكد من التركيز على مجالك ومتطلباتك عند تصميم API الخاص بك.

# التدقيق الطويل، نظائر الويب، أحداث الخادم المُرسلة (SSE)

تم تطوير التطبيقات الويب في البداية حول نموذج العميل-الخادم، حيث يكون العميل هو المبادر دائمًا للمعاملات مثل طلب البيانات من الخادم. وبالتالي، لم يكن هناك آلية للخادم لإرسال البيانات بشكل مستقل، أو دفعها، إلى العميل دون أن يقوم العميل أولاً بإجراء طلب. لنناقش بعض الطرق للتغلب على هذه المشكلة.

## التدقيق الطويل

التدقيق الطويل عبر HTTP هو تقنية تُستخدم لدفع المعلومات إلى العميل في أقرب وقت ممكن من الخادم. وبالتالي، لا يتعين على الخادم الانتظار حتى يُرسل العميل طلبًا.

في التدقيق الطويل، لا يُغلق الخادم الاتصال بمجرد استلامه لطلب من العميل. بدلاً من ذلك، يُرد الخادم فقط إذا كان هناك أي رسالة جديدة مُتاحة أو تم الوصول إلى عتبة الانتهاء من الوقت المحدد.

![long-polling](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-III/long-polling-websockets-server-sent-events/long-polling.png)

عندما يتلقى العميل استجابة، يُرسل على الفور طلبًا جديدًا إلى الخادم لإنشاء اتصال معلق جديد لإرسال البيانات إلى العميل، ويتم تكرار العملية. بهذا النهج، يحاكي الخادم ميزة دفع الخادم في الوقت الفعلي.

### العملية

دعنا نفهم كيف يعمل التدقيق الطويل:

1. يقوم العميل بإجراء طلبٍ أولي وينتظر استجابة.
2. يستقبل الخادم الطلب ويؤخر إرسال أي شيء حتى يتوفر تحديث.
3. بمجرد توفر تحديث، يتم إرسال الاستجابة إلى العميل.
4. يستقبل العميل الاستجابة ويُجري طلبًا جديدًا فورًا أو بعد فترة زمنية محددة لإعادة إنشاء الاتصال مرة أخرى.

### المزايا

إليك بعض المزايا للتدقيق الطويل:

- سهل التنفيذ وجيد للمشاريع ذات النطاق الصغير.
- يتم دعمه تقريبًا من الجميع.

### العيوب

السيئ الأساسي للتدقيق الطويل هو أنه عادة لا يكون موسعًا. فيما يلي بعض الأسباب الأخرى:

- يُنشئ اتصالًا جديدًا في كل مرة، مما قد يكون مكثفًا على الخادم.
- قد تكون ترتيب الرسائل الموثوق بها مشكلة للطلبات المتعددة.
- زيادة التأخير حيث يحتاج الخادم إلى الانتظار للطلب الجديد.

## نظائر الويب

توفر نظائر الويب قنوات اتصال ثنائية الاتجاه عبر اتصال TCP واحد. إنها اتصال دائم بين العميل والخادم يمكن لكلا الطرفين استخدامه لبدء إرسال البيانات في أي وقت.

يُنشئ العميل اتصالًا نظائر الويب من خلال عملية تعرف باسم مصافحة نظائر الويب. إذا نجحت العملية، يمكن للخادم والعميل تبادل البيانات في كلا الاتجاهين في أي وقت. يُمكّن بروتوكول نظائر الويب التواصل بين العميل والخادم بتكاليف أقل، مما يُيسّر نقل البيانات في الوقت الفعلي من وإلى الخادم.

![نظائر الويب](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-III/long-polling-websockets-server-sent

-events/websockets.png)

يتم ذلك عن طريق توفير طريقة موحدة للخادم لإرسال المحتوى إلى العميل دون أن يُطلب منه ذلك والسماح بتمرير الرسائل ذهابًا وإيابًا مع الاحتفاظ بالاتصال مفتوحًا.

### العملية

دعنا نفهم كيف تعمل نظائر الويب:

1. يبدأ العميل عملية مصافحة نظائر الويب عن طريق إرسال طلب.
2. يحتوي الطلب أيضًا على رأس [HTTP Upgrade](https://en.wikipedia.org/wiki/HTTP/1.1_Upgrade_header) الذي يسمح للطلب بالتبديل إلى بروتوكول نظائر الويب (`ws://`).
3. يرسل الخادم استجابة إلى العميل، مع التأكيد على طلب مصافحة نظائر الويب بنجاح.
4. سيتم فتح اتصال نظائر الويب بمجرد أن يتلقى العميل استجابة ناجحة لعملية المصافحة.
5. الآن يمكن للعميل والخادم البدء في إرسال البيانات في كلا الاتجاهين مما يُمكن الاتصال في الوقت الفعلي.
6. يتم إغلاق الاتصال عندما يقرر الخادم أو العميل إغلاق الاتصال.

### المزايا

فيما يلي بعض مزايا نظائر الويب:

- الرسائل الجاهزة للإرسال غير المتزامن.
- نموذج أمان أفضل يعتمد على المصدر.
- خفيفة الوزن للعميل والخادم على حد سواء.

### العيوب

لنناقش بعض سلبيات نظائر الويب:

- لا يتم استعادة الاتصالات المُنتهية تلقائيًا.
- المتصفحات القديمة لا تدعم نظائر الويب (أصبحت ذات أهمية أقل).

## أحداث الخادم المُرسلة (SSE)

أحداث الخادم المُرسلة (SSE) هي طريقة لإقامة اتصال طويل الأمد بين العميل والخادم يتيح للخادم دفع البيانات إلى العميل بشكل استباقي.

![أحداث الخادم المُرسلة](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-III/long-polling-websockets-server-sent-events/server-sent-events.png)

إنها اتصال ذو اتجاه واحد، وهذا يعني بمجرد أن يرسل العميل الطلب، يمكنه استقبال الاستجابات فقط دون القدرة على إرسال طلبات جديدة عبر نفس الاتصال.

### العملية

دعنا نفهم كيف تعمل أحداث الخادم المُرسلة:

1. يقوم العميل بإجراء طلب للخادم.
2. يتم إنشاء الاتصال بين العميل والخادم ويبقى مفتوحًا.
3. يقوم الخادم بإرسال الاستجابات أو الأحداث إلى العميل عندما تكون البيانات الجديدة مُتاحة.

### المزايا

- سهلة التنفيذ وسهلة الاستخدام للعميل والخادم على حد سواء.
- مدعومة من معظم المتصفحات.
- لا تواجه مشاكل مع جدران الحماية.

### العيوب

- قد تكون الطبيعة ذات الاتجاه قيدًا.
- قيود للحد الأقصى لعدد الاتصالات المفتوحة.
- لا يدعم بيانات ثنائية.


# ترميز الموقع الجغرافي والأشجار الرباعية

## ترميز الموقع الجغرافي

تعد ترميز الموقع الجغرافي (Geohashing) وسيلة لترميز الإحداثيات الجغرافية مثل خط العرض وخط الطول إلى سلاسل أبجدية قصيرة. تم ابتكارها من قبل [جوستافو نيمير](https://twitter.com/gniemeyer) في عام 2008.

على سبيل المثال، يمكن تمثيل سان فرانسيسكو بالإحداثيات `37.7564، -122.4016` في ترميز الموقع الجغرافي باستخدام `9q8yy9mf`.

### كيف يعمل ترميز الموقع الجغرافي؟

تعتبر ترميز الموقع الجغرافي مؤشرًا مكانيًا تسلسليًا يستخدم ترميزًا ألفبائيًا من 32 رمزًا. يُعرف الرمز الأول في ترميز الموقع الجغرافي الموقع الأولي كواحد من الخلايا الـ 32. ستحتوي هذه الخلية أيضًا على 32 خليةً أخرى. يعني هذا أن العالم يتم تقسيمه هرميًا إلى خلايا أصغر وأصغر مع كل بت إضافي حتى يتم الحصول على الدقة المطلوبة. يُحدد عامل الدقة أيضًا حجم الخلية.

![ترميز الموقع الجغرافي](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-IV/geohashing-and-quadtrees/geohashing.png)

تضمن ترميز الموقع الجغرافي أن النقاط أقرب فضائيًا إذا كانت إحداثيات ترميز الموقع الخاصة بها تشترك في بادئة أطول، وهذا يعني أنه كلما زاد عدد الأحرف في السلسلة، زادت الدقة. على سبيل المثال، تعتبر إحداثيات ترميز الموقع `9q8yy9mf` و `9q8yy9vx` أقرب مكانيًا حيث يشتركان في البادئة `9q8yy9`.

يمكن استخدام ترميز الموقع الجغرافي أيضًا لتوفير درجة من الاستبقاء لأنه لا يلزمنا كشف الموقع الدقيق للمستخدم نظرًا لأننا، اعتمادًا على طول ترميز الموقع، نعلم فقط أنهم في منطقة معينة.

حجم خلايا ترميز الموقع الجغرافي بأطوال مختلفة هو على النحو التالي:

| طول ترميز الموقع | عرض الخلية | ارتفاع الخلية |
| -------------- | ---------- | ----------- |
| 1              | 5000 كم    | 5000 كم     |
| 2              | 1250 كم    | 1250 كم     |
| 3              | 156 كم     | 156 كم      |
| 4              | 39.1 كم    | 19.5 كم     |
| 5              | 4.89 كم    | 4.89 كم     |
| 6              | 1.22 كم    | 0.61 كم     |
| 7              | 153 متر    | 153 متر     |
| 8              | 38.2 متر   | 19.1 متر    |
| 9              | 4.77 متر   | 4.77 متر    |
| 10             | 1.19 متر   | 0.596 متر   |
| 11             | 149 ملم    | 149 ملم     |
| 12             | 37.2 ملم   | 18.6 ملم    |

### حالات الاستخدام

فيما يلي بعض حالات استخدام ترميز الموقع الجغرافي الشائعة:

- إنها طريقة بسيطة لتمثيل وتخزين الموقع في قاعدة البيانات.
- يمكن مشاركتها أيضًا على وسائل التواصل الاجتماعي عبر روابط URL حيث يكون من الأسهل مشاركتها وتذكرها من خطوط العرض وخطوط الطول.
- يمكننا البحث بكفاءة عن الجيران الأقرب لنقطة من خلال مقارنات سلاسل سهلة والبحث الفعال في الفهارس.

### أمثلة

يُستخدم ترميز الموقع الجغرافي على نط

اق واسع ويتم دعمه من قبل قواعد البيانات الشهيرة.

- [MySQL](https://www.mysql.com)
- [Redis](http://redis.io)
- [Amazon DynamoDB](https://aws.amazon.com/dynamodb)
- [Google Cloud Firestore](https://cloud.google.com/firestore)

## الأشجار الرباعية

الأشجار الرباعية هي هيكل بيانات شجري يحتوي كل عقدة داخلية بالضبط على أربعة أبناء. غالبًا ما تُستخدم لتقسيم مساحة ثنائية الأبعاد عن طريق تقسيمها بشكل هرمي إلى أربعة رباعيات أو مناطق. تخزن كل عقدة فرعية أو ورقة معلومات فضائية. تعتبر الأشجار الرباعية التناظر الثنائي للأشجار الثمانية (Octrees) التي تستخدم لتقسيم المساحة ثلاثية الأبعاد.

![الأشجار الرباعية](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-IV/geohashing-and-quadtrees/quadtree.png)

### أنواع الأشجار الرباعية

يمكن تصنيف الأشجار الرباعية وفقًا لنوع البيانات التي تمثلها، بما في ذلك المناطق، النقاط، الخطوط، والمنحنيات. وفيما يلي بعض أنواع الأشجار الرباعية الشائعة:

- أشجار النقاط.
- أشجار النقطة-المنطقة (PR).
- أشجار الخريطة المضلعة (PM).
- أشجار الضغط.
- أشجار الحواف.

### لماذا نحتاج إلى الأشجار الرباعية؟

أليس خطوط العرض وخطوط الطول كافية؟ لماذا نحتاج إلى الأشجار الرباعية؟ على الرغم من أنه في النظرية يمكننا تحديد مدى قرب النقاط من بعضها البعض باستخدام المسافة الأوروبية، إلا أنه في حالات الاستخدام العملية لا يُعد ذلك مجديًا بسبب طبيعته المكلفة لوحدة المعالجة المركزية عند التعامل مع مجموعات بيانات كبيرة.

تتيح لنا الأشجار الرباعية البحث عن النقاط داخل نطاق ثنائي الأبعاد بكفاءة، حيث يتم تعريف هذه النقاط كإحداثيات خط العرض/خط الطول أو كإحداثيات كارتيسية (x، y). بالإضافة إلى ذلك، يمكننا توفير المزيد من الحسابات عن طريق تقسيم العقدة فقط بعد تجاوز عتبة معينة. ومع تطبيق خوارزميات التعيين الفراغي مثل [المنحنى هيلبرت](https://en.wikipedia.org/wiki/Hilbert_curve)، يمكننا تحسين أداء استعلام النطاق بسهولة.

### حالات الاستخدام

فيما يلي بعض استخدامات الأشجار الرباعية الشائعة:

- تمثيل الصور، ومعالجتها، وضغطها.
- فهرسة المساحة واستعلامات النطاق.
- الخدم

ات المستندة إلى الموقع مثل خرائط جوجل، أوبر، إلخ.
- توليد الشبكة والرسومات الكمبيوترية.
- تخزين البيانات الضعيفة.

أرجو أن يكون هذا النص مفيداً لك. إذا كان هناك أي استفسار آخر تود الحصول على إجابة له، فلا تتردد في طرحه!

# قاطع الدائرة

قاطع الدائرة هو نمط تصميم يُستخدم لاكتشاف الأخطاء ويحتوي على منطق لمنع تكرار الفشل باستمرار أثناء الصيانة أو فشل النظام الخارجي المؤقت أو صعوبات غير متوقعة في النظام.

![قاطع الدائرة](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-IV/circuit-breaker/circuit-breaker.png)

الفكرة الأساسية وراء قاطع الدائرة بسيطة جدًا. نقوم بلفّ دعوة وظيفة محمية بكائن قاطع الدائرة، الذي يراقب الأخطاء. بمجرد أن تصل الأخطاء إلى عتبة معينة، يتم تشغيل قاطع الدائرة وتعود كل المكالمات اللاحقة إلى قاطع الدائرة مع خطأ، دون أن يتم عمل الدعوة المحمية على الإطلاق. عادةً، سنرغب أيضًا في الحصول على تنبيه إذا تم تشغيل قاطع الدائرة.

## لماذا نحتاج إلى قاطع الدائرة؟

من المشترك أن يقوم أنظمة البرمجيات بإجراءات استدعاء للبرمجيات التي تعمل في عمليات مختلفة، ربما على أجهزة مختلفة عبر شبكة. إحدى الاختلافات الكبيرة بين الاستدعاءات الموجودة في الذاكرة والاستدعاءات البعيدة هي أن الاستدعاءات البعيدة قد تفشل، أو تتعطل دون استجابة حتى يتم الوصول إلى حد الانتهاء المؤقت. والأسوأ من ذلك هو إذا كان لدينا العديد من المستدعين على مورد غير مستجيب، فيمكن أن ننفد من الموارد الحرجة مما يؤدي إلى تعثر الفشل عبر أنظمة متعددة.

## الحالات

لنتناقش حول حالات قاطع الدائرة:

### مغلق

عندما تكون الأمور طبيعية، يظل قواطع الدائرة مغلقة، وتمر جميع الطلبات إلى الخدمات كالمعتاد. إذا زادت عدد الأخطاء متجاوزة الحد المسموح به، يتم تشغيل قاطع الدائرة ويدخل في حالة مفتوحة.

### مفتوح

في هذه الحالة، يُرجع قاطع الدائرة خطأ على الفور دون استدعاء الخدمات. تنتقل قواطع الدائرة إلى حالة مفتوحة بعد مرور فترة زمنية معينة. عادةً، ستحتوي على نظام مراقبة حيث سيتم تحديد المهلة الزمنية.

### شبه مفتوح

في هذه الحالة، يسمح قاطع الدائرة بعدد محدود من الطلبات من الخدمة للمرور وتنفيذ العملية. إذا كانت الطلبات ناجحة، يتجه قاطع الدائرة إلى الحالة المغلقة. ومع ذلك، إذا استمرت الطلبات في الفشل، فإنه يعود إلى الحالة المفتوحة.

# تحديد الحد الزمني

تحديد الحد الزمني يشير إلى منع تكرار العملية من تجاوز الحد المحدد. في الأنظمة ذات النطاق الواسع، يتم استخدام تحديد الحد الزمني بشكل شائع لحماية الخدمات والموارد الأساسية. يتم استخدام تحديد الحد الزمني عمومًا كآلية دفاعية في الأنظمة الموزعة، بحيث يمكن للموارد المشتركة الحفاظ على التوفر. كما أنه يحمي واجهات برمجة التطبيقات (APIs) الخاصة بنا من الاستخدام الزائد غير المقصود أو الضار عن طريق تحديد عدد الطلبات التي يمكن أن تصل إلى واجهة برمجة التطبيق في فترة زمنية معينة.

![تحديد الحد الزمني](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-IV/rate-limiting/rate-limiting.png)

## لماذا نحتاج إلى تحديد الحد الزمني؟

تحديد الحد الزمني هو جزء مهم جدًا من أي نظام ذو مقياس كبير، ويمكن استخدامه لتحقيق الأهداف التالية:

- تجنب نقص الموارد نتيجة هجمات حجب الخدمة (DoS).
- يساعد تحديد الحد الزمني في التحكم في التكاليف التشغيلية من خلال وضع سقف افتراضي على توسعة الموارد، وإلا فقد يؤدي عدم المراقبة إلى فواتير ضخمة.
- يمكن استخدام تحديد الحد الزمني كآلية دفاعية أو التخفيف من بعض الهجمات المشتركة.
- بالنسبة لواجهات برمجة التطبيقات التي تعمل على معالجة كميات ضخمة من البيانات، يمكن استخدام تحديد الحد الزمني للتحكم في تدفق تلك البيانات.

## الخوارزميات

هناك خوارزميات مختلفة لتحديد الحد الزمني للواجهات البرمجية، لكل منها مزاياه وعيوبه. دعنا نناقش بإيجاز بعض هذه الخوارزميات:

### دلو المثقبة

دلو المثقبة هو خوارزمية توفر نهجًا بسيطًا وبديهيًا لتحديد الحد الزمني عبر قائمة انتظار. عند تسجيل طلب، يتم إلحاقه بنهاية القائمة. يحدث معالجة العنصر الأول في القائمة بانتظام أو أولاً داخل أولاً خارج (FIFO). إذا كانت القائمة ممتلئة، فإن الطلبات الإضافية تُتجاوز (أو تسرب).

### دلو الرمز المميز

نستخدم هنا مفهوم _الدلو_. عندما يأتي طلب، يجب أن يتم أخذ دلو من المخزون ومعالجته. سيتم رفض الطلب إذا لم يكن هناك دلو متاح في المخزون، وعلى المرسل أن يحاول مرة أخرى لاحقًا. ونتيجة لذلك، يتم تحديث دلو المخزون بعد فترة زمنية معينة.

### النافذة الثابتة

تستخدم النظام نافذة زمنية بحجم `n` ثانية لتتبع معدل خوارزمية النافذة الثابتة. يزيد كل طلب وارد عداد النافذة. يتم رفض الطلب إذا تجاوز عداد النافذة الحد المحدد.

### السجل المنزلق

تتضمن تحديد الحد الزمني السجل المنزلق تتبع سجل محدد بالوقت لكل طلب. يقوم النظام بتخزين هذه السجلات في مجموعة أو جدول مرتب بالوقت. يتم أيضًا رفض السجلات ذات الطوابق الزمنية التي تتجاوز حدًا معينًا. عندما يأتي طلب

 جديد، نحسب مجموع السجلات لتحديد معدل الطلب. إذا كان الطلب سيتجاوز معدل الحد، فإنه يتم تأجيله.

### النافذة المنزلقة

النافذة المنزلقة هي نهج مختلط يجمع بين التكلفة المعالجة المنخفضة لخوارزمية النافذة الثابتة وتحسين الظروف الحدودية للسجل المنزلق. على غرار خوارزمية النافذة الثابتة، نتتبع عداد لكل نافذة ثابتة. بعد ذلك، نأخذ في الاعتبار قيمة مرجحة لمعدل طلب النافذة السابقة بناءً على الطابع الزمني الحالي لتخفيف اندفاعات حركة المرور.

## تحديد الحد الزمني في الأنظمة الموزعة

يصبح تحديد الحد الزمني معقدًا عندما يتورط الأنظمة الموزعة. المشاكل الرئيسية التي تأتي مع تحديد الحد الزمني في الأنظمة الموزعة هي:

### عدم التسقيم

عند استخدام مجموعة من العقد المتعددة، قد نحتاج إلى فرض سياسة حد زمني عالمية. لأنه إذا تعقبت كل عقدة حد زمني خاص بها، فقد يمكن للمستهلك أن يتجاوز الحد الزمني العالمي عند إرسال الطلبات إلى عقدات مختلفة. وكلما زاد عدد العقد، زادت احتمالية تجاوز المستخدم الحد العالمي.

أبسط طريقة لحل هذه المشكلة هو استخدام جلسات لاصقة في توازن الحمل لدينا بحيث يتم إرسال كل مستهلك إلى عقدة واحدة فقط ولكن هذا يسبب نقصًا في التحمل ومشاكل التوازن. يمكن أن يكون النهج الآخر هو استخدام مخزن بيانات مركزي مثل [Redis](https://redis.io) ولكن هذا سيزيد من التأخير ويسبب مشاكل التسابق.

### مشاكل التسابق

يحدث هذا المشكل عندما نستخدم نهج _"احصل ثم ضع"_ الساذج، حيث نسترد عداد حد الحد الحالي ونزيد من قيمته، ثم نضغط به مرة أخرى إلى مخزن البيانات. مشكلة هذا النموذج هي أنه يمكن أن تأتي طلبات إضافية خلال الوقت الذي يستغرقه الأمر لأداء دورة كاملة من القراءة والزيادة والتخزين، حيث يحاول كل منها تخزين عداد الزيادة بقيمة عداد غير صالحة (أقل). هذا يتيح للمستهلك إرسال عدد كبير جدًا من الطلبات لتجاوز التحكم في الحد.

طريقة لتجنب هذه المشكلة هي استخدام آلية قفل موزعة حول المفتاح، تمنع أي عمليات أخرى من الوصول إلى العداد أو كتابة قيمة العداد. على الرغم من ذلك، سيصبح القفل عائقًا كبيرًا ولن يتم توسيعه بشكل جيد. يمكن أن يكون النهج الأفضل هو استخدام نموذج _"ضع ثم احصل"_، مما يسمح لنا بزيادة قيم العداد بسرعة والتحقق من قيم العداد بسرعة دون السماح للعمليات الذرية أن تتعارض مع بعضها البعض.

# اكتشاف الخدمات

اكتشاف الخدمات هو اكتشاف الخدمات داخل شبكة الكمبيوتر. بروتوكول اكتشاف الخدمات (SDP) هو معيار للشبكات يقوم بالكشف عن الشبكات من خلال تحديد الموارد.

## لماذا نحتاج إلى اكتشاف الخدمات؟

في تطبيق أحادي القطعة، تقوم الخدمات باستدعاء بعضها البعض من خلال أساليب على مستوى اللغة أو استدعاء الإجراءات. ومع ذلك، تعمل تطبيقات الخدمات المعتمدة على الميكروسيرفس بشكل حديث عادةً في بيئات مجازية أو مُحاكاة حيث يتغير عدد نسخ الخدمة ومواقعها بشكل دينامي. وبالتالي، نحتاج إلى آلية تمكن عملاء الخدمات من تقديم طلبات إلى مجموعة متغيرة ديناميًا من نسخ الخدمة العابرة.

## التنفيذات

هناك نمطين رئيسيين لاكتشاف الخدمات:

### الاكتشاف من الجانب العميل

![الاكتشاف من الجانب العميل](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-IV/service-discovery/client-side-service-discovery.png)

في هذا النهج، يحصل العميل على موقع خدمة أخرى عن طريق استعلام سجل الخدمة الذي يتولى إدارة وتخزين مواقع الشبكة لجميع الخدمات.

### الاكتشاف من الجانب الخادم

![الاكتشاف من الجانب الخادم](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-IV/service-discovery/server-side-service-discovery.png)

في هذا النهج، نستخدم عنصرًا وسيطيًا مثل توازن الحمل. يقوم العميل بإرسال طلب إلى الخدمة عبر توازن الحمل الذي يمر بدوره بالطلب إلى نسخة خدمة متاحة.

## سجل الخدمة

سجل الخدمة هو في الأساس قاعدة بيانات تحتوي على مواقع شبكة نسخ الخدمة التي يمكن للعملاء الوصول إليها. يجب أن يكون سجل الخدمة متاحًا بشكل كبير وحديثًا.

## تسجيل الخدمة

نحتاج أيضًا إلى وسيلة للحصول على معلومات الخدمة، وتُعرف عادة بتسجيل الخدمة. دعونا نلقي نظرة على نهجين ممكنين لتسجيل الخدمة:

### التسجيل الذاتي

عند استخدام نموذج التسجيل الذاتي، تكون نسخة الخدمة مسؤولة عن تسجيل نفسها وإلغاء تسجيلها في سجل الخدمة. بالإضافة إلى ذلك، إذا كان ذلك ضروريًا، ترسل

 نسخة الخدمة طلبات تحقق النبض للحفاظ على تسجيلها حيًا.

### التسجيل من جهة ثالثة

يقوم السجل بتتبع التغييرات في النسخ المشغلة من خلال استطلاع بيئة النشر أو الاشتراك في الأحداث. عند اكتشاف نسخة خدمة متاحة حديثًا، يقوم بتسجيلها في قاعدة بياناته. يقوم سجل الخدمة أيضًا بإلغاء تسجيل نسخ الخدمة المنتهية.

## شبكة الخدمة

الاتصال من خدمة إلى خدمة ضروري في تطبيق موزع، ولكن تصبح توجيه هذا الاتصال، سواء داخل تجمعات التطبيق أو عبرها، معقدًا بشكل متزايد مع زيادة عدد الخدمات. تمكّن شبكة الخدمة التواصل المُدار والمُراقب والآمن بين الخدمات الفردية. تعمل مع بروتوكول اكتشاف الخدمات لاكتشاف الخدمات. [Istio](https://istio.io/latest/about/service-mesh) و [envoy](https://www.envoyproxy.io) هما بعض من تقنيات شبكة الخدمة الأكثر استخدامًا.

## أمثلة

إليك بعض أدوات بنية اكتشاف الخدمات المستخدمة بشكل شائع:

- [etcd](https://etcd.io)
- [Consul](https://www.consul.io)
- [Apache Thrift](https://thrift.apache.org)
- [Apache Zookeeper](https://zookeeper.apache.org)

# SLA، SLO، SLI

لنناقش بإيجاز SLA و SLO و SLI. هذه المصطلحات مرتبطة بشكل أساسي بجانب الأعمال وموثوقية الموقع ولكنها مهمة للمعرفة على الرغم من ذلك.

## لماذا هي مهمة؟

تتيح SLAs و SLOs و SLIs للشركات تحديد وتتبع ومراقبة الوعود التي تُقدمها لخدمتها للمستخدمين. يجب أن تساعد معًا SLAs و SLOs و SLIs الفِرق على تعزيز الثقة لدى المستخدمين في خدماتهم مع التركيز على تحسين استجابة وإدارة الحوادث بشكل مستمر.

## SLA

SLA أو اتفاقية مستوى الخدمة هو اتفاق يتم بين شركة ومستخدمي خدمة معينة. تحدد SLA الوعود المختلفة التي تقدمها الشركة للمستخدمين بخصوص مقاييس محددة، مثل توفر الخدمة.

_غالبًا ما تُكتب SLAs من قِبل فِرق الأعمال أو الفرق القانونية للشركة._

## SLO

SLO أو هدف مستوى الخدمة هو الوعد الذي تقدمه الشركة للمستخدمين بشأن مقياس محدد مثل استجابة الحوادث أو وقت التشغيل. تتواجد SLOs ضمن SLA كوعود فردية موجودة ضمن اتفاقية المستخدم الكاملة. يُعد SLO الهدف المحدد الذي يجب أن تحققه الخدمة للامتثال لـ SLA. يجب أن تكون SLOs دائمًا بسيطة ومحددة بوضوح، ويسهل قياسها لتحديد ما إذا تم تحقيق الهدف أم لا.

## SLI

SLI أو مؤشر مستوى الخدمة هو مقياس رئيسي يُستخدم لتحديد ما إذا تم تحقيق SLO أم لا. إنه القيمة المقاسة للمقياس الموصوف ضمن SLO. من أجل الامتثال لـ SLA، يجب أن تستوفي قيمة SLI دائمًا قيمة SLO أو تزيدها.

# استعادة الكوارث

استعادة الكوارث (DR) هو عملية استعادة الوصول والوظائف للبنية التحتية بعد حدوث أحداث مثل الكوارث الطبيعية أو الهجمات السيبرانية أو حتى انقطاعات الأعمال.

تعتمد استعادة الكوارث على تكرار البيانات ومعالجة الكمبيوتر في موقع بعيد غير متأثر بالكارثة. عندما تتعطل الخوادم بسبب كارثة، يحتاج العمل إلى استعادة البيانات المفقودة من موقع ثاني حيث تم نسخ البيانات. في الواقع، يمكن للمؤسسة نقل معالجتها الكمبيوترية إلى ذلك الموقع البعيد أيضًا من أجل متابعة العمليات.

_غالبًا ما لا يتم مناقشة استعادة الكوارث بنشاط خلال مقابلات تصميم النظم، ولكن من المهم أن يكون لديك بعض الفهم الأساسي حول هذا الموضوع. يمكنك معرفة المزيد عن استعادة الكوارث من [إطار الهندسة المعمارية الجيدة لأمازون ويب سيرفس](https://docs.aws.amazon.com/wellarchitected/latest/reliability-pillar/plan-for-disaster-recovery-dr.html)._

## لماذا تعتبر استعادة الكوارث مهمة؟

استعادة الكوارث يمكن أن تحقق الفوائد التالية:

- تقليل انقطاع الخدمة والتوقف
- تقييد الأضرار
- استعادة سريعة
- تحسين الاحتفاظ بالعملاء

## المصطلحات

لنناقش بعض المصطلحات الهامة المتعلقة بأهمية استعادة الكوارث:

![استعادة-الكوارث](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-IV/disaster-recovery/disaster-recovery.png)

### RTO

الهدف الزمني للاستعادة (RTO) هو أقصى تأخير مقبول بين انقطاع الخدمة واستعادة الخدمة. هذا يحدد ما هو مقبول كنافذة زمنية عندما تكون الخدمة غير متاحة.

### RPO

الهدف الزمني لنقطة الاستعادة (RPO) هو أقصى مدة زمنية مقبولة منذ آخر نقطة استعادة للبيانات. يحدد هذا ما هو مقبول كفقدان للبيانات بين آخر نقطة استعادة وانقطاع الخدمة.

## استراتيجيات

يمكن أن تكون مجموعة متنوعة من استراتيجيات استعادة الكوارث (DR) جزءًا من خطة استعادة الكوارث.

### النسخ الاحتياطي

هذا هو نوع استعادة الكوارث الأبسط ويتضمن تخزين البيانات في موقع بعيد أو على وسائط قابلة للإزالة.

### الموقع البارد

في هذا النوع من استعادة الكوارث، تقوم المؤسسة بإعداد بنية أساسية أساسية في موقع ثانٍ.

### الموقع الساخن

يحتفظ الموقع الساخن بنسخ محدثة من البيانات في جميع الأوقات. يستغرق إعداد المواقع الساخنة وقتًا طويلاً ويكون أكثر تكلفة من المواقع الباردة، ولكنها تقلل بشكل كبير من الوقت التوقف.

# الآلات الافتراضية (VMs) والحاويات

قبل أن نناقش الافتراض الافتراضي مقابل الحاويات، دعونا نتعرف على مفهوم الآلات الافتراضية (VMs) والحاويات.

## الآلات الافتراضية (VM)

الآلة الافتراضية (VM) هي بيئة افتراضية تعمل كنظام كمبيوتر افتراضي بمعالجها المركزي الخاص، وذاكرتها، وواجهة الشبكة، والتخزين، والتي تُنشأ على نظام الأجهزة الفعلي. برنامج يُسمى المضيف يفصل موارد الجهاز عن الأجهزة ويخصصها بشكل مناسب حتى يمكن استخدامها من قبل الآلة الافتراضية.

الآلات الافتراضية معزولة عن بقية النظام، ويمكن أن تكون هناك عدة آلات افتراضية على قطعة واحدة من الأجهزة، مثل خادم. يمكن نقلها بين خوادم المضيف حسب الطلب أو لاستخدام الموارد بكفاءة أكبر.

### ما هو المضيف؟

المضيف، المعروف أحيانًا بمراقب الآلات الافتراضية (VMM)، يعزل نظام التشغيل والموارد عن الآلات الافتراضية ويمكن من إنشاء وإدارة تلك الآلات الافتراضية. يعامل المضيف الموارد مثل وحدات المعالجة المركزية والذاكرة والتخزين كمجموعة من الموارد يمكن إعادة تخصيصها بسهولة بين الضيوف الحاليين أو الآلات الافتراضية الجديدة.

### لماذا استخدام آلة افتراضية؟

الدمج الخادم هو سبب رئيسي لاستخدام الآلات الافتراضية. معظم نظم التشغيل ونشر التطبيقات تستخدم فقط كمية صغيرة من الموارد الفعلية المتاحة. من خلال افتراض الخوادم لدينا، يمكننا وضع العديد من الخوادم الافتراضية على كل خادم فعلي لتحسين استخدام الأجهزة. وهذا يمنعنا من الحاجة إلى شراء موارد فعلية إضافية.

توفر آلة افتراضية بيئة معزولة عن بقية النظام، لذلك مهما كان يتم تشغيله داخل الآلة الافتراضية لن يتداخل مع أي شيء آخر يتم تشغيله على الأجهزة المضيفة. بسبب العزلة التي توفرها الآلات الافتراضية، فهي خيار جيد لاختبار التطبيقات الجديدة أو إعداد بيئة إنتاج. يمكننا أيضًا تشغيل آلة افتراضية تقوم بدعم حالة استخدام محددة.

## الحاويات

الحاوية هي وحدة قياسية للبرمجيات تقوم بتعبئة الشيفرة وجميع تبعياتها مثل الإصدارات المحددة للتشغيل والمكتبات بحيث يمكن تشغيل التطبيق بسرعة

 وبشكل موثوق في بيئة حوسبة أخرى. تقدم الحاويات آلية تعبئة منطقية حيث يمكن تجريد التطبيقات من البيئة التي تعمل فيها فعليًا. تتيح هذه الإزالة الحاوياتية للتطبيقات التي تعتمد على الحاويات أن تُنشأ وتُنفذ بسهولة وباستمرار، بغض النظر عن البيئة المستهدفة.

### لماذا نحتاج إلى الحاويات؟

لنناقش بعض المزايا التي تقدمها الحاويات:

**فصل المسؤوليات**

توفر الحاويات فصلًا واضحًا للمسؤوليات، حيث يُركز المطورون على منطق التطبيق والتبعيات، بينما يمكن لفرق العمليات التركيز على عمليات النشر والإدارة.

**قابلية نقل الأعباء**

يمكن أن تعمل الحاويات في أي مكان تقريبًا، مما يسهل كثيرًا عملية التطوير والنشر.

**عزل التطبيقات**

تقوم الحاويات بتقنين موارد وحدة المعالجة المركزية والذاكرة والتخزين والشبكة على مستوى نظام التشغيل، مما يوفر للمطورين نظرة للنظام التشغيل معزولة من التطبيقات الأخرى.

**التطوير السريع**

تتيح الحاويات للمطورين الانتقال بسرعة أكبر من خلال تجنب القلق بشأن التبعيات والبيئات.

**عمليات فعالة**

الحاويات خفيفة الوزن وتتيح لنا استخدام الموارد الحاسوبية التي نحتاجها فقط.

## الافتراض الافتراضي مقابل الحاويات

![الافتراض الافتراضي مقابل الحاويات](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-IV/virtual-machines-and-containers/virtualization-vs-containerization.png)

في الافتراض التقليدي، يقوم المضيف بتقنين الأجهزة الفعلية. النتيجة هي أن كل آلة افتراضية تحتوي على نظام التشغيل المضيف، ونسخة افتراضية من الأجهزة التي يحتاج النظام إلى تشغيلها، وتطبيق ومكتبته والتبعيات المرتبطة به.

بدلاً من تقنين الأجهزة الأساسية، تقوم الحاويات بتقنين نظام التشغيل بحيث تحتوي كل حاوية فقط على التطبيق وتبعياته، مما يجعلها أخف وزنًا بكثير من الآلات الافتراضية. تشترك الحاويات أيضًا في نواة النظام التشغيل وتستخدم جزءًا من الذاكرة التي تحتاجها الآلات الافتراضية.

# OAuth 2.0 وOpenID Connect (OIDC)

## OAuth 2.0

OAuth 2.0، والذي يعني الترخيص المفتوح، هو معيار مصمم لتوفير وصول موافق عليه إلى الموارد نيابةً عن المستخدم، دون مشاركة أوراق اعتماد المستخدم. OAuth 2.0 هو بروتوكول ترخيص وليس بروتوكول مصادقة، وهو مصمم بشكل أساسي كوسيلة لمنح الوصول إلى مجموعة من الموارد، على سبيل المثال، واجهات برمجة تطبيقات عن بُعد أو بيانات المستخدمين.

### المفاهيم

يُعرِّف بروتوكول OAuth 2.0 الكيانات التالية:

- **مالك الموارد**: المستخدم أو النظام الذي يمتلك الموارد المحمية ويمكنه منح الوصول إليها.
- **العميل**: العميل هو النظام الذي يحتاج إلى الوصول إلى الموارد المحمية.
- **خادم التفويض**: هذا الخادم يتلقى طلبات من العميل للحصول على رموز الوصول ويصدرها بنجاح بعد المصادقة والموافقة من قِبل مالك الموارد.
- **خادم الموارد**: خادم يحمي موارد المستخدم ويستقبل طلبات الوصول من العميل. يقبل ويحقق رمز الوصول من العميل ويعيد الموارد المناسبة.
- **النطاقات**: تُستخدم لتحديد سبب منح الوصول إلى الموارد بدقة. القيم المقبولة للنطاقات، والموارد التي تتعلق بها، تعتمد على خادم الموارد.
- **رمز الوصول**: قطعة من البيانات تُمثِّل التفويض للوصول إلى الموارد نيابةً عن المستخدم النهائي.

### كيف يعمل OAuth 2.0؟

لنتعرف على كيفية عمل OAuth 2.0:

![oauth2](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-IV/oauth2-and-openid-connect/oauth2.png)

1. العميل يُطلب المصادقة من خادم التفويض، ويقدم معرّف العميل وسره كمعرّف. يقدم أيضًا النطاقات وعنوان URI لإرسال رمز الوصول أو رمز المصادقة.
2. خادم التفويض يُصادق العميل ويتحقق من أن النطاقات المطلوبة مسموح بها.
3. مالك الموارد يتفاعل مع خادم التفويض لمنح الوصول.
4. يُعاد خادم التفويض العودة إلى العميل مع رمز المصادقة أو رمز الوصول، اعتمادًا على نوع المنحة. يمكن أن يُرجع أيضًا رمز التجديد.
5. باستخدام رمز الوصول، يمكن للعميل طلب الوصول إلى المورد من خادم الموارد.

### العيوب

إليك أشهر العيوب

 المشتركة لـ OAuth 2.0:

- يفتقر إلى ميزات أمان مدمجة.
- لا توجد تنفيذات قياسية.
- لا يوجد مجموعة مشتركة من النطاقات.

## OpenID Connect

تم تصميم OAuth 2.0 فقط للـ "الترخيص"، لمنح الوصول إلى البيانات والميزات من تطبيق إلى آخر. OpenID Connect (OIDC) هو طبقة رفيعة تستند إلى OAuth 2.0 تضيف معلومات تسجيل الدخول والملف الشخصي حول الشخص المسجل دخوله.

عندما يدعم خادم التفويض OIDC، يُطلق عليه أحيانًا موفر الهوية (IdP)، حيث يوفر معلومات حول مالك الموارد إلى العميل. OpenID Connect نسبيًا جديد، مما يؤدي إلى تبني أقل وتنفيذ أفضل الممارسات في الصناعة مقارنةً بـ OAuth.

### المفاهيم

يُعرِّف بروتوكول OpenID Connect (OIDC) الكيانات التالية:

- **الجهة المعتمدة**: التطبيق الحالي.
- **مزود OpenID**: هذا هو أساسًا خدمة وسيط تقدم رمزًا مرة واحدة للجهة المعتمدة.
- **نقطة الرمز**: خادم ويب يقبل رمز مرة واحدة (OTC) ويوفر رمز وصول صالح لمدة ساعة. الفرق الرئيسي بين OIDC و OAuth 2.0 هو أن الرمز يتم توفيره باستخدام رمز الويب الممتد JSON (JWT).
- **نقطة معلومات المستخدم**: تتفاعل الجهة المعتمدة مع هذه النقطة، وتوفر رمزًا آمنًا وتتلقى معلومات عن المستخدم النهائي.

كل من OAuth 2.0 و OIDC سهل التنفيذ وقائم على JSON، والذي يدعمه معظم تطبيقات الويب والجوّال. ومع ذلك، مواصفات OpenID Connect (OIDC) أكثر صرامة من مواصفات OAuth الأساسية.

# تسجيل الدخول الموحّد (SSO)

تسجيل الدخول الموحّد (SSO) هو عملية مصادقة تُمكِّن المستخدم من الوصول إلى تطبيقات أو مواقع متعددة باستخدام مجموعة واحدة من بيانات تسجيل الدخول فقط. وهذا يمنع الحاجة لتسجيل الدخول بشكل منفصل إلى التطبيقات المختلفة.

بيانات مصادقة المستخدم ومعلومات التعرّف الأخرى يتم تخزينها وإدارتها من قبل نظام مركزي يُسمى مُوفر الهوية (IdP). مُوفر الهوية هو نظام موثوق يوفر وصولًا إلى مواقع وتطبيقات أخرى.

يُستخدَم نظام المصادقة القائم على تسجيل الدخول الموحّد (SSO) بشكل شائع في بيئات المؤسسات حيث يحتاج الموظفون إلى الوصول إلى تطبيقات متعددة تابعة لهم.

## المكونات

لنناقش بعض المكونات الرئيسية لتسجيل الدخول الموحّد (SSO).

### مُوفِّر الهوية (IdP)

معلومات هوية المستخدم تُخزَّن وتُدار من قبل نظام مركزي يُسمى مُوفر الهوية (IdP). يقوم مُوفِّر الهوية بمصادقة المستخدم ويوفِّر وصولًا إلى موفِّر الخدمة.

مُوفر الهوية يمكنه مصادقة المستخدم مباشرةً عن طريق التحقق من اسم المستخدم وكلمة المرور أو عن طريق التحقق من بيان مُظهر حول هوية المستخدم كما يُقدِّمه مُوفِّر هوية منفصل. مُوفِّر الهوية يُدير إدارة هويات المستخدم لتحرير مزود الخدمة من هذه المسؤولية.

### مزود الخدمة

مُزود الخدمة يقدِّم خدمات للمستخدم النهائي. يعتمدون على مُوفِّري الهوية لتأكيد هوية المستخدم، وعادة ما يُدار بواسطة مُوفِّري الهوية بعض السمات المتعلقة بالمستخدم. يمكن أن يحتفظ مُزودي الخدمة أيضًا بحساب محلي للمستخدم بالإضافة إلى سمات فريدة لخدمتهم.

### وسيط الهوية

وسيط الهوية يعمل كوسيط يربط مزودي خدمة متعددين بمزودي هوية مختلفين. باستخدام وسيط الهوية، يُمكِنُنا تنفيذ تسجيل الدخول الموحّد عبر أي تطبيق دون عناء البروتوكول الذي يتبعه.

## SAML

لغة ترميز تصريحات الأمان هي معيار مفتوح يسمح للعملاء بمشاركة معلومات الأمان حول الهوية والمصادقة والأذون عبر أنظمة مختلفة. يتم تنفيذ SAML باستخدام معيار لغة الترميز الموسّعة (XML) لمشاركة البيانات.

تمكن SAML على وجه الخصوص تكامل الهويات، مما يجعل من الممكن على مزودي الهوية (IdPs) تمرير هويات مصادقة وسماتها بشكل سلس وآمن إلى مقدمي الخدمة.

## كيف يعمل تسجيل الدخول الموحّد (SSO)؟

الآن، لنتناقش حول كيفية عمل تسجيل الدخول الموحّد:

![sso](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-IV/single-sign-on/sso.png)

1. يُطلب المستخدم موردًا من تطبيقه المرغوب.
2. يُعيد التطبيق المستخدم إلى مُوفِّر الهوية (IdP) للمصادقة.
3. يُسجل المستخدم دخوله باستخدام بيانات اعتماده (عاد

ة، اسم المستخدم وكلمة المرور).
4. يُرسِل مُوفِّر الهوية (IdP) رد تسجيل دخول موحّد إلى تطبيق العميل.
5. يُمنَح التطبيق الوصول للمستخدم.

## SAML مقابل OAuth 2.0 و OpenID Connect (OIDC)

هناك العديد من الاختلافات بين SAML و OAuth و OIDC. يستخدم SAML XML لتمرير الرسائل، بينما يستخدم OAuth و OIDC JSON. يوفر OAuth تجربة أبسط، بينما يُستهدَف SAML أمان المؤسسات.

يستخدم OAuth و OIDC التواصل القائم على REST بشكل واسع، ولهذا تعتبر التطبيقات المتنقلة وتطبيقات الويب الحديثة تجربة أفضل للمستخدم مع OAuth و OIDC. بالمقابل، يفرض SAML ملف تعريف جلسة في متصفح يتيح للمستخدم الوصول إلى صفحات ويب معينة. وهذا رائع لأعباء العمل المستمرة.

OIDC ودود للمطورين وأسهل في التنفيذ، مما يوسع حالات الاستخدام التي يمكن تنفيذها به. يمكن تنفيذه من الصفر بسرعة كبيرة، من خلال مكتبات متاحة مجانًا في جميع لغات البرمجة الشائعة. يمكن أن يكون SAML معقدًا لتثبيته وصيانته، والذي يمكن لشركات الحجم الكبير فقط التعامل معه جيدًا.

OpenID Connect عبارة عن أساس أعلى لإطار OAuth. لذلك، يمكن أن يقدم طبقة مدمجة من الإذن تُطلب من المستخدم الموافقة على الوصول إلى ما قد يصل إليه مقدم الخدمة. على الرغم من أن SAML قادر أيضًا على السماح بتدفق الموافقة، إلا أنه يتم ذلك عن طريق الترميز الصلب الذي يقوم به المطور وليس كجزء من بروتوكوله.

_كلا من بروتوكولات المصادقة هاتان جيدتان في مجالاتهما. كما هو الحال دائمًا، يعتمد الكثير على حالات الاستخدام الخاصة بنا وجمهور الهدف._

## المزايا

فيما يلي بعض فوائد استخدام تسجيل الدخول الموحّد:

- سهولة الاستخدام حيث يحتاج المستخدمون فقط إلى تذكر مجموعة واحدة من بيانات تسجيل الدخول.
- سهولة الوصول دون الحاجة للخضوع لعملية تفويض طويلة.
- تطبيق أمان وامتثال لحماية البيانات الحساسة.
- تبسيط الإدارة مع تقليل تكلفة دعم تكنولوجيا المعلومات ووقت الإدارة.

## العيوب

إليك بعض عيوب تسجيل الدخول الموحّد:

- عرضة لضعف كلمة المرور الوحيدة، إذا تم اختراق كلمة المرور الرئيسية لتسجيل الدخول الموحّد، ستتعرض جميع التطبيقات المدعومة للاختراق.
- عملية المصادقة باستخدام تسجيل الدخول الموحّد أبطأ من المصادقة التقليدية حيث يجب على كل تطبيق طلب تحقق من موفِّر الهوية للتحقق.

## أمثلة

إليك بعض مُوفري الهوية (IdP) الشائعين:

- [Okta](https://www.okta.com)
- [Google](https://cloud.google.com/architecture/identity/single-sign-on)
- [Auth0](https://auth0.com)
- [OneLogin](https://www.onelogin.com)

# SSL، TLS، mTLS

لنتناول بإيجاز بعض بروتوكولات الأمان الهامة للاتصال مثل SSL و TLS و mTLS. أقول أنه من وجهة نظر تصميم النظام من منظور الصورة الكبيرة، هذا الموضوع ليس مهمًا جدًا ولكن من الجيد معرفته.

## SSL

تعني SSL "Secure Sockets Layer" وهو بروتوكول لتشفير وتأمين الاتصالات التي تحدث على الإنترنت. تم تطويره لأول مرة في عام 1995 ولكنه تم التخلي عنه لصالح TLS (Transport Layer Security).

### لماذا يُسمى شهادة SSL إذا كان قد تم التخلي عنه؟

معظم مُزوّدي شهادات كبار لا يزالون يشيرّون إلى الشهادات بأنها شهادات SSL، وهذا هو السبب وراء استمرار تقديم التسمية.

### لماذا كان SSL مهمًا جدًا؟

في الأصل، كانت البيانات على الويب تُرسل على شكل نصوص واضحة يمكن لأي شخص قراءتها إذا تم التقاط الرسالة. تم إنشاء SSL لتصحيح هذه المشكلة وحماية خصوصية المستخدم. من خلال تشفير أي بيانات تنتقل بين المستخدم وخادم الويب، يمنع SSL أيضًا أنواعًا معينة من الهجمات السيبرانية من التلاعب بالبيانات أثناء النقل.

## TLS

تعني Transport Layer Security، أو TLS، وهو بروتوكول أمان معتمد على نطاق واسع مصمم لتحقيق الخصوصية وأمان البيانات للاتصالات عبر الإنترنت. تطور TLS من بروتوكول تشفير سابق يُسمى Secure Sockets Layer (SSL). حالة الاستخدام الأساسية لبروتوكول TLS هي تشفير الاتصال بين تطبيقات الويب والخوادم.

يتألف بروتوكول TLS من ثلاثة مكونات رئيسية:

- **التشفير**: يخفي البيانات التي تُرسل من أطراف ثالثة.
- **المصادقة**: يضمن أن الأطراف التي تبادل المعلومات هي نفسها التي تدّعي أنها عليها.
- **النزاهة**: يتحقق من أن البيانات لم تتم تزويرها أو تعديلها.

## mTLS

المصادقة المتبادلة للتشفير أو mTLS هي طريقة للمصادقة المتبادلة. يضمن mTLS أن الأطراف على كل طرف من الاتصال الشبكي هما نفسهما الذين يدّعون أنهما عليهما بالتحقق من أن لديهما المفتاح الخاص الصحيح. تقدم المعلومات في شهادات TLS الخاصة بهما التحقق الإضافي.

### لماذا استخدام mTLS؟

يساعد mTLS في التأكد من أمان وثقة حركة المرور في كلا الاتجاهين بين العميل والخادم. وهذا يوفر طبقة إضافية من الأمان للمستخدمين الذين يقومون بتسجيل الدخول إلى شبكة المنظمة أو التطبيقات. كما أنه يتحقق من الاتصالات مع أجهزة العملاء التي لا تتبع عملية تسجيل الدخول، مثل أجهزة الإنترنت من الأشياء (IoT).

في الوقت الحاضر، يُستخدم mTLS بشكل شائع من قِبل خدمات المايكروسيرفس أو الأنظمة الموزعة في [نموذج أمان

 الثقة الصفرية](https://en.wikipedia.org/wiki/Zero_trust_security_model) للتحقق من بعضها البعض.

# مقابلات تصميم الأنظمة

تصميم النظام هو موضوع شامل جدًا، ومقابلات تصميم النظم مصممة لتقييم قدرتك على تقديم حلول تقنية لمشاكل مجردة. لذلك، فإنها ليست مصممة للحصول على إجابة محددة. الجانب الفريد في مقابلات تصميم النظم هو الطبيعة ذات الاتجاه المزدوج بين المرشح والمقابل.

تتغير التوقعات بشكل كبير بين مستويات الهندسة المختلفة أيضًا. هذا لأن شخصًا لديه الكثير من الخبرة العملية سيقترب منها بشكل مختلف تمامًا عن شخص جديد في الصناعة. ونتيجة لذلك، من الصعب إيجاد استراتيجية واحدة ستساعدنا في البقاء منظمين خلال المقابلة.

لنلقي نظرة على بعض الاستراتيجيات المشتركة لمقابلات تصميم النظم:

## توضيح المتطلبات

أسئلة مقابلات تصميم النظم، بطبيعتها، غامضة أو مجردة. طرح أسئلة حول نطاق المشكلة بالضبط، وتوضيح المتطلبات الوظيفية في وقت مبكر من المقابلة أمر ضروري. عادةً، يتم تقسيم المتطلبات إلى ثلاثة أجزاء:

### المتطلبات الوظيفية

هذه هي المتطلبات التي يطلبها المستخدم النهائي باعتبارها وظائف أساسية يجب أن يقدمها النظام. يجب دمج جميع هذه الوظائف ضمن النظام كجزء من العقد.

مثال:

- "ما هي الميزات التي نحتاج لتصميمها لهذا النظام؟"
- "ما هي الحالات الحدية التي يجب أن نأخذها في اعتبارنا في تصميمنا؟"

### المتطلبات غير الوظيفية

هذه هي القيود النوعية التي يجب أن يستوفيها النظام وفقًا لعقد المشروع. يختلف الأولوية أو الدرجة التي يتم تنفيذ هذه العوامل من مشروع إلى آخر. تُعرف أيضًا باسم المتطلبات غير السلوكية. على سبيل المثال، القابلية للنقل، وسهولة الصيانة، والموثوقية، والتوسعة، والأمان، إلخ.

مثال:

- "يجب معالجة كل طلب بأدنى وقت استجابة"
- "يجب أن يكون النظام متاحًا بشكل كبير"

### المتطلبات الموسعة

هذه هي أساسًا المتطلبات "الجيدة أن تكون متوفرة" التي قد تكون خارج نطاق النظام.

مثال:

- "يجب أن يسجل نظامنا المقاييس والتحليلات"
- "مراقبة أداء وصحة الخدمة؟"

## التقدير والقيود

قم بتقدير مقياس النظام الذي سنقوم بتصميمه. من المهم طرح أسئلة مثل:

- "ما هو المقياس المطلوب الذي يجب أن يتعامل معه هذا النظام؟"
- "ما هو نسبة القراءة/الكتابة في نظامنا؟"
- "كم عدد الطلبات في الثانية؟"
- "ما هو حجم التخزين المطلوب؟"

ستساعدنا هذه الأسئلة في تحديد تصميمنا لاحقًا.

## تصميم نموذج البيانات

بمجرد أن يكون لدينا التقديرات، يمكننا البدء في تحديد مخطط قاعدة البيانات. يساعدنا القيام بذلك في المراحل الأولى من المقابلة في فهم تدفق البيانات الذي يعد جوهر كل نظام. في هذه الخطوة، نقوم ببساطة بتعريف جميع الكيانات والعلاقات بين

ها.

- "ما هي الكيانات المختلفة في النظام؟"
- "ما هي العلاقات بين هذه الكيانات؟"
- "كم جداول نحتاج؟"
- "هل NoSQL خيار أفضل هنا؟"

## تصميم واجهة البرمجة (API)

بعد ذلك، يمكننا البدء في تصميم واجهات البرمجة للنظام. هذه الواجهات ستساعدنا في تحديد التوقعات من النظام بشكل صريح. لا يجب علينا كتابة أي كود، فقط واجهة بسيطة تحدد متطلبات الواجهة مثل المعلمات، والدوال، والفئات، والأنواع، والكيانات، وما إلى ذلك.

على سبيل المثال:

```tsx
createUser(name: string, email: string): User
```

من المستحسن أن نبقي واجهة البرمجة بسيطة قدر الإمكان ونعود إليها لاحقًا عند التطرق إلى المتطلبات الموسعة.

## تصميم المكونات على المستوى العالي

الآن بعد أن أنشأنا نموذج البيانات وتصميم واجهة البرمجة، حان وقت تحديد المكونات (مثل توازن الحمل، وبوابة واجهة البرمجة، وما إلى ذلك) التي تحتاج إلى حل مشكلتنا ورسم التصميم الأولي لنظامنا.

- "هل تصميم هندسة تطبيقات متعددة الطبقات (Monolithic) أم معمارية الميكروسيرفيس (Microservices) هو الأفضل؟"
- "ما هو نوع قاعدة البيانات الذي يجب أن نستخدمه؟"

بمجرد وجود رسم تخطيطي أساسي، يمكننا بدء النقاش مع المقابل حول كيفية عمل النظام من منظور العميل.

## التصميم التفصيلي

الآن حان وقت الدخول في التفاصيل حول المكونات الرئيسية للنظام الذي قمنا بتصميمه. كما هو دائمًا، مناقشة مع المقابل حول أي مكون قد يحتاج لتحسينات إضافية.

هذه فرصة جيدة لإظهار خبرتك في مجالات خبرتك. قدم أساليب مختلفة ومزايا وعيوبها. شرح قرارات التصميم الخاصة بك واستنادها إلى أمثلة. هذه أيضًا فرصة جيدة لمناقشة أي ميزات إضافية قد يمكن أن يدعمها النظام، ولكن هذا اختياري.

- "كيف يجب أن نقسم بياناتنا؟"
- "ماذا عن توزيع الأحمال؟"
- "هل يجب أن نستخدم الذاكرة المؤقتة (Cache)؟"
- "كيف سنتعامل مع زيادة مفاجئة في حركة المرور؟"

أيضًا، حاول ألا تكون متعصبًا للغاية حيال تقنيات معينة. تصريحات مثل "أعتقد أن قواعد البيانات NoSQL هي الأفضل، قواعد البيانات SQL ليست قابلة للتوسعة" تعكس ضعفًا. بصفتي شخصًا قمت بمقابلة الكثير من الأشخاص على مر السنين، يمكنني أن أقول أنه يجب أن تكون متواضعًا حول ما تعرفه وما لا تعرفه. استخدم معرفتك الحالية مع أمثلة للتنقل في هذا الجزء من المقابلة.

## تحديد وحل مشاكل الاختناقات

أخيرًا، حان وقت مناقشة مشاكل الاختناق والأساليب للتخفيف منها. إليك بعض الأس

ئلة المهمة لطرحها:

- "هل لدينا ما يكفي من نسخ قواعد البيانات؟"
- "هل هناك نقطة فشل واحدة؟"
- "هل هناك حاجة لتجزئة قاعدة البيانات؟"
- "كيف يمكننا جعل نظامنا أكثر قوة؟"
- "كيف يمكن تحسين توفر ذاكرة التخزين المؤقت؟"

تأكد من قراءة مدونة الهندسة في الشركة التي تقوم بمقابلتها. سيساعدك ذلك في الحصول على فهم للتكنولوجيا التي يستخدمونها والمشاكل التي تعد مهمة بالنسبة لهم.

تصميم مُختصر الروابط

دعونا نصمم خدمة مختصر الروابط، مشابهة لخدمات مثل [Bitly](https://bitly.com)، و [TinyURL](https://tinyurl.com/app).

## ما هو مختصر الروابط؟

خدمة مختصر الروابط تقوم بإنشاء اختصار أو رابط مختصر لرابط طويل. يتم توجيه المستخدمين إلى الرابط الأصلي عند زيارتهم لهذه الروابط المختصرة.

على سبيل المثال، يمكن تغيير الرابط الطويل التالي إلى رابط أقصر.

**الرابط الطويل**: [https://karanpratapsingh.com/courses/system-design/url-shortener](https://karanpratapsingh.com/courses/system-design/url-shortener)

**الرابط المختصر**: [https://bit.ly/3I71d3o](https://bit.ly/3I71d3o)

## لماذا نحتاج إلى مختصر الروابط؟

يوفر مختصر الروابط مساحة عمومًا عند مشاركة الروابط. المستخدمون أيضًا أقل احتمالًا لارتكاب أخطاء في كتابة الروابط الأقصر. علاوة على ذلك، يمكننا أيضًا تحسين الروابط عبر الأجهزة، وهذا يسمح لنا بتتبع الروابط الفردية.

## المتطلبات

يجب أن تلبي نظام مختصر الروابط الخاص بنا المتطلبات التالية:

### المتطلبات الوظيفية

- عندما يتم تزويدنا برابط، يجب أن تُنشئ خدمتنا اختصارًا _أقصر وفريد_ له.
- يجب توجيه المستخدمين إلى الرابط الأصلي عندما يزورون الرابط القصير.
- يجب أن تنتهي صلاحية الروابط بعد مدة زمنية افتراضية.

### المتطلبات غير الوظيفية

- توفير عالية بأدنى تأخير.
- يجب أن يكون النظام قابلًا للتوسعة وفعّالًا.

### المتطلبات الموسعة

- منع سوء استخدام الخدمة.
- تسجيل تحليلات وبيانات مقاييس لعمليات التوجيه.

## التقديرات والقيود

لنبدأ بالتقديرات والقيود.

_ملحوظة: تأكد من التحقق من أي افتراضات تتعلق بالحجم أو حركة المرور مع المقابل._

### حركة المرور

سيكون هذا نظامًا قائمًا على القراءة بشكل رئيسي، لنفترض نسبة قراءة / كتابة `100:1` مع إنشاء 100 مليون رابط شهريًا.

**قراءة / كتابة شهريًا**

بالنسبة لعمليات ال

قراءة شهريًا:

$$
100 \times 100 \space مليون = 10 \space مليار / شهر
$$

بالمثل لعمليات الكتابة:

$$
1 \times 100 \space مليون = 100 \space مليون / شهر
$$

**ما ستكون عدد الطلبات في الثانية (RPS) لنظامنا؟**

100 مليون طلب في الشهر يترجم إلى 40 طلبًا في الثانية.

$$
\frac{100 \space مليون}{(30 \space يوم \times 24 \space ساعة \times 3600 \space ثانية)} = \sim 40 \space طلبًا في الثانية
$$

وبنسبة قراءة / كتابة `100:1`، سيكون عدد عمليات التوجيه:

$$
100 \times 40 \space طلبًا في الثانية = 4000 \space طلبًا في الثانية
$$

### العرض الترددي

نظرًا لتوقعنا حوالي 40 رابطًا في الثانية، وإذا فرضنا أن كل طلب حجمه 500 بايت، سيكون إجمالي البيانات الواردة للطلبات كتابةً:

$$
40 \times 500 \space بايت = 20 \space كيلو بايت / ثانية
$$

بالمثل، بالنسبة للطلبات التوجيه، نظرًا لتوقعنا حوالي 4 آلاف توجيه، ستكون البيانات الصادرة الإجمالية:

$$
4000 \space رابط / ثانية \times 500 \space بايت = \sim 2 \space ميغابايت / ثانية
$$

### التخزين

بالنسبة للتخزين، سنفترض أننا سنخزن كل رابط أو سجل في قاعدة البيانات لمدة 10 سنوات. نظرًا لتوقعنا حوالي 100 مليون طلب جديد شهريًا، سيكون إجمالي عدد السجلات التي سنحتاج إلى تخزينها:

$$
100 \space مليون \times 10 \space سنوات \times 12 \space شهرًا = 12 \space مليار
$$

مثلما كان في السابق، إذا فرضنا أن كل سجل مخزن سيكون حوالي 500 بايت. سنحتاج إلى حوالي 6 تيرابايت من التخزين:

$$
12 \space مليار \times 500 \space بايت = 6 \space تيرابايت
$$

### التخزين المؤقت

بالنسبة للتخزين المؤقت، سنتبع مبدأ باريتو الكلاسيكي المعروف أيضًا باسم قاعدة 80/20. وهذا يعني أن 80% من الطلبات تتعلق بـ 20% من البيانات، لذا يمكننا تخزين حوالي 20% من الطلبات.

نظرًا لتوقعنا حوالي 4 آلاف طلب قراءة أو توجيه كل ثانية، يترجم ذلك إلى حوالي 350 مليون طلب يوميًا.

$$
4000 \space رابط / ثانية \times 24 \space ساعة \times 3600 \space ثانية = \sim 350 \space مليون \space طلب / يوم
$$

لذلك، سنحتاج إلى حوالي 35 غيغابايت من الذاكرة يوميًا.

$$
20 \space في المئة \times 350 \space مليون \times 500 \space بايت = 35 \space غيغابايت / يوم
$$

### تقدير عام

إليكم تقديرنا العام:

| النوع                 | التقدير   |
| -------------------- | ---------- |
| عمليات الكتابة (روابط جديدة)    | 40/ثانية       |
| عمليات القراءة (توجيه)  | 4K/ثانية       |
| العرض الترددي (الوارد) | 20 كيلو بايت/ثانية    |
| العرض الترددي (الصادر) | 2 ميغابايت/ثانية     |
| التخزين (10 سنوات)   | 6 تيرابايت       |
| الذاكرة (تخزين مؤقت)

     | ~35 غيغابايت/يوم |

## تصميم نموذج البيانات

في الخطوة التالية، سنركز على تصميم نموذج البيانات. هذه هي مخططات قاعدة البيانات لدينا:

![url-shortener-datamodel](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-V/url-shortener/url-shortener-datamodel.png)

في البداية، يمكننا أن نبدأ بجدولين فقط:

**users**

يخزن تفاصيل المستخدم مثل `الاسم`، `البريد الإلكتروني`، `createdAt`، وما إلى ذلك.

**urls**

يحتوي على خصائص الروابط القصيرة الجديدة مثل `انتهاء الصلاحية`، `الهاش`، `originalURL`، و `معرف المستخدم` الذي أنشأ الرابط القصير. يمكننا أيضًا استخدام عمود `الهاش` كـ [فهرس](https://karanpratapsingh.com/courses/system-design/indexes) لتحسين أداء الاستعلام.

### ما نوع قاعدة البيانات يجب أن نستخدمه؟

نظرًا لعدم قوة العلاقة بين البيانات، قواعد البيانات غير العلائقية مثل [Amazon DynamoDB](https://aws.amazon.com/dynamodb)، [Apache Cassandra](https://cassandra.apache.org/_/index.html)، أو [MongoDB](https://www.mongodb.com) سيكونون خيارًا أفضل هنا، وإذا قررنا استخدام قاعدة بيانات SQL، فيمكننا استخدام شيء مثل [Azure SQL Database](https://azure.microsoft.com/en-in/products/azure-sql/database) أو [Amazon RDS](https://aws.amazon.com/rds).

_لمزيد من التفاصيل، راجع [SQL مقابل NoSQL](https://karanpratapsingh.com/courses/system-design/sql-vs-nosql-databases)._

## تصميم واجهة البرمجة التطبيقية (API)

لنقم بتصميم واجهة برمجة التطبيقية الأساسية لخدماتنا:

### إنشاء رابط قصير

يجب أن تقوم هذه الواجهة بإنشاء رابط قصير جديد في نظامنا باستخدام عنوان URL الأصلي المعطى.

```tsx
createURL(apiKey: string, originalURL: string, expiration?: Date): string
```

**المعاملات**

مفتاح API (`string`): المفتاح المقدم من قبل المستخدم.

عنوان URL الأصلي (`string`): العنوان URL الأصلي ليتم اختصاره.

انتهاء الصلاحية (`Date`): تاريخ انتهاء الصلاحية للعنوان URL الجديد _(اختياري)_.

**العائدات**

رابط قصير (`string`): رابط مقتصر جديد.

### الحصول على الرابط

يجب أن تسترد هذه الواجهة العنوان URL الأصلي من رابط قصير معين.

```tsx
getURL(apiKey: string, shortURL: string): string
```

**المعاملات**

مفتاح API (`string`): المفتاح المقدم من قبل المستخدم.

رابط قصير (`string`): الرابط المقتصر المتعلق بالعنوان URL الأصلي.

**العائدات**

عنوان URL الأصلي (`string`): العنوان URL الأصلي الذي يجب استرداده.

### حذف الرابط

يجب أن تقوم هذه الواجهة بحذف الرابط المقتصر المعطى من نظامنا.

```tsx
deleteURL(apiKey: string, shortURL: string): boolean
```

**المعاملات**

مفتاح API (`string`): المفتاح المقدم من قبل المستخدم.

رابط قصير (`string`): الرابط المقتصر الذي سيتم حذفه.

**العائدات**

نتيجة (`boolean`): تمثل ما إذا كانت العملية ناجحة أم لا.

### لماذا نحتاج إلى مفتاح API؟

كما لاحظت، نحن نستخدم مفتاح API لمنع سوء استخدام خدماتنا. باستخدام هذا المفتاح، يمكننا تقييد المستخدمين إلى عدد معين من الطلبات في الثانية أو الدقيقة. هذه ممارسة قياسية جدًا لواجهات برمجة التطبيق للمطورين ويجب أن تغطي متطلباتنا الموسعة.

## تصميم مرتفع المستوى

الآن دعونا نقوم بتصميم مرتفع المستوى لنظام

نا.

### ترميز العناوين URL

هدف نظامنا الرئيسي هو اختصار عنوان URL المعطى، دعونا نلقي نظرة على الطرق المختلفة:

**الطريقة الأساسية 62**

في هذا النهج، يمكننا ترميز العنوان URL الأصلي باستخدام [الأساس 62](https://en.wikipedia.org/wiki/Base62) والذي يتألف من الحروف الكبيرة من A إلى Z، والحروف الصغيرة من a إلى z، والأرقام من 0 إلى 9.

$$
عدد \space الروابط = 62^N
$$

حيث:

`N`: عدد الأحرف في العنوان URL المولد.

لذا، إذا أردنا إنشاء رابطًا طوله 7 أحرف، فسنقوم بإنشاء ~3.5 تريليون روابط مختلفة.

$$
\begin{gather*}
62^5 = \sim 916 \space مليون \space رابط \\
62^6 = \sim 56.8 \space تريليون \space رابط \\
62^7 = \sim 3.5 \space تريليون \space رابط
\end{gather*}
$$

هذا هو أبسط حلاً هنا، ولكنه لا يضمن مفاتيح غير مكررة أو مقاومة للاصطدام.

**الطريقة MD5**

خوارزمية التجزئة MD5 هي خوارزمية تجزئة رسالة تستخدم على نطاق واسع تنتج قيمة تجزئة بطول 128 بت (أو 32 رقمًا عشريًا سداسيًا عشريًا). يمكننا استخدام هذه الأرقام السداسية عشرية الـ 32 لإنشاء رابط بطول 7 أحرف.

$$
MD5(original\_url) \rightarrow base62encode \rightarrow hash
$$

ومع ذلك، هذا يخلق لنا مشكلة جديدة، وهي التكرار والتصادم. يمكننا محاولة إعادة حساب التجزئة حتى نجد واحدًا فريدًا ولكن ذلك سيزيد من تكاليف أنظمتنا. من الأفضل البحث عن طرق أكثر قابلية للتوسع.

**الطريقة العددية**

في هذا النهج، سنبدأ بخادم واحد يحتفظ بعدد المفاتيح التي تم إنشاؤها. بمجرد أن يتلقى خدمتنا طلبًا، يمكنها الوصول إلى العداد الذي يعيد رقمًا فريدًا ويزيد العداد. عندما يأتي الطلب التالي، يعيد العداد مرة أخرى الرقم الفريد وهذا يستمر.

$$
عداد(0-3.5 \space تريليون) \rightarrow base62encode \rightarrow hash
$$

المشكلة مع هذا النهج هي أنه يمكن أن يصبح بسرعة نقطة فردية للفشل. وإذا قمنا بتشغيل عدة مثيلات من العداد، يمكن أن يكون هناك تصادم حيث أنه في الأساس هو نظام موزع.

لحل هذه المشكلة يمكننا استخدام مدير نظام موزع مثل [Zookeeper](https://zookeeper.apache.org) الذي يمكنه توفير المزامنة الموزعة. يمكن لـ Zookeeper الحفاظ على مجموعات متعددة لخوادمنا.

$$
\begin{align*}
& مجموعة \space 1: \space 1 \rightarrow 1,000,000 \\
& مجموعة \space 2: \space 1,000,001 \rightarrow 2,000,000 \\
& مجموعة \space 3: \space 2,000,001 \rightarrow 3,000,000 \\
& ...
\end{align*}
$$

عندما يصل خادم ما إلى نطاقه الأقصى، سيقوم Zookeeper بتخصيص نطاق عداد غير مستخدم إلى الخادم الجديد. يمكن أن يضمن هذا النهج مفاتيح غير مكررة ومقاومة للاصطدام. كما يمكننا تشغيل مثيلات متعددة من Zookeeper لإزالة نقطة الفشل الفردية.

### خدمة توليد المفاتيح (KGS)

كما ناقشنا، توليد مفتاح فريد على نطاق واسع بدون تكرار وتصادم يمكن أن يكون ت

حديًا بعض الشيء. لحل هذه المشكلة، يمكننا إنشاء خدمة مستقلة لتوليد المفاتيح (KGS) التي تقوم بتوليد مفتاح فريد مسبقًا وتخزينه في قاعدة بيانات منفصلة للاستخدام لاحقًا. يمكن أن يجعل هذا النهج الأمور بسيطة بالنسبة لنا.

**كيفية التعامل مع الوصول المتزامن؟**

بمجرد استخدام المفتاح، يمكننا وضع علامة عليه في قاعدة البيانات للتأكد من أننا لا نعيد استخدامه، ومع ذلك، إذا كان هناك العديد من مثيلات الخادم تقوم بقراءة البيانات بتزامن، فقد يحاول خادمان أو أكثر استخدام نفس المفتاح.

أسهل طريقة لحل هذه المشكلة هي تخزين المفاتيح في جدولين. بمجرد استخدام المفتاح، ننقله إلى جدول منفصل مع قفل مناسب في مكانه. وأيضًا، لتحسين القراءات، يمكننا الاحتفاظ ببعض المفاتيح في الذاكرة.

**تقديرات قاعدة بيانات KGS**

كما هو مذكور في مناقشتنا، يمكننا توليد ما يصل إلى ~56.8 مليار مفتاح فريد طوله 6 أحرف مما سيؤدي إلى حاجتنا لتخزين 300 جيجابايت من المفاتيح.

$$
6 \space characters \times 56.8 \space billion = \sim 390 \space GB
$$

على الرغم من أن 390 جيجابايت يبدو وكأنها الكثير لهذا الاستخدام البسيط، إلا أنه من المهم أن نتذكر أن هذا لفترة حياة خدمتنا بأكملها وحجم قاعدة البيانات للمفاتيح لن يزداد مثل قاعدتنا البيانات الرئيسية.

### التخزين المؤقت

الآن، دعونا نتحدث عن [التخزين المؤقت](https://karanpratapsingh.com/courses/system-design/caching). ووفقًا لتقديراتنا، سنحتاج إلى حوالي ~35 جيجابايت من الذاكرة يوميًا لتخزين 20% من الطلبات الواردة إلى خدماتنا. لهذا الاستخدام، يمكننا استخدام خوادم [Redis](https://redis.io) أو [Memcached](https://memcached.org) جنبًا إلى جنب مع خادم API.

_لمزيد من التفاصيل، راجع [التخزين المؤقت](https://karanpratapsingh.com/courses/system-design/caching)._

### التصميم

الآن بعد أن حددنا بعض المكونات الأساسية، دعونا نقوم بصياغة مسودة أولية لتصميم نظامنا.

![url-shortener-basic-design](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-V/url-shortener/url-shortener-basic-design.png)

هكذا يعمل النظام:

**إنشاء عنوان URL جديد**

1. عندما ينشئ المستخدم عنوان URL جديد، يطلب خادم الـ API مفتاح فريد جديد من خدمة توليد المفاتيح (KGS).
2. تقدم خدمة توليد المفاتيح مفتاحًا فريدًا لخادم الـ API وتضع علامة على المفتاح على أنه تم استخدامه.
3. يكتب خادم الـ API إدخال العنوان الجديد في قاعدة البيانات والذاكرة المؤقتة.
4. تعيد خدمتنا استجابة HTTP 201 (تم الإنشاء) إلى المستخدم.

**الوصول إلى عنوان URL**

1. عندما يتصفح العميل إلى عنوان URL مقتصر معين، يتم إرسال الطلب إلى خوادم الـ API.
2. يصل الطلب أولاً إلى التخزين المؤقت، وإذا لم يتم العثور على الإدخال هناك، يتم استرداده من قاعدة البيانات ويتم إصدار استجابة HTTP 301 (توجيه) إلى العنوان URL الأصلي.
3. إذا ل

م يتم العثور على المفتاح حتى في قاعدة البيانات، يتم إرسال خطأ HTTP 404 (غير موجود) إلى المستخدم.

## التصميم التفصيلي

حان وقت مناقشة تفاصيل تصميمنا الأدق.

### تقسيم البيانات

لتوسيع قواعد البيانات لدينا، سنحتاج إلى تقسيم بياناتنا. يمكن أن يكون التقسيم الأفقي (المعروف أيضًا باسم [التقسيم](https://karanpratapsingh.com/courses/system-design/sharding)) خطوة أولى جيدة. يمكننا استخدام خطط تقسيم مثل:

- التقسيم القائم على الهاش
- التقسيم القائم على القائمة
- التقسيم القائم على النطاق
- التقسيم المركب

النهج المذكور أعلاه قد يسبب توزيعًا غير متساويًا للبيانات والأحمال، يمكننا حل هذا باستخدام [التجزئة المستمرة](https://karanpratapsingh.com/courses/system-design/consistent-hashing).

_للمزيد من التفاصيل، يمكنك الرجوع إلى [التقسيم](https://karanpratapsingh.com/courses/system-design/sharding) و [التجزئة المستمرة](https://karanpratapsingh.com/courses/system-design/consistent-hashing)._

### تنظيف قاعدة البيانات

هذه خطوة أكثر توجيهًا لصيانة خدماتنا وتعتمد على ما إذا كنا سنحتفظ بالإدخالات المنتهية أم سنقوم بإزالتها. إذا قررنا إزالة الإدخالات المنتهية، يمكننا التعامل مع هذا الأمر بطريقتين مختلفتين:

**تنظيف نشط**

في التنظيف النشط، سنقوم بتشغيل خدمة تنظيف منفصلة ستقوم بشكل دوري بإزالة الروابط المنتهية من التخزين والذاكرة المؤقتة. ستكون هذه خدمة خفيفة الوزن جدًا مثل [المهمة المجدولة](https://en.wikipedia.org/wiki/Cron).

**تنظيف سلبي**

في التنظيف السلبي، يمكننا إزالة الإدخالة عندما يحاول المستخدم الوصول إلى رابط منتهي. يمكن أن يضمن هذا تنظيفًا كسولًا لقاعدة البيانات والذاكرة المؤقتة.

### الذاكرة المؤقتة

الآن دعونا نتحدث عن [التخزين المؤقت](https://karanpratapsingh.com/courses/system-design/caching).

**أي سياسة تطهير ذاكرة التخزين المؤقت يجب استخدامها؟**

كما ناقشنا سابقًا، يمكننا استخدام حلول مثل [Redis](https://redis.io) أو [Memcached](https://memcached.org) وتخزين تخزين مؤقت لـ 20% من حركة البيانات اليومية، ولكن أي نوع من سياسات تطهير ذاكرة التخزين المؤقت سيكون مناسبًا لاحتياجاتنا؟

يمكن أن تكون السياسة المعتمدة على الاستخدام الأقل حديثًا (LRU) سياسة جيدة لنظامنا. في هذه السياسة، نقوم بالتخلص من المفتاح الذي تم استخدامه مؤخرًا بشكل أقل.

**كيفية التعامل مع النقص في التخزين المؤقت؟**

في حالة النقص في التخزين المؤقت، يمكن لخوادمنا أن تصل إلى قاعدة البيانات مباشرةً وتحديث التخزين المؤقت باستخدام الإدخالات الجديدة.

### القياسات والتحليلات

تسجيل التحليلات والقياسات هو واحد من متطلباتنا الموسّعة. يمكننا تخزين وتحديث البيانات الوصفية مثل بلد الزائر، والمنصة، وعدد المشاهدات، إلخ، جنبًا إلى جنب مع إدخال رابط URL في قاعدة البيانات.

### الأمان

بالنسبة للأمان، يمكننا تقديم روابط خاصة ومصادقة. يمكن استخدام جدول منفصل ل

تخزين معرّفات المستخدمين الذين لديهم إذن للوصول إلى رابط محدد. إذا لم يكن لدى المستخدم أذونات مناسبة، يمكننا إرجاع خطأ HTTP 401 (غير مصرح به).

يمكننا أيضًا استخدام [بوابة واجهة البرمجة](https://karanpratapsingh.com/courses/system-design/api-gateway) حيث يمكن أن تدعم قدرات مثل المصادقة، وتحديد معدل الاستجابة، وتوازن الأحمال من خلالها.

## التعرف وحل العقبات

![url-shortener-advanced-design](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-V/url-shortener/url-shortener-advanced-design.png)

دعونا نعرف ونحل العقبات مثل نقاط الفشل الواحدة في تصميمنا:

- "ماذا لو تعطل خدمة الواجهة البرمجية أو خدمة إنشاء المفاتيح؟"
- "كيف سنوزع حركة المرور بين مكوناتنا؟"
- "كيف يمكننا تقليل الأحمال على قاعدة البيانات؟"
- "ماذا لو فشلت قاعدة بيانات المفاتيح المستخدمة بواسطة KGS؟"
- "كيفية تحسين توفر ذاكرة التخزين المؤقت؟"

لجعل نظامنا أكثر مرونة، يمكننا القيام بما يلي:

- تشغيل عدة نسخ من خوادمنا وخدمة إنشاء المفاتيح.
- تقديم [موازنة الأحمال](https://karanpratapsingh.com/courses/system-design/load-balancing) بين العملاء والخوادم وقواعد البيانات وخوادم التخزين المؤقت.
- استخدام قراءات متعددة لقاعدة البيانات لأنها نظام ذو ميل قراءة عالٍ.
- نسخة احتياطية لقاعدة البيانات المفاتيح في حالة فشلها.
- عدة نسخ ونسخ احتياطية لذاكرة التخزين المؤقت الموزعة.

## تصميم واتساب

دعونا نصمم خدمة مراسلة فورية مشابهة لتطبيق [واتساب](https://whatsapp.com)، مماثلة لخدمات مثل [فيسبوك ماسنجر](https://www.messenger.com) و [ويشات](https://www.wechat.com).

## ما هو واتساب؟

واتساب هو تطبيق مراسلة يقدم خدمات المراسلة الفورية لمستخدميه. إنه أحد أكثر التطبيقات المحمولة استخدامًا على وجه الكوكب، حيث يربط أكثر من 2 مليار مستخدم في أكثر من 180 دولة. واتساب متاح أيضًا على الويب.

## المتطلبات

يجب أن يستوفي نظامنا المتطلبات التالية:

### المتطلبات الوظيفية

- يجب أن يدعم المحادثة من شخص إلى شخص.
- المحادثات الجماعية (حد أقصى 100 شخص).
- يجب دعم مشاركة الملفات (صورة، فيديو، إلخ).

### المتطلبات غير الوظيفية

- توفير عالي مع حد أدنى من التأخير.
- يجب أن يكون النظام قابلًا للتوسعة وفعالًا.

### المتطلبات الموسّعة

- تقارير الإرسال والتوصيل والقراءة للرسائل.
- عرض وقت آخر ظهور للمستخدمين.
- إشعارات الدفع.

## التقدير والقيود

لنبدأ بالتقدير والقيود.

_ملاحظة: تأكد من التحقق من أي افتراضات تتعلق بالمقياس أو حركة المرور مع مقابلك._

### حركة المرور

لنفترض أن لدينا 50 مليون مستخدم نشط يوميًا (DAU) وعلى المتوسط كل مستخدم يرسل على الأقل 10 رسائل إلى 4 أشخاص مختلفين يوميًا. هذا يمنحنا 2 مليار رسالة في اليوم.

$$
50 \space million \times 40 \space messages = 2 \space billion/day
$$

قد تحتوي الرسائل أيضًا على وسائط مثل الصور والفيديوهات أو ملفات أخرى. يمكننا أن نفترض أن 5 في المئة من الرسائل هي ملفات وسائط يتم مشاركتها بواسطة المستخدمين، وهذا يمنحنا 100 مليون ملف إضافي يجب تخزينهم.

$$
5 \space percent \times 2 \space billion = 100 \space million/day
$$

**ما هو معدل الطلبات في الثانية (RPS) لنظامنا؟**

2 مليار طلب في اليوم يترجم إلى 24 ألف طلب في الثانية.

$$
\frac{2 \space billion}{(24 \space hrs \times 3600 \space seconds)} = \sim 24K \space requests/second
$$

### التخزين

إذا افترضنا أن كل رسالة تتكون في المتوسط من 100 بايت، فسنحتاج إلى حوالي 200 جيجابايت من تخزين قاعدة البيانات يوميًا.

$$
2 \space billion \times 100 \space bytes = \sim 200 \space GB/day
$$

وطبقًا لم

تطلباتنا، نعلم أيضًا أن حوالي 5 في المئة من الرسائل اليومية (100 مليون) هي ملفات وسائط. إذا افترضنا أن كل ملف يبلغ متوسط 100 كيلوبايت، فسنحتاج إلى 10 تيرابايت من التخزين يوميًا.

$$
100 \space million \times 100 \space KB = 10 \space TB/day
$$

وعلى مدى 10 سنوات، سنحتاج إلى حوالي 38 بيتابايت من التخزين.

$$
(10 \space TB + 0.2 \space TB) \times 10 \space years \times 365 \space days = \sim 38 \space PB
$$

### النطاق الترددي

نظرًا لأن نظامنا يتعامل مع 10.2 تيرابايت من البيانات الواردة كل يوم، سنحتاج إلى نطاق ترددي لا يقل عن 120 ميجابايت في الثانية.

$$
\frac{10.2 \space TB}{(24 \space hrs \times 3600 \space seconds)} = \sim 120 \space MB/second
$$

### تقدير عالي المستوى

إليكم تقديرنا عالي المستوى:

| النوع                         | التقدير         |
| ------------------------- | ---------- |
| مستخدمين نشطين يوميًا (DAU)  | 50 مليون   |
| طلبات في الثانية (RPS)   | 24K/ثانية   |
| التخزين (يوميًا)          | ~10.2 تيرابايت |
| التخزين (10 سنوات)        | ~38 بيتابايت |
| النطاق الترددي           | ~120 ميجابايت/ثانية |

## تصميم النموذج البياناتي

هذا هو النموذج العام للبيانات الذي يعكس متطلباتنا.

![whatsapp-datamodel](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-V/whatsapp/whatsapp-datamodel.png)

لدينا الجداول التالية:

**المستخدمين**

ستحتوي هذه الجدول على معلومات المستخدم مثل "الاسم" و"رقم الهاتف" وتفاصيل أخرى.

**الرسائل**

كما يوحي الاسم، سيحتوي هذا الجدول على تخزين الرسائل مع خصائص مثل "النوع" (نص، صورة، فيديو، إلخ) و"المحتوى" والطوابق الزمنية لتسليم الرسالة. ستكون للرسالة أيضًا "chatID" أو "groupID" المقابلة.

**المحادثات**

يمثل هذا الجدول ببساطة محادثة خاصة بين مستخدمين اثنين ويمكن أن يحتوي على عدة رسائل.

**المستخدمين_المحادثات**

يقوم هذا الجدول بتعيين المستخدمين والمحادثات حيث يمكن لعدة مستخدمين أن يكونوا لديهم عدة محادثات (علاقة N:M) والعكس أيض

ًا.

**المجموعات**

يمثل هذا الجدول مجموعة مكونة من عدة مستخدمين.

**المستخدمين_المجموعات**

يقوم هذا الجدول بتعيين المستخدمين والمجموعات حيث يمكن لعدة مستخدمين أن يكونوا جزءًا من عدة مجموعات (علاقة N:M) والعكس أيضًا.

### أي نوع من قواعد البيانات يجب أن نستخدمه؟

بينما يبدو نموذج البيانات الخاص بنا ذا طابع علاقي، ليس من الضروري تخزين كل شيء في قاعدة بيانات واحدة، حيث يمكن أن يحد من توسعنا ويصبح نقطة توقف سريعًا.

سنقسم البيانات بين خدمات مختلفة لكل منها ملكية خاصة على جدول معين. ثم يمكننا استخدام قاعدة بيانات علاقية مثل [PostgreSQL](https://www.postgresql.org) أو قاعدة بيانات NoSQL موزعة مثل [Apache Cassandra](https://cassandra.apache.org/_/index.html) لحالتنا.

## تصميم واجهة البرمجة (API)

لنقم بتصميم واجهة برمجة تطبيقات (API) الأساسية لخدماتنا:

### الحصول على جميع المحادثات أو المجموعات

ستحصل هذه الواجهة على جميع المحادثات أو المجموعات لمستخدم معين باستخدام "userID".

```tsx
getAll(userID: UUID): Chat[] | Group[]
```

**المعلمات**

معرف المستخدم (`UUID`): معرف المستخدم الحالي.

**العائدات**

النتيجة (`Chat[] | Group[]`): جميع المحادثات والمجموعات التي يشارك فيها المستخدم.

### الحصول على الرسائل

الحصول على جميع الرسائل لمستخدم معين باستخدام "channelID" (معرف المحادثة أو المجموعة).

```tsx
getMessages(userID: UUID, channelID: UUID): Message[]
```

**المعلمات**

معرف المستخدم (`UUID`): معرف المستخدم الحالي.

معرف القناة (`UUID`): معرف القناة (معرف المحادثة أو المجموعة) الذي تحتاج إلى استرداد الرسائل منه.

**العائدات**

الرسائل (`Message[]`): جميع الرسائل في محادثة أو مجموعة معينة.

### إرسال رسالة

إرسال رسالة من مستخدم إلى قناة (محادثة أو مجموعة).

```tsx
sendMessage(userID: UUID, channelID: UUID, message: Message): boolean
```

**المعلمات**

معرف المستخدم (`UUID`): معرف المستخدم الحالي.

معرف القناة (`UUID`): معرف القناة (معرف المحادثة أو المجموعة) الذي يرغب المستخدم في إرسال رسالة إليه.

الرسالة (`Message`): الرسالة (نص، صورة، فيديو، إلخ.) التي يرغب المستخدم في إرسالها.

**العائدات**

النتيجة (`boolean`): يمثل ما إذا كانت العملية ناجحة أم لا.

### الانضمام أو مغادرة قناة

تسمح للمستخدم بالانضمام إلى قناة (محادثة أو مجموعة) أو مغادرتها.

```tsx
joinGroup(userID: UUID, channelID: UUID): boolean
leaveGroup(userID: UUID, channelID: UUID): boolean
```

**المعلمات**

معرف المستخدم (`UUID`): معرف المستخدم الحالي.

معرف القناة (`UUID`): معرف القناة (معرف المحادثة أو المجموعة) الذي يرغب المستخدم في الانضمام إليه أو مغادرته.

**العائدات**

النتيجة (`boolean`): يمثل ما إذا كانت العملية ناجحة أم لا.

## تصميم عالي المستوى

لنقم الآن بتصميم عالي المستوى لنظامنا.

### الهندسة المعمارية

سنستخدم [هندسة الخدمات المصغرة](https://karanpratapsingh.com/courses/system-design/monoliths-microservices#microservices) لأنها ستجعل من السهل توسيع خدماتنا أفقيًا وفصلها. ستمتلك كل خدمة نموذج بياناتها الخاص. دعونا نقسم نظامنا إلى بعض الخدمات الأساسية.

**خدمة المستخدمين**

هذه الخدمة تستند إلى HTTP وتتعامل مع مسائل تتعلق بالمستخدمين مثل المصادقة ومعلومات المستخدم.

**خدمة المحادثة**

ستستخدم خدمة المحادثة WebSockets وإنشاء اتصالات مع العميل للتعامل مع وظائف المحادثة والرسائل في المجموعة. يمكننا أيضًا استخدام التخزين المؤقت لتتبع جميع الاتصالات النشطة تمامًا مثل الجلسات مما سيساعدنا على تحديد ما إذا كان المستخدم متصلًا أم لا.

**خدمة الإشعارات**

ستقوم هذه الخدمة ببساط

ة بإرسال إشعارات دفع للمستخدمين. سيتم مناقشتها بالتفصيل بشكل منفصل.

**خدمة الوجود**

ستقوم خدمة الوجود بتتبع حالة "آخر ظهور" لجميع المستخدمين. سيتم مناقشتها بالتفصيل بشكل منفصل.

**خدمة الوسائط**

ستتعامل هذه الخدمة مع تحميل وسائط (صور، فيديو، ملفات، إلخ.). سيتم مناقشتها بالتفصيل بشكل منفصل.

**ماذا عن التواصل بين الخدمات واكتشاف الخدمات؟**

نظرًا لأن هندسة النظام الخاص بنا تعتمد على الخدمات المصغرة، ستتواصل الخدمات مع بعضها البعض. بشكل عام، تعمل REST أو HTTP بشكل جيد ولكن يمكننا تحسين الأداء بمزيد من الكفاءة باستخدام [gRPC](https://karanpratapsingh.com/courses/system-design/rest-graphql-grpc#grpc) والذي هو أخف وزنًا وأكثر كفاءة.

[اكتشاف الخدمات](https://karanpratapsingh.com/courses/system-design/service-discovery) هو شيء آخر يجب أخذه في الاعتبار. يمكننا أيضًا استخدام شبكة خدمة تمكِّن من التواصل المُدار والمرئي والآمن بين الخدمات الفردية.

_ملحوظة: تعرّف على المزيد حول [REST، GraphQL، gRPC](https://karanpratapsingh.com/courses/system-design/rest-graphql-grpc) وكيفية مقارنتها مع بعضها البعض._

### الرسائل في الوقت الحقيقي

كيف يمكننا إرسال واستقبال الرسائل بكفاءة؟ لدينا اختيارين مختلفين:

**نموذج الاستقطاب (Pull)**

يمكن للعميل أن يرسل بشكل دوري طلبًا HTTP إلى الخوادم للتحقق مما إذا كانت هناك رسائل جديدة. يمكن تحقيق ذلك عبر شيء مثل [الاستقطاب الطويل (Long polling)](https://karanpratapsingh.com/courses/system-design/long-polling-websockets-server-sent-events#long-polling).

**نموذج الدفع (Push)**

يفتح العميل اتصالًا طويل الأمد مع الخادم وعندما تكون البيانات الجديدة متاحة سيتم دفعها إلى العميل. يمكننا استخدام [WebSockets](https://karanpratapsingh.com/courses/system-design/long-polling-websockets-server-sent-events#websockets) أو [أحداث الخادم المرسلة (SSE)](https://karanpratapsingh.com/courses/system-design/long-polling-websockets-server-sent-events#server-sent-events-sse) لهذا.

نموذج الاستقطاب (Pull) ليس قابلاً للتوسع حيث س

يؤدي إلى إنشاء زيادة غير ضرورية في الطلبات على خوادمنا وفي معظم الوقت ستكون الاستجابة فارغة، مما يهدر مواردنا. لتقليل التأخير، استخدام نموذج الدفع (Push) باستخدام [WebSockets](https://karanpratapsingh.com/courses/system-design/long-polling-websockets-server-sent-events#websockets) هو اختيار أفضل لأننا سنتمكن من دفع البيانات إلى العميل بمجرد توفرها دون أي تأخير، بشرط أن يكون الاتصال مفتوحًا مع العميل. أيضًا، توفر WebSockets اتصالًا ذهابيًا وإيابيًا بالكامل، على عكس [أحداث الخادم المرسلة (SSE)](https://karanpratapsingh.com/courses/system-design/long-polling-websockets-server-sent-events#server-sent-events-sse) التي تكون ذات اتجاه واحد فقط.

_ملحوظة: تعرّف على المزيد حول [الاستقطاب الطويل (Long polling)، WebSockets، أحداث الخادم المرسلة (SSE)](https://karanpratapsingh.com/courses/system-design/long-polling-websockets-server-sent-events)._

### الظهور الأخير

لتنفيذ وظيفة "الظهور الأخير"، يمكننا استخدام آلية [نبضات القلب (Heartbeat)](https://en.wikipedia.org/wiki/Heartbeat_(computing))، حيث يمكن للعميل إرسال إشارة نبضية بشكل دوري إلى الخوادم للإشارة إلى عمله. نظرًا لأن هذا يحتاج إلى أدنى قدر ممكن من التكلفة، يمكننا تخزين الطابع الزمني للنشاط الأخير في الذاكرة المخبأة على النحو التالي:

| المفتاح | القيمة                |
| ------- | -------------------- |
| مستخدم أ | 2022-07-01T14:32:50 |
| مستخدم ب | 2022-07-05T05:10:35 |
| مستخدم ج | 2022-07-10T04:33:25 |

سيمنحنا هذا آخر وقت قام فيه المستخدم بالتفاعل. سيتم التعامل مع هذه الوظيفة بواسطة خدمة الوجود بالتعاون مع [Redis](https://redis.io) أو [Memcached](https://memcached.org) كذاكرة مؤقتة.

طريقة أخرى لتنفيذ ذلك هي تتبع أحدث عملية للمستخدم، عندما يتجاوز آخر نشاط عتبة معينة، مثل _"المستخدم لم يقم بأي عمل خلال الـ 30 ثانية الماضية"_. يمكننا عرض العميل على أنه غير متصل وظهوره الأخير مع الطابع الزمني الذي تم تسجيله آخر مرة. سيكون هذا نهجًا لتحديث كسول قد يفيدنا في بعض الحالات أكثر من النبضات.

### الإشعارات

بمجرد إرسال رسالة في دردشة أو مجموعة، سنتحقق أولاً مما إذا كان المستلم نشطًا أم لا، يمكننا الحصول على هذه المعلومات من خلال مراعاة الاتصال النشط للمستخدم ووقت آخر ظهوره.

إذا كان المستلم غير نشط، سيقوم خدمة الدردشة بإضافة حدث إلى [صف الرسائل](https://karanpratapsingh.com/courses/system-design/message-queues) مع بيانات تعريفية إضافية مثل منصة جهاز العميل التي سيتم استخدامها لتوجيه الإشعار إلى المنصة الصحيحة لاحقًا.

ثم ستستهلك خدمة الإشعارات الحدث من صف الرسائل وتوجيه الطلب إلى [Firebase Cloud Messaging (FCM)](https://firebase.google.com/docs/cloud-messaging) أو [Apple Push Notification Service (APNS)](https://developer.apple.com/documentation/usernotifications) استنادًا إلى منصة جهاز العميل (Android، iOS، الويب، إلخ). يمكننا أيضًا إضافة دعمًا للبريد الإلكتروني ورسائل النص.

**لماذا نستخدم صف الرسائل؟**

نظرًا لأن معظم أنظمة الرسائل توفر ترتيبًا حسب أفضل الجهود والذي يضمن تسليم الرسائل بشكل عام بنفس الترتيب الذي تم إرساله وأن تسليم الرسالة يتم مرة واحدة على الأقل، وهو جزء مهم من وظيفة خدمتنا.

على الرغم من أن هذا يبدو وكأنه استخدام تقليدي لنمط النشر-الاشتراك ([publish-subscribe](https://karanpratapsingh.com/courses

/system-design/publish-subscribe))، إلا أنه في الواقع ليس كذلك بما أن الأجهزة المحمولة ومتصفحات الويب لكل منها طريقتها الخاصة للتعامل مع الإشعارات. عادةً ما يتم التعامل مع الإشعارات بشكل خارجي من خلال Firebase Cloud Messaging (FCM) أو Apple Push Notification Service (APNS) على عكس انتشار الرسائل الذي نراه بشكل شائع في خدمات الخادم الخلفي. يمكننا استخدام شيء مثل [Amazon SQS](https://aws.amazon.com/sqs) أو [RabbitMQ](https://www.rabbitmq.com) لدعم هذه الوظيفة.

### تلقي إيصالات القراءة

التعامل مع إيصالات القراءة يمكن أن يكون أمرًا معقدًا، لهذا الغرض يمكننا الانتظار حتى نحصل على نوع من [التأكيد (ACK)](https://en.wikipedia.org/wiki/Acknowledgement_(data_networks)) من العميل لتحديد ما إذا تم تسليم الرسالة وتحديث الحقل `deliveredAt` المقابل. بالمثل، سنضيف علامة على الرسالة كمقروءة بمجرد أن يفتح المستخدم الدردشة وتحديث الحقل الزمني المقابل `seenAt`.

### التصميم

الآن بعد أن قمنا بتحديد بعض المكونات الأساسية، دعونا نقوم بصياغة المسودة الأولى لتصميم نظامنا.

![whatsapp-basic-design](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-V/whatsapp/whatsapp-basic-design.png)

## تصميم مفصل

حان الوقت لمناقشة قرارات التصميم لدينا بالتفصيل.

### تجزئة البيانات

لتوسيع قواعد البيانات لدينا سنحتاج إلى تجزئة بياناتنا. يمكن أن تكون التجزئة الأفقية (المعروفة أيضًا بـ [التجزئة الأفقية](https://karanpratapsingh.com/courses/system-design/sharding)) خطوة أولى جيدة. يمكننا استخدام أنماط التجزئة مثل:

- التجزئة القائمة على التجزئة (Hash-Based Partitioning)
- التجزئة القائمة على القائمة (List-Based Partitioning)
- التجزئة القائمة على النطاق (Range Based Partitioning)
- التجزئة المركبة (Composite Partitioning)

تلك النماذج أعلاه قد تؤدي لاستقطاب غير متساوي للبيانات والأعباء، ويمكننا حل هذا باستخدام [التجزئة المتسقة (Consistent hashing)](https://karanpratapsingh.com/courses/system-design/consistent-hashing).

_لمزيد من التفاصيل، راجع [التجزئة (Sharding)](https://karanpratapsingh.com/courses/system-design/sharding) و [التجزئة المتسقة (Consistent Hashing

)](https://karanpratapsingh.com/courses/system-design/consistent-hashing).__

### التخزين المؤقت (Caching)

في تطبيق الرسائل، يجب أن نكون حذرين عند استخدام التخزين المؤقت نظرًا لأن المستخدمين يتوقعون البيانات الأحدث، ولكن العديد من المستخدمين سيطلبون نفس الرسائل، خاصةً في دردشة المجموعة. لذا، من أجل منع الذروات في استهلاك مواردنا، يمكننا تخزين الرسائل القديمة في التخزين المؤقت.

بعض دردشات المجموعات يمكن أن تحتوي على آلاف الرسائل وسيكون إرسالها عبر الشبكة غير كفوء، لتحسين الكفاءة يمكننا إضافة ترقيم لنظام واجهات البرمجة (APIs) لدينا. سيكون هذا القرار مفيدًا للمستخدمين ذوي العرض الترددي المحدود حيث لن يكون عليهم استرداد الرسائل القديمة إلا عند الطلب.

**أي نوع من سياسة إخراج التخزين المؤقت يجب استخدامه؟**

يمكننا استخدام حلول مثل [Redis](https://redis.io) أو [Memcached](https://memcached.org) وتخزين 20٪ من حركة المرور اليومية، ولكن أي نوع من سياسات إخراج التخزين المؤقت سيكون مناسبًا لاحتياجاتنا؟

[Least Recently Used (LRU)](<https://en.wikipedia.org/wiki/Cache_replacement_policies#Least_recently_used_(LRU)>) يمكن أن يكون سياسة جيدة لنظامنا. في هذه السياسة، نقوم بنبذ المفتاح الذي تم استخدامه مؤخرًا بشكل أقل أولاً.

**كيفية التعامل مع نقص التخزين المؤقت؟**

كلما حدث نقص في التخزين المؤقت، يمكن لخوادمنا الاتصال بقاعدة البيانات مباشرة وتحديث التخزين المؤقت بالمدخلات الجديدة.

_لمزيد من التفاصيل، راجع [التخزين المؤقت (Caching)](https://karanpratapsingh.com/courses/system-design/caching)._

### وصول وتخزين الوسائط

كما نعلم، ستُستخدم معظم مساحة التخزين لدينا لتخزين ملفات وسائط مثل الصور ومقاطع الفيديو أو ملفات أخرى. سيتولى خدمة الوسائط لدينا كل من وصول وتخزين ملفات وسائط المستخدم.

ولكن أين يمكننا تخزين الملفات على نطاق واسع؟ حسنًا، [التخزين على شكل كائنات (Object Storage)](https://karanpratapsingh.com/courses/system-design/storage#object-storage) هو ما نبحث عنه. تقوم تخزينات الكائنات بتجزئة ملفات البيانات إلى قطع تسمى كائنات. ثم تخزن تلك الكائنات في مستودع واحد، والذي يمكن أن يكون موزعًا عبر أنظمة متعددة متصلة بشبكة. يمكننا أيضًا استخدام تخزين الملفات الموزعة مثل [HDFS](https://karanpratapsingh.com/courses/system-design/storage#hdfs) أو [GlusterFS](https://www.gluster.org).

_حقيقة ممتعة: تقوم واتساب بحذف الوسائط على خوادمها بمجرد أن يتم تنزيلها من قبل المستخدم._

يمكننا استخدام تخزين الكائنات مثل [Amazon S3](https://aws.amazon.com/s3) أو [Azure Blob Storage](https://azure.microsoft.com/en-in/services/storage/blobs) أو [Google Cloud Storage](https://cloud.google.com/storage) لهذا الاستخدام.

### شبكة تسليم المحتوى (CDN)

[شبكة تسليم المحتوى (CDN)](https://karanpratapsingh.com/courses/system-design/content-delivery-network) تزيد من توفر وتكرار المحتوى وتقليل تكاليف النطاق الترددي. عمومًا، يتم تقديم الملفات الثابتة مثل الصور ومقاطع الفيديو من خلال شبكة CDN. يم

كننا استخدام خدمات مثل [Amazon CloudFront](https://aws.amazon.com/cloudfront) أو [Cloudflare CDN](https://www.cloudflare.com/cdn) لهذا الاستخدام.

### بوابة واجهة برمجة التطبيق (API Gateway)

نظرًا لأننا سوف نستخدم بروتوكولات متعددة مثل HTTP وWebSocket وTCP/IP، سيكون نشر محملات التوازن بين الخوادم من الطبقة الرابعة (طبقة النقل) أو الطبقة السابعة (طبقة التطبيق) بشكل منفصل لكل بروتوكول مكلفًا. بدلاً من ذلك، يمكننا استخدام [بوابة واجهة برمجة التطبيق (API Gateway)](https://karanpratapsingh.com/courses/system-design/api-gateway) التي تدعم بروتوكولات متعددة دون أي مشكلات.

قد تقدم بوابة واجهة برمجة التطبيق ميزات أخرى مثل المصادقة، والتفويض، وتحديد السرعة، والتقييد، وإصدارات واجهة برمجة التطبيق، والتي ستحسن جودة خدماتنا.

يمكننا استخدام خدمات مثل [Amazon API Gateway](https://aws.amazon.com/api-gateway) أو [Azure API Gateway](https://azure.microsoft.com/en-in/services/api-management) لهذا الاستخدام.

## التعرف على نقاط الضعف وحلها

![whatsapp-advanced-design](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-V/whatsapp/whatsapp-advanced-design.png)

لنتعرف على نقاط الضعف ونحلها مثل نقاط الفشل الفردية في تصميمنا:

- "ماذا لو انهارت إحدى خدماتنا؟"
- "كيف سنوزع حركة المرور بين مكوناتنا؟"
- "كيف يمكننا تقليل الأحمال على قاعدة البيانات؟"
- "كيف يمكن تحسين توفر التخزين المؤقت؟"
- "ألن تكون بوابة واجهة البرمجة التطبيق نقطة فشل فردية؟"
- "كيف يمكن جعل نظام الإشعارات أكثر قوة؟"
- "كيف يمكننا تقليل تكاليف تخزين الوسائط؟"
- "هل لدى خدمة الدردشة مسؤوليات كبيرة؟"

لجعل نظامنا أكثر قدرة على التحمل، يمكننا القيام بما يلي:

- تشغيل عدة نسخ من كل من خدماتنا.
- تقديم [محملات توازن الحمولة](https://karanpratapsingh.com/courses/system-design/load-balancing) بين العملاء والخوادم وقواعد البيانات وخوادم التخزين المؤقت.
- استخدام قراء مكررة متعددة لقواعد البيانات لدينا.
- نسخ متعددة ومكررة لخوادم التخزين المؤقت لدينا.
- يمكن أن يكون لدينا نسخة احتياطية لـ بوابة واجهة البرمجة التطبيق (API Gateway).
- تس

ليم مرة واحدة تمامًا وترتيب الرسائل أمر صعب في نظام موزع، يمكننا استخدام [وسيط الرسائل المخصص](https://karanpratapsingh.com/courses/system-design/message-brokers) مثل [Apache Kafka](https://kafka.apache.org) أو [NATS](https://nats.io) لجعل نظام الإشعارات أكثر قوة.
- يمكننا إضافة إمكانيات معالجة وضغط الوسائط إلى خدمة الوسائط لضغط الملفات الكبيرة بشكل مماثل لواتساب والتي ستوفر الكثير من مساحة التخزين وتقليل التكلفة.
- يمكننا إنشاء خدمة مجموعة منفصلة عن خدمة الدردشة لتفكيك خدماتنا بشكل أكبر.

هذه الخطوات ستجعل نظامنا أكثر مرونة وقدرة على التحمل.

# تويتر

دعونا نصمم خدمة وسائل التواصل الاجتماعي مشابهة لـ [تويتر](https://twitter.com)، تشبه الخدمات مثل [فيسبوك](https://facebook.com)، [إنستغرام](https://instagram.com)، وما إلى ذلك.

## ما هو تويتر؟

تويتر هو خدمة وسائل التواصل الاجتماعي حيث يمكن للمستخدمين قراءة أو نشر رسائل قصيرة (تصل إلى 280 حرفًا) تُسمى تغريدات. إنه متاح على الويب ومنصات الجوال مثل أندرويد وآي أو إس.

## المتطلبات

يجب أن يفي نظامنا بالمتطلبات التالية:

### المتطلبات الوظيفية

- يجب أن يكون بإمكان المستخدمين نشر تغريدات جديدة (يمكن أن تكون نصًا، صورة، فيديو، وما إلى ذلك).
- يجب أن يكون بإمكان المستخدمين متابعة مستخدمين آخرين.
- يجب أن يكون هناك ميزة لتغذية الأخبار تتضمن تغريدات من الأشخاص الذين يتابعهم المستخدم.
- يجب أن يكون بإمكان المستخدمين البحث عن تغريدات.

### المتطلبات غير الوظيفية

- توفر عالي مع الحد الأدنى من التأخير.
- يجب أن يكون النظام قابلًا للتوسعة وفعّالًا.

### المتطلبات الموسعة

- مقاييس وتحليلات.
- وظيفة إعادة التغريد.
- تغريدات المفضلة.

## التقدير والقيود

لنبدأ بالتقدير والقيود.

_ملاحظة: تأكد من التحقق من أي افتراضات تتعلق بالمقياس أو حركة المرور مع مقابلك._

### حركة المرور

سيكون هذا نظامًا يعتمد بشكل رئيسي على القراءة، دعونا نفترض أن لدينا مليار مستخدم إجمالي مع 200 مليون مستخدم نشط يوميًا (DAU)، ومتوسط كل مستخدم يقوم بنشر 5 تغريدات في اليوم. هذا يمنحنا 1 مليار تغريدة يوميًا.

$$
200 \space مليون \times 5 \space تغريدات = 1 \space مليار/يوم
$$

تستطيع التغريدات أيضًا أن تحتوي على وسائط مثل الصور أو الفيديو. يمكننا أن نفترض أن 10 في المئة من التغريدات هي ملفات وسائط تم مشاركتها من قبل المستخدمين، مما يمنحنا 100 مليون ملف إضافي يجب تخزينهم.

$$
10 \space في المئة \times 1 \space مليار = 100 \space مليون/يوم
$$

**ما سيكون عدد الطلبات في الثانية الواحدة (RPS) لنظامنا؟**

1 مليار طلب في اليوم يترجم إلى 12 ألف طلب في الثانية.

$$
\frac{1 \space مليار}{(24 \space ساعة \times 3600 \space ثانية)} = \sim 12 \space ألف طلب/ثانية
$$

### التخزين

إذا افترضنا أن كل رسالة في المتوسط تأخذ 100 بايت، سنحتاج إلى حوالي 100 غيغابايت من تخزين قاعدة البيانات يوميًا.

$$
1 \space مليار \times 100 \space بايت = \sim 100 \space غيغابايت/يوم
$$

نعلم أيضًا أن حوالي 10 في المئة من رسائلنا اليومية (100 مليون) هي ملفات وسائط وفقًا لمتطلباتنا. إذا افترضنا أن كل ملف يبلغ متوسطه 50 كيلوبايت، سنحتاج إلى 5 تيرابايت من التخزين يوميًا.

$$
100 \space مليون \times 50 \space كيلوبايت = 5 \space تيرابايت/

يوم
$$

وخلال 10 سنوات، سنحتاج إلى حوالي 19 بيتابايت من التخزين.

$$
(5 \space تيرابايت + 0.1 \space تيرابايت) \times 365 \space يوم \times 10 \space سنوات = \sim 19 \space بيتابايت
$$

### العرض الترددي

نظرًا لأن نظامنا يتعامل مع 5.1 تيرابايت من البيانات الواردة كل يوم، سنحتاج إلى عرض ترددي دقيق يبلغ حوالي 60 ميجابايت في الثانية.

$$
\frac{5.1 \space تيرابايت}{(24 \space ساعة \times 3600 \space ثانية)} = \sim 60 \space ميجابايت/ثانية
$$

### تقدير عام

إليكم تقديرنا العام:

| النوع                     | التقدير     |
| ------------------------- | ----------- |
| مستخدمون نشطون يوميًا (DAU) | 100 مليون |
| طلبات في الثانية (RPS) | 12K/ثانية       |
| التخزين (يوميًا)         | ~5.1 تيرابايت     |
| التخزين (10 سنوات)        | ~19 بيتابايت      |
| العرض الترددي                 | ~60 ميجابايت/ثانية    |

## تصميم نموذج البيانات

هذا هو نموذج البيانات العام الذي يعكس متطلباتنا.

![نموذج-بيانات-تويتر](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-V/twitter/twitter-datamodel.png)

لدينا الجداول التالية:

**users**

تحتوي هذه الجدول على معلومات المستخدم مثل "الاسم"، "البريد الإلكتروني"، "تاريخ الميلاد"، وتفاصيل أخرى.

**tweets**

كما يوحي الاسم، سيحتوي هذا الجدول على التغريدات وخصائصها مثل "النوع" (نص، صورة، فيديو، وما إلى ذلك)، "المحتوى"، وما إلى ذلك. سنقوم أيضًا بتخزين "userID" المقابل.

**favorites**

يختص هذا الجدول بتعيين التغريدات مع المستخدمين لوظيفة تغريدات المفضلة في تطبيقنا.

**followers**

يعيّن هذا الجدول المتابعين والـ "followees" كما يمكن للمستخدمين متابعة بعضهم البعض (علاقة N:M).

**feeds**

يخزن هذا الجدول خصائص التغذية مع "userID" المقابل.

**feeds_tweets**

يعيّن هذا الجدول التغريدات والتغذية (علاقة N:M).

### أي نوع من قواعد البيانات يجب أن نستخدم؟

بينما يبدو نموذج بياناتنا نسبيًا ذا طابع علاقي، ليس من الضروري أن نقوم بتخزين كل شيء في قاعدة بيانات واحدة، حيث يمكن أن يقيّد ذلك قابليتنا للتوسع ويصبح سرعان ما عائقًا.

سنقسم البيانات بين خدمات مختلفة تمتلك كل منها السيطرة على جدول معين. ثم يمكننا استخدام قاعدة بيانات علاقية مثل [PostgreSQL](https://www.postgresql.org) أو قاعدة بيانات NoSQL موزعة مثل [Apache Cassandra](https://cassandra.apache.org/_/index.html) لحالتنا.

## تصميم واجهة البرمجة (API)

لنقم بتصميم واجهة برمجة التطبيق (API) الأساسية لخدماتنا:

### نشر تغريدة

ستسمح هذه الواجهة للمستخدم بنشر تغريدة على المنصة.

```tsx
postTweet(userID: UUID, content: string, mediaURL?: string): boolean
```

**المعلمات**

مُعرّف المستخدم (`UUID`): مُعرّف المستخدم.

المحتوى (`string`): محتوى التغريدة.

رابط الوسائط (`string`): رابط الوسائط المرفقة _(اختياري)_.

**العودة**

النتيجة (`boolean`): تُمثّل ما إذا كانت العملية ناجحة أم لا.

### متابعة أو إلغاء متابعة مستخدم

ستسمح هذه الواجهة للمستخدم بمتابعة أو إلغاء متابعة مستخدم آخر.

```tsx
follow(followerID: UUID, followeeID: UUID): boolean
unfollow(followerID: UUID, followeeID: UUID): boolean
```

**المعلمات**

مُعرّف المتابع (`UUID`): مُعرّف المستخدم الحالي.

مُعرّف المتابَع (`UUID`): مُعرّف المستخدم الذي نريد متابعته أو إلغاء متابعته.

**العودة**

النتيجة (`boolean`): تُمثّل ما إذا كانت العملية ناجحة أم لا.

### الحصول على تغذية الأخبار

ستقوم هذه الواجهة بإرجاع جميع التغريدات التي سيتم عرضها في تغذية الأخبار الخاصة بمستخدم معين.

```tsx
getNewsfeed(userID: UUID): Tweet[]
```

**المعلمات**

مُعرّف المستخدم (`UUID`): مُعرّف المستخدم.

**العودة**

التغريدات (`Tweet[]`): جميع التغريدات التي سيتم عرضها في تغذية الأخبار الخاصة بمستخدم معين.

## تصميم مستوى عالي

لنقم الآن بتصميم عالي المستوى ل

نظامنا.

### الهندسة المعمارية

سنستخدم [هندسة الخدمات الصغيرة (Microservices)](https://karanpratapsingh.com/courses/system-design/monoliths-microservices#microservices) حيث ستسهّل لنا هذه الهندسة توسيع الخدمات أفقيًا وفصلها عن بعضها البعض. ستمتلك كل خدمة بياناتها الخاصة. دعونا نحاول تقسيم نظامنا إلى بعض الخدمات الأساسية.

**خدمة المستخدم**

هذه الخدمة تتعامل مع قضايا تتعلق بالمستخدمين مثل المصادقة ومعلومات المستخدم.

**خدمة تغذية الأخبار**

ستتعامل هذه الخدمة مع إنشاء ونشر تغذية الأخبار للمستخدمين. سيتم مناقشتها بالتفصيل بشكل منفصل.

**خدمة التغريدة**

ستتعامل خدمة التغريدة مع استخدامات التغريدة مثل نشر تغريدة، تغريدات المفضلة، وما إلى ذلك.

**خدمة البحث**

هذه الخدمة مسؤولة عن معالجة وظائف البحث. ستتم مناقشتها بالتفصيل بشكل منفصل.

**خدمة الوسائط**

ستتعامل هذه الخدمة مع تحميل الوسائط (الصور، الفيديو، الملفات، إلخ). سيتم مناقشتها بالتفصيل بشكل منفصل.

**خدمة الإشعارات**

ستقوم هذه الخدمة ببساطة بإرسال إشعارات دفع إلى المستخدمين.

**خدمة التحليلات**

ستُستخدم هذه الخدمة لاستخدامات المقاييس والتحليلات.

**ماذا عن التواصل بين الخدمات واكتشاف الخدمات؟**

نظرًا لأن هندسة النظام لدينا مبنية على خدمات صغيرة، سيتواصل الخدمات مع بعضها. عمومًا، تؤدي التقنيات المعتادة مثل REST أو HTTP بشكل جيد ولكن يمكننا تحسين الأداء بمزيد من التحسين باستخدام [gRPC](https://karanpratapsingh.com/courses/system-design/rest-graphql-grpc#grpc) الذي يعتبر أكثر خفة وكفاءة.

[اكتشاف الخدمات](https://karanpratapsingh.com/courses/system-design/service-discovery) هو شيء آخر يجب أن نأخذه في الاعتبار. يمكننا أيضًا استخدام "خدمة الشبكة" (Service Mesh) التي تمكّن من التواصل بين الخدمات الفردية بشكل مُدار وقابل للمراقبة والأمان.

_ملاحظة: تعرف على المزيد حول [REST و GraphQL و gRPC](https://karanpratapsingh.com/courses/system-design/rest-graphql-grpc) وكيف تتفاوت هذه التقنيات مع بعضها البعض._

### تغذية الأخبار

عندما يتعلق الأمر بتغذية الأخبار، يبدو أن تنفيذها سهل بما فيه الكفاية، ولكن هناك العديد من الأمور التي يمكن أن تجعل هذه الميزة تكون ناجحة أو فاشلة. لنقسم مشكلتنا إلى جزئين:

**إنشاء التغذية**

لنفترض أننا نريد إنشاء تغذية للمستخدم A، سنقوم بأداء الخطوات التالية:

1. استرداد مُعرفات جميع المستخدمين والكيانات (الهاشتاجات، الموضوعات، إلخ) الذين يتابعهم المستخدم A.
2. جلب التغريدات ذات الصلة لكل معرّف تم استرداده.
3. استخدام خوارزمية ترتيب لترتيب التغريدات بناءً على معايير مثل الأهمية، الوقت، التفاعل، وما إلى ذلك.
4. إرجاع بيانات التغريدات المُرتّبة إلى العميل بطريقة مُصفّحة.

إن إنشاء التغذية هو عملية مكثفة وقد تستغرق وقتًا طويلاً، خاصةً بالنسبة للمستخدمين الذين يتابعون الكثير من الأشخاص. لتحسين الأداء، يمكن توليد التغذية مُسبقًا وتخزينها في الذاكرة المخبأة، ثم يمكننا وجود آلية لتحديث التغذية بشكل دوري وتطبيق خوارزمية الترتيب على التغريدات الجديدة.

**نشر التغذية**

النشر هو الخطوة التي يتم فيها دفع بيانات التغذية وفقًا لكل مستخدم بشكل محدد. يمكن أن يكون هذا عملية ثقيلة للغاية، حيث قد يكون لدى المستخدم ملايين من الأصدقاء أو المتابعين. للتعامل مع هذا، لدينا ثلاثة نماذج مختلفة:

- نموذج الاستحضار (Pull Model) أو الزحف على التحميل (Fan-out on load)

![نموذج-استحضار-التغذية](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-V/twitter/newsfeed-pull-model.png)

عندما يقوم مستخدم بإنشاء تغريدة، ويقوم أحد المتابعين بإعادة تحميل تغذيتهم، يتم إنشاء التغذية وتخزينها في الذاكرة المؤقتة. يتم تحميل أحدث تغذية فقط عندما يطلبها المستخدم. يقلل هذا النموذج من عدد عمليات الكتابة على قاعدة البيانات.

عيب هذا النموذج هو أن المستخدمين لن يكونوا قادرين على عرض التغذيات الأخيرة ما لم يقوموا بـ "سحب" البيانات من الخادم، مما سيزيد من عدد عمليات القراءة على الخادم.

- نموذج الدفع (Push Model) أو الزحف على الكتابة (Fan-out on write)

![نموذج-الدفع-للتغذية](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-V/twitter/newsfeed-push-model.png)

في هذا النموذج، عندما يقوم مستخدم بإنشاء تغريدة، يتم "دفع" التغريدة إلى تغذية جميع المتابعين على الفور. يمنع ذلك النظام من الحاجة إلى الانتقال عبر قائمة متابعي المستخدم للتحقق من التحديثات.

مع ذلك، عيب هذا النموذج هو أنه سيزيد من عدد عمليات الكتابة على قاعدة البيانات.

- النموذج المختلط (Hybrid Model)

النهج الثالث هو نموذج مختلط بين نموذج الاستحضار ونموذج الدفع. يجمع هذا النموذج بين الميزات المفيدة للنموذجين السابقين ويحاول تقديم نهج متوازن بينهما.

يُسمح للنم

وذج المختلط بالمستخدمين الذين لديهم عدد أقل من المتابعين باستخدام نموذج الدفع. بالنسبة للمستخدمين الذين لديهم عدد أكبر من المتابعين مثل المشاهير، يُستخدم نموذج الاستحضار.

### خوارزمية الترتيب

كما ناقشنا، سنحتاج إلى خوارزمية ترتيب لترتيب كل تغريدة وفقًا لأهميتها لكل مستخدم بشكل مُحدد.

على سبيل المثال، كانت فيسبوك تستخدم في السابق خوارزمية [EdgeRank](https://en.wikipedia.org/wiki/EdgeRank). هنا، يتم وصف ترتيب كل عنصر في التغذية بالمعادلة التالية:

$$
الترتيب = الارتباط \times الوزن \times التحلل
$$

حيث:

`الارتباط`: هو "القرب" من المستخدم إلى مُنشئ الحافة. إذا كان المستخدم يحب أو يعلق أو يرسل رسائل بشكل متكرر لمُنشئ الحافة، فسيكون قيمة الارتباط أعلى، مما يؤدي إلى ترتيب أعلى للمشاركة.

`الوزن`: هو القيمة المُخصصة وفقًا لكل حافة. يمكن أن يكون للتعليق وزنًا أعلى من الإعجابات، وبالتالي فإن المشاركة مع المزيد من التعليقات من المرجح أن تحصل على ترتيب أعلى.

`التحلل`: هو مقياس إنشاء الحافة. كلما زادت قدم الحافة، قلت قيمة التحلل وبالتالي الترتيب.

في الوقت الحالي، تكون الخوارزميات أكثر تعقيدًا ويتم تنفيذ الترتيب باستخدام نماذج التعلم الآلي التي يمكن أن تأخذ الآلاف من العوامل في الاعتبار.

### عمليات إعادة التغريد

عمليات إعادة التغريد تعد واحدة من متطلباتنا الممتدة. لتنفيذ هذه الميزة، يمكننا ببساطة إنشاء تغريدة جديدة باستخدام مُعرّف المستخدم للمستخدم الذي أعاد التغريدة من التغريدة الأصلية، ثم نقوم بتعديل النوع (Enum) وخاصية المحتوى (Content) للتغريدة الجديدة لربطها بالتغريدة الأصلية.

على سبيل المثال، يمكن أن يكون نوع (Enum) خاصية التغريدة من نوع "تغريدة"، مشابهًا للنص والفيديو، إلخ ويمكن أن يكون المحتوى هو مُعرّف التغريدة الأصلية. حيث تُمثل الصف الأولى التغريدة الأصلية، بينما الصف الثاني يوضح كيفية تمثيل تغريدة إعادة التغريد.

| المعرّف  | مُعرّف المستخدم | النوع  | المحتوى | تاريخ الإنشاء |
| --------- | ----------------- | ------ | ------- | -------------- |
| ad34-291a | 7a2c-62c4         | نص    | مرحبًا، هذه أول تغريدة لي... | 1658905644054 |
| f064-49ad | 6aa2-2bc9         | تغريدة | ad34-291a                   | 1658906165427 |

هذا تنفيذ أساسي جداً. لتحسين ذلك، يمكننا إنشاء جدول منفصل لتخزين عمليات إعادة التغريد ذاتها.

### البحث

أحيانًا، قواعد البيانات العادية لا تكون كفؤة بما فيه الكفاية، نحتاج إلى شيء يسمح لنا بتخزين وبحث وتحليل كميات ضخمة من البيانات بسرعة وبالقرب من الوقت الفعلي وتقديم النتائج في غضون مللي ثانية. يمكن أن يساعدنا [Elasticsearch](https://www.elastic.co) في هذا الحالة.

[Elasticsearch](https://www.elastic.co) هو محرك بحث وتحليل موزع ومجاني

 ومفتوح المصدر لجميع أنواع البيانات، بما في ذلك النصوص والأرقام والمكان والبنية وغير المنظمة. يتم بناؤه على أعلى [Apache Lucene](https://lucene.apache.org).

**كيف يمكننا تحديد موضوعات الاتجاه؟**

ستعتمد وظيفة الاتجاه على وظيفة البحث. يمكننا تخزين الاستعلامات والهاشتاجات والمواضيع الأكثر بحثًا بشكل مؤقت في آخر `N` ثانية وتحديثها كل `M` ثانية باستخدام نوع من آلية الوظائف على دفعة. يمكن تطبيق خوارزمية الترتيب أيضًا على موضوعات الاتجاه لمنحها وزنًا أكبر وتخصيصها للمستخدم.

### الإشعارات

الإشعارات الفورية هي جزء أساسي من أي منصة وسائل التواصل الاجتماعي. يمكننا استخدام طابور رسائل أو وسيط الرسائل مثل [Apache Kafka](https://kafka.apache.org) مع خدمة الإشعارات لإرسال الطلبات إلى [Firebase Cloud Messaging (FCM)](https://firebase.google.com/docs/cloud-messaging) أو [Apple Push Notification Service (APNS)](https://developer.apple.com/documentation/usernotifications) الذي سيتولى توصيل الإشعارات الفورية إلى أجهزة المستخدم.

_لمزيد من التفاصيل، يُرجى الإشارة إلى تصميم نظام [WhatsApp](https://karanpratapsingh.com/courses/system-design/whatsapp#notifications) حيث نناقش الإشعارات الفورية بالتفصيل._

## تصميم مفصل

حان الوقت لمناقشة قرارات التصميم لدينا بتفصيل.

### تقسيم البيانات

لتوسيع قواعد البيانات لدينا، سنحتاج إلى تقسيم بياناتنا. يمكن أن يكون التقسيم الأفقي (المعروف أيضًا بـ [Sharding](https://karanpratapsingh.com/courses/system-design/sharding)) هو خطوة جيدة أولى. يمكننا استخدام خطط تقسيم مثل:

- التقسيم القائم على الهاش
- التقسيم القائم على القائمة
- التقسيم القائم على النطاق
- التقسيم المركب

يمكن أن تسبب النهجات المذكورة أعلاه توزيعًا غير منتظم للبيانات والأحمال، يمكننا حل هذه المشكلة باستخدام [الهاش المستمر](https://karanpratapsingh.com/courses/system-design/consistent-hashing).

_لمزيد من التفاصيل، يُرجى الإشارة إلى [Sharding](https://karanpratapsingh.com/courses/system-design/sharding) و [الهاش المستمر](https://karanpratapsingh.com/courses/system-design/consistent-hashing)._

### أصدقاء مشتركين

بالنسبة للأصدقاء المشتركين، يمكننا بناء رسم بياني اجتماعي لكل مستخدم. كل عقدة في الرسم البياني ستمثل مستخدمًا، وسيمثل الحافة الاتجاهية المتابعين والمتابعون. بعد ذلك، يمكننا الانتقال إلى متابعي مستخدم للعثور على أصدقاء مشتركين واقتراحهم. سيتطلب ذلك قاعدة بيانات رسم بياني مثل [Neo4j](https://neo4j.com) و [ArangoDB](https://www.arangodb.com).

هذا خوارزمية بسيطة جدًا، ولتحسين دقة اقتراحنا، سنحتاج إلى دمج نموذج توصية يستخدم التعلم الآلي كجزء من خوارزميتنا.

### مقاييس وتحليلات

تسجيل التحليلات والمقاييس هو واحد من متطلباتنا الممتدة. حيث سنستخدم [Apache Kafka](https://kafka.apache.org) لنشر جميع أنواع الأحداث، يمكننا معالجة هذه الأحداث وتشغيل تحليلات على البيانات باستخدام [Apache Spark](https://spark.apache.org) وهو محرك تحليلات موحد مفتوح المصدر لمعالجة البيانات بمقياس كبير.

### التخزين المؤقت

في تطبيق وسائل التواصل الاجتماعي، يجب أن نكون حذرين في استخدام التخزين المؤقت حيث يتوقع مستخدمونا البيانات الأحدث. لذا، من أجل منع الارتفاعات الحادة في استخدام مواردنا، يمكننا تخزين أعلى 20٪ من التغريدات.

ومن أجل تحسين الكفاءة بشكل أكبر، يمكننا إضافة ترقيم الصفحات إلى واجهات برمجة التطبيقات الخاصة بنظامنا. سيكون هذا القرار مفيدًا للمستخدمين الذين لديهم عرض نطاق ترددي محدود حيث لن يكون عليهم استرداد الرسائل القديمة إلا عند الطلب.

**ما هو سياسة ترحيل التخزين المؤقت المناسبة؟**

يمكننا استخدام حلول مثل [Redis](https://redis.io) أو [Memcached](https://memcached.org) وتخزين 20٪ من حركة المرور اليومية ولكن أي نوع من سياسات ترحيل التخزين المؤقت سيكون مناسبًا لاحتياجاتنا؟

سيكون السياسة المعروفة باسم [أقل استخدامًا مؤخرًا (LRU)](<https://en.wikipedia.org/wiki/Cache_replacement_policies#Least_recently

_used_(LRU)>) مناسبة لنظامنا. في هذه السياسة، يتم التخلص من المفتاح الذي تم استخدامه مؤخرًا بأولوية.

**كيفية التعامل مع عدم وجود بيانات في التخزين المؤقت؟**

عند حدوث عدم وجود بيانات في التخزين المؤقت، يمكن لخوادمنا ضرب قاعدة البيانات مباشرةً وتحديث التخزين المؤقت بالإدخالات الجديدة.

_لمزيد من التفاصيل، يُرجى الإشارة إلى [التخزين المؤقت](https://karanpratapsingh.com/courses/system-design/caching)._

### وصول وتخزين الوسائط

كما نعلم، سيتم استخدام معظم مساحة التخزين لدينا لتخزين ملفات وسائط مثل الصور ومقاطع الفيديو أو الملفات الأخرى. ستتولى خدمة الوسائط لدينا كل من وصول وتخزين ملفات وسائط المستخدم.

ولكن أين يمكننا تخزين الملفات على نطاق واسع؟ حسنًا، [تخزين الكائنات](https://karanpratapsingh.com/courses/system-design/storage#object-storage) هو ما نبحث عنه. يقوم تخزين الكائنات بتقسيم ملفات البيانات إلى قطع تسمى الكائنات. ثم يقوم بتخزين تلك الكائنات في مستودع واحد، والذي يمكن أن يُنتشر عبر الأنظمة المتصلة بالشبكة المتعددة. يمكننا أيضًا استخدام تخزين الملفات الموزع مثل [HDFS](https://karanpratapsingh.com/courses/system-design/storage#hdfs) أو [GlusterFS](https://www.gluster.org).

### شبكة توصيل المحتوى (CDN)

تزيد شبكة توصيل المحتوى ([CDN](https://karanpratapsingh.com/courses/system-design/content-delivery-network)) من توفر المحتوى والتكرار وتقليل تكاليف النطاق الترددي. عمومًا، يتم تقديم الملفات الثابتة مثل الصور ومقاطع الفيديو من شبكة توصيل المحتوى. يمكننا استخدام خدمات مثل [Amazon CloudFront](https://aws.amazon.com/cloudfront) أو [Cloudflare CDN](https://www.cloudflare.com/cdn) لهذا الاستخدام.

## تحديد وحل الأضغاط

![twitter-advanced-design](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-V/twitter/twitter-advanced-design.png)

دعونا نحدد ونحل الأضغاط مثل النقاط الفردية للفشل في تصميمنا:

- "ماذا لو تعطلت إحدى خدماتنا؟"
- "كيف سنوزع حركة المرور بين مكوناتنا؟"
- "كيف يمكننا تقليل العبء على قاعدة بياناتنا؟"
- "كيفية تحسين توافر ذاكرتنا المؤقتة؟"
- "كيف يمكننا جعل نظام الإشعارات أكثر قوة؟"
- "كيف يمكننا تقليل تكاليف تخزين الوسائط؟"

لجعل نظامنا أكثر مرونة، يمكننا القيام بالأمور التالية:

- تشغيل عدة نسخ من كل من خدماتنا.
- إدخال [موازنات الحمولة](https://karanpratapsingh.com/courses/system-design/load-balancing) بين العملاء والخوادم وقواعد البيانات وخوادم التخزين المؤقت.
- استخدام مستنسخات قراءة متعددة لقواعد بياناتنا.
- نسخ متعددة ومستنسخات لذاكرتنا المؤقتة الموزعة.
- توصيل مرة واحدة وترتيب الرسائل أمر تحدي في نظام موزع، يمكننا استخدام [وسيط الرسائل](https://karanpratapsingh.com/courses/system-design/message-brokers) المخصص مثل [Apache Kafka](https://kafka.apache.org) أو [NATS](https://nats.io) لجعل نظام الإشعارات أكثر قوة.
- يمكننا إضافة قدرات معالجة وضغط الوسائط إلى خدمة الوسائط لضغ

ط الملفات الكبيرة مما سيوفر الكثير من مساحة التخزين ويقلل التكلفة.

# Netflix

دعونا نصمم خدمة بث فيديو مشابهة لـ [نيتفليكس](https://netflix.com)، مشابهة لخدمات مثل [أمازون برايم فيديو](https://www.primevideo.com)، [ديزني بلس](https://www.disneyplus.com)، [هولو](https://www.hulu.com)، [يوتيوب](https://youtube.com)، [فيميو](https://vimeo.com)، وغيرها.

## ما هو نيتفليكس؟

نيتفليكس هي خدمة بث مبنية على الاشتراك تتيح لأعضائها مشاهدة البرامج التلفزيونية والأفلام على أجهزة متصلة بالإنترنت. تتوفر على منصات مثل الويب، iOS، Android، التلفاز، إلخ.

## المتطلبات

يجب أن يلبي نظامنا المتطلبات التالية:

### المتطلبات الوظيفية

- يجب أن يتمكن المستخدمون من بث ومشاركة الفيديوهات.
- يجب أن يكون فريق المحتوى (أو المستخدمون في حالة يوتيوب) قادرًا على رفع فيديوهات جديدة (أفلام، حلقات مسلسلات تلفزيونية، ومحتوى آخر).
- يجب أن يكون المستخدمون قادرين على البحث عن الفيديوهات باستخدام العناوين أو الوسوم.
- يجب أن يكون المستخدمون قادرين على التعليق على الفيديو مشابهة لـ يوتيوب.

### المتطلبات غير الوظيفية

- توفير درجة عالية من التوفر مع الحد الأدنى من التأخير.
- توفير درجة عالية من الموثوقية، لا يجب أن يتم فقد رفع أي فيديو.
- يجب أن يكون النظام قابلًا للتوسع وفعّالًا.

### المتطلبات الموسعة

- يجب أن يتم حجب محتوى معين [جغرافيًا](https://en.wikipedia.org/wiki/Geo-blocking).
- تكملة تشغيل الفيديو من النقطة التي تركها المستخدم.
- تسجيل مقاييس وتحليلات الفيديوهات.

## التقديرات والقيود

لنبدأ بالتقديرات والقيود.

_ملاحظة: تأكد من التحقق من أي افتراضات تتعلق بالحجم أو حركة المرور مع مقابلتك._

### حركة المرور

سيكون هذا نظامًا قائمًا على القراءة بشكل رئيسي، دعونا نفترض أن لدينا مليار مستخدم إجمالي مع 200 مليون مستخدم نشط يوميًا (DAU)، وعلى المتوسط ​​يشاهد كل مستخدم 5 فيديوهات في اليوم. هذا يعطينا مليار فيديو شوهد في اليوم.

$$
200 \space مليون \times 5 \space فيديو = 1 \space مليار/اليوم
$$

بفرض نسبة قراءة/كتابة `200:1`، سيتم تحميل حوالي 5 ملايين فيديو يوميًا.

$$
\frac{1}{200} \times 1 \space مليار = 5 \space ملايين/اليوم
$$

**ما هو عدد الطلبات في الثانية (RPS) لنظامنا؟**

مليار طلب في اليوم يترج

م إلى 12 ألف طلب في الثانية.

$$
\frac{1 \space مليار}{(24 \space ساعة \times 3600 \space ثانية)} = \sim 12 ألف \space طلب/الثانية
$$

### التخزين

إذا افترضنا أن حجم كل فيديو هو 100 ميجابايت في المتوسط، سنحتاج إلى حوالي 500 تيرابايت من التخزين كل يوم.

$$
5 \space ملايين \times 100 \space ميجابايت = 500 \space تيرابايت/اليوم
$$

وعلى مدى 10 سنوات، سنحتاج إلى 1825 بيتابايت من التخزين المذهل.

$$
500 \space تيرابايت \times 365 \space يوم \times 10 \space سنوات = \sim 1825 \space بيتابايت
$$

### عرض النطاق الترددي

نظرًا لأن نظامنا يتعامل مع 500 تيرابايت من البيانات الواردة كل يوم، سنحتاج إلى عرض نطاق ترددي دقيق يبلغ حوالي 5.8 غيغابايت في الثانية.

$$
\frac{500 \space تيرابايت}{(24 \space ساعة \times 3600 \space ثانية)} = \sim 5.8 \space غيغابايت/الثانية
$$

### تقدير عالي المستوى

إليكم تقديرنا عالي المستوى:

| النوع                     | التقدير      |
| ------------------------- | ----------- |
| المستخدمون النشطون يوميًا (DAU)  | 200 مليون |
| طلبات في الثانية (RPS) | 12 ألف/ثانية |
| التخزين (في اليوم)         | ~500 تيرابايت     |
| التخزين (على مدى 10 سنوات)        | ~1825 بيتابايت   |
| عرض النطاق الترددي                 | ~5.8 غيغابايت/ثانية |

## تصميم نموذج البيانات

هذا هو النموذج العام للبيانات الذي يعكس متطلباتنا.

![netflix-datamodel](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-V/netflix/netflix-datamodel.png)

لدينا الجداول التالية:

**users**

ستحتوي هذه الجدول على معلومات المستخدم مثل `الاسم`، `البريد الإلكتروني`، `تاريخ الميلاد`، وتفاصيل أخرى.

**videos**

كما يوحي الاسم، ستخزن هذه الجدول الفيديوهات وخصائصها مثل `العنوان`، `عنوان التدفق`، `الوسوم`، إلخ. سنخزن أيضًا `معرّف المستخدم المقابل`.

**tags**

سيقوم هذا الجدول ببساطة بتخزين الوسوم المرتبطة بفيديو معين.

**views**

يساعدنا هذا الجدول على تخزين جميع المشاهدات التي تم تلقيها على الفيديو.

**comments**

سيقوم هذا الجدول بتخزين جميع التعليقات التي تم تلقيها على الفيديو (مثل يوتيوب).

### أي نوع من قواعد البيانات يجب أن نستخدمه؟

على الرغم من أن نموذج البيانات يبدو ذا طابع تعاملي، إلا أنه ليس من الضروري أن نخزن كل شيء في قاعدة بيانات واحدة، حيث يمكن أن يقيّد ذلك قابلية توسعتنا ويصبح بسرعة مصدر اختناق.

سنقوم بتقسيم البيانات بين خدمات مختلفة، ولكل خدمة ملكية على جدول معين. بعد ذلك يمكننا استخدام قاعدة بيانات تعاملية مثل [PostgreSQL](https://www.postgresql.org) أو قاعدة بيانات NoSQL موزعة مثل [Apache Cassandra](https://cassandra.apache.org/_/index.html) لحالتنا.

## تصميم واجهات البرمجة (API)

لنقم بتصميم واجهات برمجة التطبيق الأساسية لخدماتنا:

### رفع فيديو

بناءً على تيار البايت المقدم، تتيح لنا هذه الواجهة تحميل الفيديو إلى خدمتنا.

```tsx
uploadVideo(title: string, description: string, data: Stream<byte>, tags?: string[]): boolean
```

**المعلمات**

العنوان (`string`): عنوان الفيديو الجديد.

الوصف (`string`): وصف الفيديو الجديد.

البيانات (`Byte[]`): تيار البايت لبيانات الفيديو.

الوسوم (`string[]`): وسوم الفيديو _(اختياري)_.

**العودة**

نتيجة (`boolean`): تمثل ما إذا كانت العملية ناجحة أم لا.

### بث فيديو

تسمح لمستخدمينا ببث الفيديو باستخدام الترميز والدقة المفضلين.

```tsx
streamVideo(videoID: UUID, codec: Enum<string>, resolution: Tuple<int>, offset?: int): VideoStream
```

**المعلمات**

معرّف الفيديو (`UUID`): معرّف الفيديو الذي يجب بثه.

الترميز (`Enum<string>`): [الترميز](https://en.wikipedia.org/wiki/Video_codec) المطلوب للفيديو المطلوب، مثل `h.265`، `h.264`، `VP9`، إلخ.

الدقة (`Tuple<int>`): [الدقة](https://en.wikipedia.org/wiki/Display_resolution) المطلوبة للفيديو.

الإزاحة (`int`): إزاحة تيار الفيديو بالثواني لبدء تدفق البيانات من أي نقطة في الفيديو _(اختياري)_.

**العودة**

تيار (`VideoStream`): تيار البيانات للفيديو المطلوب.

### البحث عن فيديو

تمكن مستخدمينا من البحث عن فيديو بناءً على عنوانه أو وسومه.

```tsx
searchVideo(query: string, nextPage?: string): Video[]
```

**المعلمات**

الاستعلام (`string`): استعلام البحث من قبل المستخدم.

الصفحة التالية (`string`): رمز للصفحة التالية، يمكن استخدامه للترقيم _(اختياري)_.

**العودة**

فيديوهات (`Video[]`): جمي

ع الفيديوهات المتاحة للاستعلام المحدد.

### إضافة تعليق

تسمح لمستخدمينا بنشر تعليق على الفيديو (مثل يوتيوب).

```tsx
comment(videoID: UUID, comment: string): boolean
```

**المعلمات**

معرّف الفيديو (`UUID`): معرّف الفيديو الذي يرغب المستخدم في التعليق عليه.

التعليق (`string`): محتوى النص للتعليق.

**العودة**

نتيجة (`boolean`): تمثل ما إذا كانت العملية ناجحة أم لا.

## High-level design

Now let us do a high-level design of our system.

### Architecture

We will be using [microservices architecture](https://karanpratapsingh.com/courses/system-design/monoliths-microservices#microservices) since it will make it easier to horizontally scale and decouple our services. Each service will have ownership of its own data model. Let's try to divide our system into some core services.

**User Service**

This service handles user-related concerns such as authentication and user information.

**Stream Service**

The stream service will handle video streaming-related functionality.

**Search Service**

The service is responsible for handling search-related functionality. It will be discussed in detail separately.

**Media service**

This service will handle the video uploads and processing. It will be discussed in detail separately.

**Analytics Service**

This service will be used for metrics and analytics use cases.

**What about inter-service communication and service discovery?**

Since our architecture is microservices-based, services will be communicating with each other as well. Generally, REST or HTTP performs well but we can further improve the performance using [gRPC](https://karanpratapsingh.com/courses/system-design/rest-graphql-grpc#grpc) which is more lightweight and efficient.

[Service discovery](https://karanpratapsingh.com/courses/system-design/service-discovery) is another thing we will have to take into account. We can also use a service mesh that enables managed, observable, and secure communication between individual services.

_Note: Learn more about [REST, GraphQL, gRPC](https://karanpratapsingh.com/courses/system-design/rest-graphql-grpc) and how they compare with each other._

### Video processing

![video-processing-pipeline](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-V/netflix/video-processing-pipeline.png)

There are so many variables in play when it comes to processing a video. For example, an average data size of two-hour raw 8K footage from a high-end camera can easily be up to 4 TB, thus we need to have some kind of processing to reduce both storage and delivery costs.

Here's how we can process videos once they're uploaded by the content team (or users in YouTube's case) and are queued for processing in our [message queue](https://karanpratapsingh.com/courses/system-design/message-queues).

Let's discuss how this works:

- **File Chunker**

![file-chunking](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-V/netflix/file-chunking.png)

This is the first step of our processing pipeline. File chunking is the process of splitting a file into smaller pieces called chunks. It can help us eliminate duplicate copies of repeating data on storage, and reduces the amount of data sent over the network by only selecting changed chunks.

Usually, a video file can be split into equal size chunks based on timestamps but Netflix instead splits chunks based on scenes. This slight variation becomes a huge factor for a better user experience since whenever the client requests a chunk from the server, there is a lower chance of interruption as a complete scene will be retrieved.

- **Content Filter**

This step checks if the video adheres to the content policy of the platform. This can be pre-approved as in the case of Netflix according to [content rating](https://en.wikipedia.org/wiki/Motion_picture_content_rating_system) of the media or can be strictly enforced like by YouTube.

This entire process is done by a machine learning model which performs copyright, piracy, and NSFW checks. If issues are found, we can push the task to a [dead-letter queue (DLQ)](https://karanpratapsingh.com/courses/system-design/message-queues#dead-letter-queues) and someone from the moderation team can do further inspection.

- **Transcoder**

[Transcoding](https://en.wikipedia.org/wiki/Transcoding) is a process in which the original data is decoded to an intermediate uncompressed format, which is then encoded into the target format. This process uses different [codecs](https://en.wikipedia.org/wiki/Video_codec) to perform bitrate adjustment, image downsampling, or re-encoding the media.

This results in a smaller size file and a much more optimized format for the target devices. Standalone solutions such as [FFmpeg](https://ffmpeg.org) or cloud-based solutions like [AWS Elemental MediaConvert](https://aws.amazon.com/mediaconvert) can be used to implement this step of the pipeline.

- **Quality Conversion**

This is the last step of the processing pipeline and as the name suggests, this step handles the conversion of the transcoded media from the previous step into different resolutions such as 4K, 1440p, 1080p, 720p, etc.

It allows us to fetch the desired quality of the video as per the user's request, and once the media file finishes processing, it gets uploaded to a distributed file storage such as [HDFS](https://karanpratapsingh.com/courses/system-design/storage#hdfs), [GlusterFS](https://www.gluster.org), or an [object storage](https://karanpratapsingh.com/courses/system-design/storage#object-storage) such as [Amazon S3](https://aws.amazon.com/s3) for later retrieval during streaming.

_Note: We can add additional steps such as subtitles and thumbnails generation as part of our pipeline._

**Why are we using a message queue?**

Processing videos as a long-running task and using a [message queue](https://karanpratapsingh.com/courses/system-design/message-queues) makes much more sense. It also decouples our video processing pipeline from the upload functionality. We can use something like [Amazon SQS](https://aws.amazon.com/sqs) or [RabbitMQ](https://www.rabbitmq.com) to support this.

### Video streaming

Video streaming is a challenging task from both the client and server perspectives. Moreover, internet connection speeds vary quite a lot between different users. To make sure users don't re-fetch the same content, we can use a [Content Delivery Network (CDN)](https://karanpratapsingh.com/courses/system-design/content-delivery-network).

Netflix takes this a step further with its [Open Connect](https://openconnect.netflix.com) program. In this approach, they partner with thousands of Internet Service Providers (ISPs) to localize their traffic and deliver their content more efficiently.

**What is the difference between Netflix's Open Connect and a traditional Content Delivery Network (CDN)?**

Netflix Open Connect is a purpose-built [Content Delivery Network (CDN)](https://karanpratapsingh.com/courses/system-design/content-delivery-network) responsible for serving Netflix's video traffic. Around 95% of the traffic globally is delivered via direct connections between Open Connect and the ISPs their customers use to access the internet.

Currently, they have Open Connect Appliances (OCAs) in over 1000 separate locations around the world. In case of issues, Open Connect Appliances (OCAs) can failover, and the traffic can be re-routed to Netflix servers.

Additionally, we can use [Adaptive bitrate streaming](https://en.wikipedia.org/wiki/Adaptive_bitrate_streaming) protocols such as [HTTP Live Streaming (HLS)](https://en.wikipedia.org/wiki/HTTP_Live_Streaming) which is designed for reliability and it dynamically adapts to network conditions by optimizing playback for the available speed of the connections.

Lastly, for playing the video from where the user left off (part of our extended requirements), we can simply use the `offset` property we stored in the `views` table to retrieve the scene chunk at that particular timestamp and resume the playback for the user.

### Searching

Sometimes traditional DBMS are not performant enough, we need something which allows us to store, search, and analyze huge volumes of data quickly and in near real-time and give results within milliseconds. [Elasticsearch](https://www.elastic.co) can help us with this use case.

[Elasticsearch](https://www.elastic.co) is a distributed, free and open search and analytics engine for all types of data, including textual, numerical, geospatial, structured, and unstructured. It is built on top of [Apache Lucene](https://lucene.apache.org).

**How do we identify trending content?**

Trending functionality will be based on top of the search functionality. We can cache the most frequently searched queries in the last `N` seconds and update them every `M` seconds using some sort of batch job mechanism.

### Sharing

Sharing content is an important part of any platform, for this, we can have some sort of URL shortener service in place that can generate short URLs for the users to share.

_For more details, refer to the [URL Shortener](https://karanpratapsingh.com/courses/system-design/url-shortener) system design._

## Detailed design

It's time to discuss our design decisions in detail.

### Data Partitioning

To scale out our databases we will need to partition our data. Horizontal partitioning (aka [Sharding](https://karanpratapsingh.com/courses/system-design/sharding)) can be a good first step. We can use partitions schemes such as:

- Hash-Based Partitioning
- List-Based Partitioning
- Range Based Partitioning
- Composite Partitioning

The above approaches can still cause uneven data and load distribution, we can solve this using [Consistent hashing](https://karanpratapsingh.com/courses/system-design/consistent-hashing).

_For more details, refer to [Sharding](https://karanpratapsingh.com/courses/system-design/sharding) and [Consistent Hashing](https://karanpratapsingh.com/courses/system-design/consistent-hashing)._

### Geo-blocking

Platforms like Netflix and YouTube use [Geo-blocking](https://en.wikipedia.org/wiki/Geo-blocking) to restrict content in certain geographical areas or countries. This is primarily done due to legal distribution laws that Netflix has to adhere to when they make a deal with the production and distribution companies. In the case of YouTube, this will be controlled by the user during the publishing of the content.

We can determine the user's location either using their [IP](https://karanpratapsingh.com/courses/system-design/ip) or region settings in their profile then use services like [Amazon CloudFront](https://aws.amazon.com/cloudfront) which supports a geographic restrictions feature or a [geolocation routing policy](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy-geo.html) with [Amazon Route53](https://aws.amazon.com/route53) to restrict the content and re-route the user to an error page if the content is not available in that particular region or country.

### Recommendations

Netflix uses a machine learning model which uses the user's viewing history to predict what the user might like to watch next, an algorithm like [Collaborative Filtering](https://en.wikipedia.org/wiki/Collaborative_filtering) can be used.

However, Netflix (like YouTube) uses its own algorithm called Netflix Recommendation Engine which can track several data points such as:

- User profile information like age, gender, and location.
- Browsing and scrolling behavior of the user.
- Time and date a user watched a title.
- The device which was used to stream the content.
- The number of searches and what terms were searched.

_For more detail, refer to [Netflix recommendation research](https://research.netflix.com/research-area/recommendations)._

### Metrics and Analytics

Recording analytics and metrics is one of our extended requirements. We can capture the data from different services and run analytics on the data using [Apache Spark](https://spark.apache.org) which is an open-source unified analytics engine for large-scale data processing. Additionally, we can store critical metadata in the views table to increase data points within our data.

### Caching

In a streaming platform, caching is important. We have to be able to cache as much static media content as possible to improve user experience. We can use solutions like [Redis](https://redis.io) or [Memcached](https://memcached.org) but what kind of cache eviction policy would best fit our needs?

**Which cache eviction policy to use?**

[Least Recently Used (LRU)](<https://en.wikipedia.org/wiki/Cache_replacement_policies#Least_recently_used_(LRU)>) can be a good policy for our system. In this policy, we discard the least recently used key first.

**How to handle cache miss?**

Whenever there is a cache miss, our servers can hit the database directly and update the cache with the new entries.

_For more details, refer to [Caching](https://karanpratapsingh.com/courses/system-design/caching)._

### Media streaming and storage

As most of our storage space will be used for storing media files such as thumbnails and videos. Per our discussion earlier, the media service will be handling both the upload and processing of media files.

We will use distributed file storage such as [HDFS](https://karanpratapsingh.com/courses/system-design/storage#hdfs), [GlusterFS](https://www.gluster.org), or an [object storage](https://karanpratapsingh.com/courses/system-design/storage#object-storage) such as [Amazon S3](https://aws.amazon.com/s3) for storage and streaming of the content.

### Content Delivery Network (CDN)

[Content Delivery Network (CDN)](https://karanpratapsingh.com/courses/system-design/content-delivery-network) increases content availability and redundancy while reducing bandwidth costs. Generally, static files such as images, and videos are served from CDN. We can use services like [Amazon CloudFront](https://aws.amazon.com/cloudfront) or [Cloudflare CDN](https://www.cloudflare.com/cdn) for this use case.

## Identify and resolve bottlenecks

![netflix-advanced-design](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-V/netflix/netflix-advanced-design.png)

Let us identify and resolve bottlenecks such as single points of failure in our design:

- "What if one of our services crashes?"
- "How will we distribute our traffic between our components?"
- "How can we reduce the load on our database?"
- "How to improve the availability of our cache?"

To make our system more resilient we can do the following:

- Running multiple instances of each of our services.
- Introducing [load balancers](https://karanpratapsingh.com/courses/system-design/load-balancing) between clients, servers, databases, and cache servers.
- Using multiple read replicas for our databases.
- Multiple instances and replicas for our distributed cache.

# Uber

Let's design an [Uber](https://uber.com) like ride-hailing service, similar to services like [Lyft](https://www.lyft.com), [OLA Cabs](https://www.olacabs.com), etc.

## What is Uber?

Uber is a mobility service provider, allowing users to book rides and a driver to transport them in a way similar to a taxi. It is available on the web and mobile platforms such as Android and iOS.

## Requirements

Our system should meet the following requirements:

### Functional requirements

We will design our system for two types of users: Customers and Drivers.

**Customers**

- Customers should be able to see all the cabs in the vicinity with an ETA and pricing information.
- Customers should be able to book a cab to a destination.
- Customers should be able to see the location of the driver.

**Drivers**

- Drivers should be able to accept or deny the customer-requested ride.
- Once a driver accepts the ride, they should see the pickup location of the customer.
- Drivers should be able to mark the trip as complete on reaching the destination.

### Non-Functional requirements

- High reliability.
- High availability with minimal latency.
- The system should be scalable and efficient.

### Extended requirements

- Customers can rate the trip after it's completed.
- Payment processing.
- Metrics and analytics.

## Estimation and Constraints

Let's start with the estimation and constraints.

_Note: Make sure to check any scale or traffic-related assumptions with your interviewer._

### Traffic

Let us assume we have 100 million daily active users (DAU) with 1 million drivers and on average our platform enables 10 million rides daily.

If on average each user performs 10 actions (such as request a check available rides, fares, book rides, etc.) we will have to handle 1 billion requests daily.

$$
100 \space million \times 10 \space actions = 1 \space billion/day
$$

**What would be Requests Per Second (RPS) for our system?**

1 billion requests per day translate into 12K requests per second.

$$
\frac{1 \space billion}{(24 \space hrs \times 3600 \space seconds)} = \sim 12K \space requests/second
$$

### Storage

If we assume each message on average is 400 bytes, we will require about 400 GB of database storage every day.

$$
1 \space billion \times 400 \space bytes = \sim 400 \space GB/day
$$

And for 10 years, we will require about 1.4 PB of storage.

$$
400 \space GB \times 10 \space years \times 365 \space days = \sim 1.4 \space PB
$$

### Bandwidth

As our system is handling 400 GB of ingress every day, we will require a minimum bandwidth of around 4 MB per second.

$$
\frac{400 \space GB}{(24 \space hrs \times 3600 \space seconds)} = \sim 5 \space MB/second
$$

### High-level estimate

Here is our high-level estimate:

| Type                      | Estimate    |
| ------------------------- | ----------- |
| Daily active users (DAU)  | 100 million |
| Requests per second (RPS) | 12K/s       |
| Storage (per day)         | ~400 GB     |
| Storage (10 years)        | ~1.4 PB     |
| Bandwidth                 | ~5 MB/s     |

## Data model design

This is the general data model which reflects our requirements.

![uber-datamodel](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-V/uber/uber-datamodel.png)

We have the following tables:

**customers**

This table will contain a customer's information such as `name`, `email`, and other details.

**drivers**

This table will contain a driver's information such as `name`, `email`, `dob` and other details.

**trips**

This table represents the trip taken by the customer and stores data such as `source`, `destination`, and `status` of the trip.

**cabs**

This table stores data such as the registration number, and type (like Uber Go, Uber XL, etc.) of the cab that the driver will be driving.

**ratings**

As the name suggests, this table stores the `rating` and `feedback` for the trip.

**payments**

The payments table contains the payment-related data with the corresponding `tripID`.

### What kind of database should we use?

While our data model seems quite relational, we don't necessarily need to store everything in a single database, as this can limit our scalability and quickly become a bottleneck.

We will split the data between different services each having ownership over a particular table. Then we can use a relational database such as [PostgreSQL](https://www.postgresql.org) or a distributed NoSQL database such as [Apache Cassandra](https://cassandra.apache.org/_/index.html) for our use case.

## API design

Let us do a basic API design for our services:

### Request a Ride

Through this API, customers will be able to request a ride.

```tsx
requestRide(customerID: UUID, source: Tuple<float>, destination: Tuple<float>, cabType: Enum<string>, paymentMethod: Enum<string>): Ride
```

**Parameters**

Customer ID (`UUID`): ID of the customer.

Source (`Tuple<float>`): Tuple containing the latitude and longitude of the trip's starting location.

Destination (`Tuple<float>`): Tuple containing the latitude and longitude of the trip's destination.

**Returns**

Result (`Ride`): Associated ride information of the trip.

### Cancel the Ride

This API will allow customers to cancel the ride.

```tsx
cancelRide(customerID: UUID, reason?: string): boolean
```

**Parameters**

Customer ID (`UUID`): ID of the customer.

Reason (`UUID`): Reason for canceling the ride _(optional)_.

**Returns**

Result (`boolean`): Represents whether the operation was successful or not.

### Accept or Deny the Ride

This API will allow the driver to accept or deny the trip.

```tsx
acceptRide(driverID: UUID, rideID: UUID): boolean
denyRide(driverID: UUID, rideID: UUID): boolean
```

**Parameters**

Driver ID (`UUID`): ID of the driver.

Ride ID (`UUID`): ID of the customer requested ride.

**Returns**

Result (`boolean`): Represents whether the operation was successful or not.

### Start or End the Trip

Using this API, a driver will be able to start and end the trip.

```tsx
startTrip(driverID: UUID, tripID: UUID): boolean
endTrip(driverID: UUID, tripID: UUID): boolean
```

**Parameters**

Driver ID (`UUID`): ID of the driver.

Trip ID (`UUID`): ID of the requested trip.

**Returns**

Result (`boolean`): Represents whether the operation was successful or not.

### Rate the Trip

This API will enable customers to rate the trip.

```tsx
rateTrip(customerID: UUID, tripID: UUID, rating: int, feedback?: string): boolean
```

**Parameters**

Customer ID (`UUID`): ID of the customer.

Trip ID (`UUID`): ID of the completed trip.

Rating (`int`): Rating of the trip.

Feedback (`string`): Feedback about the trip by the customer _(optional)_.

**Returns**

Result (`boolean`): Represents whether the operation was successful or not.

## High-level design

Now let us do a high-level design of our system.

### Architecture

We will be using [microservices architecture](https://karanpratapsingh.com/courses/system-design/monoliths-microservices#microservices) since it will make it easier to horizontally scale and decouple our services. Each service will have ownership of its own data model. Let's try to divide our system into some core services.

**Customer Service**

This service handles customer-related concerns such as authentication and customer information.

**Driver Service**

This service handles driver-related concerns such as authentication and driver information.

**Ride Service**

This service will be responsible for ride matching and quadtree aggregation. It will be discussed in detail separately.

**Trip Service**

This service handles trip-related functionality in our system.

**Payment Service**

This service will be responsible for handling payments in our system.

**Notification Service**

This service will simply send push notifications to the users. It will be discussed in detail separately.

**Analytics Service**

This service will be used for metrics and analytics use cases.

**What about inter-service communication and service discovery?**

Since our architecture is microservices-based, services will be communicating with each other as well. Generally, REST or HTTP performs well but we can further improve the performance using [gRPC](https://karanpratapsingh.com/courses/system-design/rest-graphql-grpc#grpc) which is more lightweight and efficient.

[Service discovery](https://karanpratapsingh.com/courses/system-design/service-discovery) is another thing we will have to take into account. We can also use a service mesh that enables managed, observable, and secure communication between individual services.

_Note: Learn more about [REST, GraphQL, gRPC](https://karanpratapsingh.com/courses/system-design/rest-graphql-grpc) and how they compare with each other._

### How is the service expected to work?

Here's how our service is expected to work:

![uber-working](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-V/uber/uber-working.png)

1. Customer requests a ride by specifying the source, destination, cab type, payment method, etc.
2. Ride service registers this request, finds nearby drivers, and calculates the estimated time of arrival (ETA).
3. The request is then broadcasted to the nearby drivers for them to accept or deny.
4. If the driver accepts, the customer is notified about the live location of the driver with the estimated time of arrival (ETA) while they wait for pickup.
5. The customer is picked up and the driver can start the trip.
6. Once the destination is reached, the driver will mark the ride as complete and collect payment.
7. After the payment is complete, the customer can leave a rating and feedback for the trip if they like.

### Location Tracking

How do we efficiently send and receive live location data from the client (customers and drivers) to our backend? We have two different options:

**Pull model**

The client can periodically send an HTTP request to servers to report its current location and receive ETA and pricing information. This can be achieved via something like [Long polling](https://karanpratapsingh.com/courses/system-design/long-polling-websockets-server-sent-events#long-polling).

**Push model**

The client opens a long-lived connection with the server and once new data is available it will be pushed to the client. We can use [WebSockets](https://karanpratapsingh.com/courses/system-design/long-polling-websockets-server-sent-events#websockets) or [Server-Sent Events (SSE)](https://karanpratapsingh.com/courses/system-design/long-polling-websockets-server-sent-events#server-sent-events-sse) for this.

The pull model approach is not scalable as it will create unnecessary request overhead on our servers and most of the time the response will be empty, thus wasting our resources. To minimize latency, using the push model with [WebSockets](https://karanpratapsingh.com/courses/system-design/long-polling-websockets-server-sent-events#websockets) is a better choice because then we can push data to the client once it's available without any delay, given the connection is open with the client. Also, WebSockets provide full-duplex communication, unlike [Server-Sent Events (SSE)](https://karanpratapsingh.com/courses/system-design/long-polling-websockets-server-sent-events#server-sent-events-sse) which are only unidirectional.

Additionally, the client application should have some sort of background job mechanism to ping GPS location while the application is in the background.

_Note: Learn more about [Long polling, WebSockets, Server-Sent Events (SSE)](https://karanpratapsingh.com/courses/system-design/long-polling-websockets-server-sent-events)._

### Ride Matching

We need a way to efficiently store and query nearby drivers. Let's explore different solutions we can incorporate into our design.

**SQL**

We already have access to the latitude and longitude of our customers, and with databases like [PostgreSQL](https://www.postgresql.org) and [MySQL](https://www.mysql.com) we can perform a query to find nearby driver locations given a latitude and longitude (X, Y) within a radius (R).

```sql
SELECT * FROM locations WHERE lat BETWEEN X-R AND X+R AND long BETWEEN Y-R AND Y+R
```

However, this is not scalable, and performing this query on large datasets will be quite slow.

**Geohashing**

[Geohashing](/courses/sytem-design/geohashing-and-quadtrees#geohashing) is a [geocoding](https://en.wikipedia.org/wiki/Address_geocoding) method used to encode geographic coordinates such as latitude and longitude into short alphanumeric strings. It was created by [Gustavo Niemeyer](https://twitter.com/gniemeyer) in 2008.

Geohash is a hierarchical spatial index that uses Base-32 alphabet encoding, the first character in a geohash identifies the initial location as one of the 32 cells. This cell will also contain 32 cells. This means that to represent a point, the world is recursively divided into smaller and smaller cells with each additional bit until the desired precision is attained. The precision factor also determines the size of the cell.

![geohashing](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-IV/geohashing-and-quadtrees/geohashing.png)

For example, San Francisco with coordinates `37.7564, -122.4016` can be represented in geohash as `9q8yy9mf`.

Now, using the customer's geohash we can determine the nearest available driver by simply comparing it with the driver's geohash. For better performance, we will index and store the geohash of the driver in memory for faster retrieval.

**Quadtrees**

A [Quadtree](/courses/sytem-design/geohashing-and-quadtrees#quadtrees) is a tree data structure in which each internal node has exactly four children. They are often used to partition a two-dimensional space by recursively subdividing it into four quadrants or regions. Each child or leaf node stores spatial information. Quadtrees are the two-dimensional analog of [Octrees](https://en.wikipedia.org/wiki/Octree) which are used to partition three-dimensional space.

![quadtree](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-IV/geohashing-and-quadtrees/quadtree.png)

Quadtrees enable us to search points within a two-dimensional range efficiently, where those points are defined as latitude/longitude coordinates or as cartesian (x, y) coordinates.

We can save further computation by only subdividing a node after a certain threshold.

![quadtree-subdivision](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-IV/geohashing-and-quadtrees/quadtree-subdivision.png)

[Quadtree](/courses/sytem-design/geohashing-and-quadtrees#quadtrees) seems perfect for our use case, we can update the Quadtree every time we receive a new location update from the driver. To reduce the load on the quadtree servers we can use an in-memory datastore such as [Redis](https://redis.io) to cache the latest updates. And with the application of mapping algorithms such as the [Hilbert curve](https://en.wikipedia.org/wiki/Hilbert_curve), we can perform efficient range queries to find nearby drivers for the customer.

**What about race conditions?**

Race conditions can easily occur when a large number of customers will be requesting rides simultaneously. To avoid this, we can wrap our ride matching logic in a [Mutex](<https://en.wikipedia.org/wiki/Lock_(computer_science)>) to avoid any race conditions. Furthermore, every action should be transactional in nature.

_For more details, refer to [Transactions](https://karanpratapsingh.com/courses/system-design/transactions) and [Distributed Transactions](https://karanpratapsingh.com/courses/system-design/distributed-transactions)._

**How to find the best drivers nearby?**

Once we have a list of nearby drivers from the Quadtree servers, we can perform some sort of ranking based on parameters like average ratings, relevance, past customer feedback, etc. This will allow us to broadcast notifications to the best available drivers first.

**Dealing with high demand**

In cases of high demand, we can use the concept of Surge Pricing. Surge pricing is a dynamic pricing method where prices are temporarily increased as a reaction to increased demand and mostly limited supply. This surge price can be added to the base price of the trip.

_For more details, learn how [surge pricing works](https://www.uber.com/us/en/drive/driver-app/how-surge-works) with Uber._

### Payments

Handling payments at scale is challenging, to simplify our system we can use a third-party payment processor like [Stripe](https://stripe.com) or [PayPal](https://www.paypal.com). Once the payment is complete, the payment processor will redirect the user back to our application and we can set up a [webhook](https://en.wikipedia.org/wiki/Webhook) to capture all the payment-related data.

### Notifications

Push notifications will be an integral part of our platform. We can use a message queue or a message broker such as [Apache Kafka](https://kafka.apache.org) with the notification service to dispatch requests to [Firebase Cloud Messaging (FCM)](https://firebase.google.com/docs/cloud-messaging) or [Apple Push Notification Service (APNS)](https://developer.apple.com/documentation/usernotifications) which will handle the delivery of the push notifications to user devices.

_For more details, refer to the [WhatsApp](https://karanpratapsingh.com/courses/system-design/whatsapp#notifications) system design where we discuss push notifications in detail._

## Detailed design

It's time to discuss our design decisions in detail.

### Data Partitioning

To scale out our databases we will need to partition our data. Horizontal partitioning (aka [Sharding](https://karanpratapsingh.com/courses/system-design/sharding)) can be a good first step. We can shard our database either based on existing [partition schemes](https://karanpratapsingh.com/courses/system-design/sharding#partitioning-criteria) or regions. If we divide the locations into regions using let's say zip codes, we can effectively store all the data in a given region on a fixed node. But this can still cause uneven data and load distribution, we can solve this using [Consistent hashing](https://karanpratapsingh.com/courses/system-design/consistent-hashing).

_For more details, refer to [Sharding](https://karanpratapsingh.com/courses/system-design/sharding) and [Consistent Hashing](https://karanpratapsingh.com/courses/system-design/consistent-hashing)._

### Metrics and Analytics

Recording analytics and metrics is one of our extended requirements. We can capture the data from different services and run analytics on the data using [Apache Spark](https://spark.apache.org) which is an open-source unified analytics engine for large-scale data processing. Additionally, we can store critical metadata in the views table to increase data points within our data.

### Caching

In a location services-based platform, caching is important. We have to be able to cache the recent locations of the customers and drivers for fast retrieval. We can use solutions like [Redis](https://redis.io) or [Memcached](https://memcached.org) but what kind of cache eviction policy would best fit our needs?

**Which cache eviction policy to use?**

[Least Recently Used (LRU)](<https://en.wikipedia.org/wiki/Cache_replacement_policies#Least_recently_used_(LRU)>) can be a good policy for our system. In this policy, we discard the least recently used key first.

**How to handle cache miss?**

Whenever there is a cache miss, our servers can hit the database directly and update the cache with the new entries.

_For more details, refer to [Caching](https://karanpratapsingh.com/courses/system-design/caching)._

## Identify and resolve bottlenecks

![uber-advanced-design](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-V/uber/uber-advanced-design.png)

Let us identify and resolve bottlenecks such as single points of failure in our design:

- "What if one of our services crashes?"
- "How will we distribute our traffic between our components?"
- "How can we reduce the load on our database?"
- "How to improve the availability of our cache?"
- "How can we make our notification system more robust?"

To make our system more resilient we can do the following:

- Running multiple instances of each of our services.
- Introducing [load balancers](https://karanpratapsingh.com/courses/system-design/load-balancing) between clients, servers, databases, and cache servers.
- Using multiple read replicas for our databases.
- Multiple instances and replicas for our distributed cache.
- Exactly once delivery and message ordering is challenging in a distributed system, we can use a dedicated [message broker](https://karanpratapsingh.com/courses/system-design/message-brokers) such as [Apache Kafka](https://kafka.apache.org) or [NATS](https://nats.io) to make our notification system more robust.

# Next Steps

Congratulations, you've finished the course!

Now that you know the fundamentals of System Design, here are some additional resources:

- [Distributed Systems](https://www.youtube.com/watch?v=UEAMfLPZZhE&list=PLeKd45zvjcDFUEv_ohr_HdUFe97RItdiB) (by Dr. Martin Kleppmann)
- [System Design Interview: An Insider's Guide](https://www.amazon.in/System-Design-Interview-insiders-Second/dp/B08CMF2CQF)
- [Microservices](https://microservices.io) (by Chris Richardson)
- [Serverless computing](https://en.wikipedia.org/wiki/Serverless_computing)
- [Kubernetes](https://kubernetes.io)

It is also recommended to actively follow engineering blogs of companies putting what we learned in the course into practice at scale:

- [Microsoft Engineering](https://engineering.microsoft.com)
- [Google Research Blog](http://googleresearch.blogspot.com)
- [Netflix Tech Blog](http://techblog.netflix.com)
- [AWS Blog](https://aws.amazon.com/blogs/aws)
- [Facebook Engineering](https://www.facebook.com/Engineering)
- [Uber Engineering Blog](http://eng.uber.com)
- [Airbnb Engineering](http://nerds.airbnb.com)
- [GitHub Engineering Blog](https://github.blog/category/engineering)
- [Intel Software Blog](https://software.intel.com/en-us/blogs)
- [LinkedIn Engineering](http://engineering.linkedin.com/blog)
- [Paypal Developer Blog](https://medium.com/paypal-engineering)
- [Twitter Engineering](https://blog.twitter.com/engineering)

Last but not least, volunteer for new projects at your company, and learn from senior engineers and architects to further improve your system design skills.

I hope this course was a great learning experience. I would love to hear feedback from you.

Wishing you all the best for further learning!

# References

Here are the resources that were referenced while creating this course.

- [Cloudflare learning center](https://www.cloudflare.com/learning)
- [IBM Blogs](https://www.ibm.com/blogs)
- [Fastly Blogs](https://www.fastly.com/blog)
- [NS1 Blogs](https://ns1.com/blog)
- [Grokking the System Design Interview](https://www.educative.io/courses/grokking-the-system-design-interview)
- [System Design Primer](https://github.com/donnemartin/system-design-primer)
- [AWS Blogs](https://aws.amazon.com/blogs)
- [Martin Fowler](https://martinfowler.com)
- [PagerDuty resources](https://www.pagerduty.com/resources)
- [VMWare Blogs](https://blogs.vmware.com/learning)

_All the diagrams were made using [Excalidraw](https://excalidraw.com) and are available [here](https://github.com/karanpratapsingh/system-design/tree/main/diagrams)._
